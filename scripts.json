[
  {
    "id": "suavizar-segmentos-curvos-tcbdn",
    "title": {
      "pt": "Suavizar Segmentos Curvos",
      "en": "Suavizar Segmentos Curvos",
      "es": "Suavizar Segmentos Curvos"
    },
    "author": "Fábio Coutinho",
    "version": "0.5",
    "description": {
      "pt": "Adiciona segmentos em sequência de arestas (curva) para tornar mais suave.",
      "en": "Adiciona segmentos em sequência de arestas (curva) para tornar mais suave.",
      "es": "Adiciona segmentos em sequência de arestas (curva) para tornar mais suave."
    },
    "keywords": {
      "pt": [
        "suaviza curva"
      ],
      "en": [
        "suaviza curva"
      ],
      "es": [
        "suaviza curva"
      ]
    },
    "code": {
      "pt": "require 'sketchup.rb'\r\n\r\nclass SmoothPolyTool\r\n  \r\n  def initialize\r\n    @model = Sketchup.active_model\r\n    @selection = @model.selection\r\n    @view = @model.active_view\r\n    \r\n    @density_multiplier = 1\r\n    @is_loop = false \r\n    \r\n    # Coleta dados iniciais\r\n    @ordered_vertices = get_ordered_vertices(@selection)\r\n    \r\n    if @ordered_vertices.length < 2\r\n      UI.messagebox(\"Selecione uma sequência de arestas conectadas primeiro.\")\r\n      @model.select_tool(nil)\r\n      return\r\n    end\r\n\r\n    @original_segment_count = @is_loop ? @ordered_vertices.length : @ordered_vertices.length - 1\r\n    calculate_distribution_metrics\r\n\r\n    @spline_points = []\r\n    calculate_spline\r\n    \r\n    create_dialog\r\n  end\r\n\r\n  def activate\r\n    @view.invalidate\r\n    update_status\r\n  end\r\n\r\n  # Chamado quando a ferramenta é desativada (ex: usuário trocou de ferramenta ou fechou a janela)\r\n  def deactivate(view)\r\n    # Fecha a janela se ela ainda estiver aberta\r\n    if @dialog && @dialog.visible?\r\n      @dialog.close \r\n    end\r\n    @view.invalidate\r\n  end\r\n\r\n  def draw(view)\r\n    # 1. Caminho Laranja\r\n    if @spline_points && @spline_points.size > 1\r\n      view.line_width = 3\r\n      view.line_stipple = \"\" \r\n      view.drawing_color = \"orange\"\r\n      mode = @is_loop ? GL_LINE_LOOP : GL_LINE_STRIP\r\n      view.draw(mode, @spline_points)\r\n    end\r\n\r\n    # 2. Nós Vermelhos\r\n    if @spline_points && !@spline_points.empty?\r\n      if view.respond_to?(:draw_points)\r\n        view.draw_points(@spline_points, 8, 2, \"red\") \r\n      else\r\n        view.drawing_color = \"red\"\r\n        view.point_size = 8 if view.respond_to?(:point_size=)\r\n        view.draw(GL_POINTS, @spline_points)\r\n      end\r\n    end\r\n  end\r\n\r\n  # --- UI ---\r\n  def create_dialog\r\n    if defined?(UI::HtmlDialog)\r\n      @dialog = UI::HtmlDialog.new({\r\n        :dialog_title => \"Suavizar (Loop & Adaptativo)\",\r\n        :preferences_key => \"com.example.smooth_poly_final\",\r\n        :scrollable => false,\r\n        :resizable => false,\r\n        :width => 320,\r\n        :height => 260, \r\n        :style => UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n      \r\n      # --- CORREÇÃO AQUI: Detecta o fechamento da janela (botão X) ---\r\n      @dialog.set_on_closed {\r\n        # Força a saída da ferramenta selecionando 'nil' (Select Tool)\r\n        Sketchup.active_model.select_tool(nil)\r\n      }\r\n      # ---------------------------------------------------------------\r\n      \r\n    else\r\n      @dialog = UI::WebDialog.new(\"Suavizar\", false, \"SmoothPolyFinal\", 320, 260, 100, 100, true)\r\n      # WebDialog antigo não tem um set_on_closed confiável igual ao HtmlDialog,\r\n      # mas para versões modernas (2017+) o bloco acima resolve.\r\n    end\r\n\r\n    html_content = %{\r\n      <!DOCTYPE html>\r\n      <html>\r\n      <head>\r\n        <style>\r\n          body { font-family: 'Segoe UI', sans-serif; font-size: 12px; padding: 15px; background-color: #f5f5f5; color: #333; overflow: hidden; }\r\n          .container { display: flex; flex-direction: column; gap: 12px; }\r\n          .header { display: flex; justify-content: space-between; align-items: center; }\r\n          label { font-weight: 600; font-size: 13px; }\r\n          input[type=range] { width: 100%; cursor: pointer; }\r\n          .val-display { \r\n            background: #fff; border: 1px solid #ccc; padding: 2px 8px; \r\n            border-radius: 4px; font-weight: bold; color: #E65100; min-width: 30px; text-align: center;\r\n          }\r\n          button { \r\n            padding: 10px; cursor: pointer; background: #2196F3; color: white; \r\n            border: none; border-radius: 4px; font-weight: bold; font-size: 13px;\r\n            text-transform: uppercase; letter-spacing: 0.5px; transition: background 0.2s; margin-top: 5px;\r\n          }\r\n          button:hover { background: #1976D2; }\r\n          .note { font-size: 11px; color: #666; font-style: italic; line-height: 1.3; }\r\n          .tag { font-size: 10px; background: #4CAF50; color: white; padding: 2px 5px; border-radius: 3px; }\r\n        </style>\r\n      </head>\r\n      <body>\r\n        <div class=\"container\">\r\n          <div class=\"header\">\r\n            <label>Densidade:</label>\r\n            <div class=\"val-display\">x<span id=\"val\">1</span></div>\r\n          </div>\r\n          \r\n          <input type=\"range\" id=\"slider\" min=\"1\" max=\"10\" step=\"1\" value=\"1\" oninput=\"updateVal(this.value)\">\r\n          \r\n          <div class=\"note\">\r\n            <span id=\"loop-msg\" style=\"display:none;\" class=\"tag\">LOOP DETECTADO</span><br>\r\n            Ajuste a densidade. A distribuição é adaptativa (foca em curvas) e contínua.\r\n          </div>\r\n\r\n          <button onclick=\"sendApply()\">Concluir (Aplicar)</button>\r\n        </div>\r\n        <script>\r\n          function updateVal(val) {\r\n            document.getElementById('val').innerText = val;\r\n            if (window.sketchup) { sketchup.on_slide(val); } \r\n            else { window.location = 'skp:on_slide@' + val; }\r\n          }\r\n          \r\n          function sendApply() {\r\n            if (window.sketchup) { sketchup.on_apply(); } \r\n            else { window.location = 'skp:on_apply'; }\r\n          }\r\n\r\n          function setLoopStatus(isLoop) {\r\n             if(isLoop) document.getElementById('loop-msg').style.display = 'inline-block';\r\n          }\r\n        </script>\r\n      </body>\r\n      </html>\r\n    }\r\n\r\n    @dialog.set_html(html_content)\r\n    \r\n    @dialog.add_action_callback(\"on_slide\") { |_, val|\r\n      @density_multiplier = val.to_i\r\n      calculate_spline\r\n      @view.invalidate\r\n    }\r\n\r\n    @dialog.add_action_callback(\"on_apply\") { \r\n      commit_geometry\r\n      # Ao selecionar nil aqui, o método deactivate será chamado, fechando a janela\r\n      @model.select_tool(nil)\r\n    }\r\n\r\n    @dialog.add_action_callback(\"exec_js\") { |_, js| @dialog.execute_script(js) }\r\n    \r\n    if @dialog.respond_to?(:center)\r\n      @dialog.center\r\n      @dialog.show\r\n    else\r\n      @dialog.show\r\n    end\r\n\r\n    UI.start_timer(0.5, false) { \r\n      @dialog.execute_script(\"setLoopStatus(#{@is_loop});\") if @dialog.visible?\r\n    }\r\n  end\r\n\r\n  # --- Lógica Matemática ---\r\n\r\n  def get_neighbors(i, points)\r\n    n = points.length\r\n    if @is_loop\r\n      p0 = points[(i - 1) % n]\r\n      p1 = points[i]\r\n      p2 = points[(i + 1) % n]\r\n      p3 = points[(i + 2) % n]\r\n    else\r\n      p0 = i == 0 ? points[0] : points[i-1]\r\n      p1 = points[i]\r\n      p2 = (i+1 >= n) ? points[n-1] : points[i+1]\r\n      p3 = (i+2 >= n) ? points[n-1] : points[i+2]\r\n    end\r\n    return p0, p1, p2, p3\r\n  end\r\n\r\n  def calculate_distribution_metrics\r\n    points = @ordered_vertices\r\n    @segment_weights = []\r\n    total_w = 0.0\r\n    limit = @is_loop ? points.length : points.length - 1\r\n\r\n    (0...limit).each do |i|\r\n      p0, p1, p2, p3 = get_neighbors(i, points)\r\n      len = p1.distance(p2)\r\n      \r\n      v_prev = p1 - p0\r\n      v_curr = p2 - p1\r\n      v_next = p3 - p2\r\n\r\n      angle_start = (v_prev.length > 0 && v_curr.length > 0) ? v_prev.angle_between(v_curr) : 0\r\n      angle_end   = (v_curr.length > 0 && v_next.length > 0) ? v_curr.angle_between(v_next) : 0\r\n      \r\n      avg_curvature = (angle_start + angle_end) / 2.0\r\n      curvature_factor = 1.0 + (avg_curvature * 3.0)\r\n\r\n      weighted_len = len * curvature_factor\r\n      @segment_weights << weighted_len\r\n      total_w += weighted_len\r\n    end\r\n    @total_weighted_length = total_w\r\n  end\r\n\r\n  def calculate_spline\r\n    return if @ordered_vertices.empty?\r\n    points = @ordered_vertices\r\n    @spline_points = []\r\n    \r\n    target_total_segments = [(@original_segment_count * @density_multiplier).round, 1].max\r\n    points_accumulator = 0.0\r\n    limit = @is_loop ? points.length : points.length - 1\r\n\r\n    (0...limit).each do |i|\r\n      p0, p1, p2, p3 = get_neighbors(i, points)\r\n      @spline_points << p1\r\n      \r\n      weighted_len = @segment_weights[i]\r\n      ratio = (@total_weighted_length > 0) ? (weighted_len / @total_weighted_length) : 0\r\n\r\n      exact_steps = ratio * target_total_segments\r\n      points_accumulator += exact_steps\r\n      \r\n      steps_to_draw = points_accumulator.floor\r\n      points_accumulator -= steps_to_draw\r\n\r\n      steps_final = steps_to_draw + 1\r\n\r\n      (1...steps_final).each do |t_step|\r\n        t = t_step.to_f / steps_final\r\n        @spline_points << catmull_rom(p0, p1, p2, p3, t)\r\n      end\r\n    end\r\n    \r\n    if @is_loop\r\n      @spline_points << @spline_points.first\r\n    else\r\n      @spline_points << points.last\r\n    end\r\n  end\r\n\r\n  def catmull_rom(p0, p1, p2, p3, t)\r\n    t2 = t * t\r\n    t3 = t2 * t\r\n    x = 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * t + (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 + (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3)\r\n    y = 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3)\r\n    z = 0.5 * ((2 * p1.z) + (-p0.z + p2.z) * t + (2 * p0.z - 5 * p1.z + 4 * p2.z - p3.z) * t2 + (-p0.z + 3 * p1.z - 3 * p2.z + p3.z) * t3)\r\n    Geom::Point3d.new(x, y, z)\r\n  end\r\n\r\n  def commit_geometry\r\n    edges_to_delete = @selection.grep(Sketchup::Edge)\r\n    return if edges_to_delete.empty?\r\n    \r\n    @model.start_operation(\"Suavizar (Loop)\", true)\r\n    @model.active_entities.erase_entities(edges_to_delete)\r\n    if @spline_points.size > 1\r\n      @model.active_entities.add_curve(@spline_points)\r\n    end\r\n    @model.commit_operation\r\n    @spline_points = []\r\n  end\r\n\r\n  def get_ordered_vertices(selection)\r\n    edges = selection.grep(Sketchup::Edge)\r\n    return [] if edges.empty?\r\n\r\n    vertices = edges.map(&:vertices).flatten\r\n    counts = vertices.each_with_object(Hash.new(0)) { |v, h| h[v] += 1 }\r\n    \r\n    if counts.values.all? { |c| c == 2 }\r\n      @is_loop = true\r\n      start_vertex = edges.first.start \r\n    else\r\n      @is_loop = false\r\n      start_vertex = counts.key(1) \r\n    end\r\n    \r\n    start_vertex ||= edges.first.start \r\n\r\n    sorted_points = [start_vertex.position]\r\n    current_v = start_vertex\r\n    visited_edges = []\r\n    \r\n    while true\r\n      next_edge = current_v.edges.find { |e| edges.include?(e) && !visited_edges.include?(e) }\r\n      break unless next_edge\r\n      visited_edges << next_edge\r\n      other_v = next_edge.other_vertex(current_v)\r\n      if @is_loop && other_v == start_vertex\r\n        break\r\n      end\r\n      sorted_points << other_v.position\r\n      current_v = other_v\r\n    end\r\n\r\n    sorted_points\r\n  end\r\n  \r\n  def update_status\r\n     Sketchup.set_status_text(\"Suavizar: Loop = #{@is_loop ? 'Sim' : 'Não'}\")\r\n  end\r\nend\r\n\r\nSketchup.active_model.select_tool(SmoothPolyTool.new)",
      "en": "require 'sketchup.rb'\r\n\r\nclass SmoothPolyTool\r\n  \r\n  def initialize\r\n    @model = Sketchup.active_model\r\n    @selection = @model.selection\r\n    @view = @model.active_view\r\n    \r\n    @density_multiplier = 1\r\n    @is_loop = false \r\n    \r\n    # Coleta dados iniciais\r\n    @ordered_vertices = get_ordered_vertices(@selection)\r\n    \r\n    if @ordered_vertices.length < 2\r\n      UI.messagebox(\"Selecione uma sequência de arestas conectadas primeiro.\")\r\n      @model.select_tool(nil)\r\n      return\r\n    end\r\n\r\n    @original_segment_count = @is_loop ? @ordered_vertices.length : @ordered_vertices.length - 1\r\n    calculate_distribution_metrics\r\n\r\n    @spline_points = []\r\n    calculate_spline\r\n    \r\n    create_dialog\r\n  end\r\n\r\n  def activate\r\n    @view.invalidate\r\n    update_status\r\n  end\r\n\r\n  # Chamado quando a ferramenta é desativada (ex: usuário trocou de ferramenta ou fechou a janela)\r\n  def deactivate(view)\r\n    # Fecha a janela se ela ainda estiver aberta\r\n    if @dialog && @dialog.visible?\r\n      @dialog.close \r\n    end\r\n    @view.invalidate\r\n  end\r\n\r\n  def draw(view)\r\n    # 1. Caminho Laranja\r\n    if @spline_points && @spline_points.size > 1\r\n      view.line_width = 3\r\n      view.line_stipple = \"\" \r\n      view.drawing_color = \"orange\"\r\n      mode = @is_loop ? GL_LINE_LOOP : GL_LINE_STRIP\r\n      view.draw(mode, @spline_points)\r\n    end\r\n\r\n    # 2. Nós Vermelhos\r\n    if @spline_points && !@spline_points.empty?\r\n      if view.respond_to?(:draw_points)\r\n        view.draw_points(@spline_points, 8, 2, \"red\") \r\n      else\r\n        view.drawing_color = \"red\"\r\n        view.point_size = 8 if view.respond_to?(:point_size=)\r\n        view.draw(GL_POINTS, @spline_points)\r\n      end\r\n    end\r\n  end\r\n\r\n  # --- UI ---\r\n  def create_dialog\r\n    if defined?(UI::HtmlDialog)\r\n      @dialog = UI::HtmlDialog.new({\r\n        :dialog_title => \"Suavizar (Loop & Adaptativo)\",\r\n        :preferences_key => \"com.example.smooth_poly_final\",\r\n        :scrollable => false,\r\n        :resizable => false,\r\n        :width => 320,\r\n        :height => 260, \r\n        :style => UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n      \r\n      # --- CORREÇÃO AQUI: Detecta o fechamento da janela (botão X) ---\r\n      @dialog.set_on_closed {\r\n        # Força a saída da ferramenta selecionando 'nil' (Select Tool)\r\n        Sketchup.active_model.select_tool(nil)\r\n      }\r\n      # ---------------------------------------------------------------\r\n      \r\n    else\r\n      @dialog = UI::WebDialog.new(\"Suavizar\", false, \"SmoothPolyFinal\", 320, 260, 100, 100, true)\r\n      # WebDialog antigo não tem um set_on_closed confiável igual ao HtmlDialog,\r\n      # mas para versões modernas (2017+) o bloco acima resolve.\r\n    end\r\n\r\n    html_content = %{\r\n      <!DOCTYPE html>\r\n      <html>\r\n      <head>\r\n        <style>\r\n          body { font-family: 'Segoe UI', sans-serif; font-size: 12px; padding: 15px; background-color: #f5f5f5; color: #333; overflow: hidden; }\r\n          .container { display: flex; flex-direction: column; gap: 12px; }\r\n          .header { display: flex; justify-content: space-between; align-items: center; }\r\n          label { font-weight: 600; font-size: 13px; }\r\n          input[type=range] { width: 100%; cursor: pointer; }\r\n          .val-display { \r\n            background: #fff; border: 1px solid #ccc; padding: 2px 8px; \r\n            border-radius: 4px; font-weight: bold; color: #E65100; min-width: 30px; text-align: center;\r\n          }\r\n          button { \r\n            padding: 10px; cursor: pointer; background: #2196F3; color: white; \r\n            border: none; border-radius: 4px; font-weight: bold; font-size: 13px;\r\n            text-transform: uppercase; letter-spacing: 0.5px; transition: background 0.2s; margin-top: 5px;\r\n          }\r\n          button:hover { background: #1976D2; }\r\n          .note { font-size: 11px; color: #666; font-style: italic; line-height: 1.3; }\r\n          .tag { font-size: 10px; background: #4CAF50; color: white; padding: 2px 5px; border-radius: 3px; }\r\n        </style>\r\n      </head>\r\n      <body>\r\n        <div class=\"container\">\r\n          <div class=\"header\">\r\n            <label>Densidade:</label>\r\n            <div class=\"val-display\">x<span id=\"val\">1</span></div>\r\n          </div>\r\n          \r\n          <input type=\"range\" id=\"slider\" min=\"1\" max=\"10\" step=\"1\" value=\"1\" oninput=\"updateVal(this.value)\">\r\n          \r\n          <div class=\"note\">\r\n            <span id=\"loop-msg\" style=\"display:none;\" class=\"tag\">LOOP DETECTADO</span><br>\r\n            Ajuste a densidade. A distribuição é adaptativa (foca em curvas) e contínua.\r\n          </div>\r\n\r\n          <button onclick=\"sendApply()\">Concluir (Aplicar)</button>\r\n        </div>\r\n        <script>\r\n          function updateVal(val) {\r\n            document.getElementById('val').innerText = val;\r\n            if (window.sketchup) { sketchup.on_slide(val); } \r\n            else { window.location = 'skp:on_slide@' + val; }\r\n          }\r\n          \r\n          function sendApply() {\r\n            if (window.sketchup) { sketchup.on_apply(); } \r\n            else { window.location = 'skp:on_apply'; }\r\n          }\r\n\r\n          function setLoopStatus(isLoop) {\r\n             if(isLoop) document.getElementById('loop-msg').style.display = 'inline-block';\r\n          }\r\n        </script>\r\n      </body>\r\n      </html>\r\n    }\r\n\r\n    @dialog.set_html(html_content)\r\n    \r\n    @dialog.add_action_callback(\"on_slide\") { |_, val|\r\n      @density_multiplier = val.to_i\r\n      calculate_spline\r\n      @view.invalidate\r\n    }\r\n\r\n    @dialog.add_action_callback(\"on_apply\") { \r\n      commit_geometry\r\n      # Ao selecionar nil aqui, o método deactivate será chamado, fechando a janela\r\n      @model.select_tool(nil)\r\n    }\r\n\r\n    @dialog.add_action_callback(\"exec_js\") { |_, js| @dialog.execute_script(js) }\r\n    \r\n    if @dialog.respond_to?(:center)\r\n      @dialog.center\r\n      @dialog.show\r\n    else\r\n      @dialog.show\r\n    end\r\n\r\n    UI.start_timer(0.5, false) { \r\n      @dialog.execute_script(\"setLoopStatus(#{@is_loop});\") if @dialog.visible?\r\n    }\r\n  end\r\n\r\n  # --- Lógica Matemática ---\r\n\r\n  def get_neighbors(i, points)\r\n    n = points.length\r\n    if @is_loop\r\n      p0 = points[(i - 1) % n]\r\n      p1 = points[i]\r\n      p2 = points[(i + 1) % n]\r\n      p3 = points[(i + 2) % n]\r\n    else\r\n      p0 = i == 0 ? points[0] : points[i-1]\r\n      p1 = points[i]\r\n      p2 = (i+1 >= n) ? points[n-1] : points[i+1]\r\n      p3 = (i+2 >= n) ? points[n-1] : points[i+2]\r\n    end\r\n    return p0, p1, p2, p3\r\n  end\r\n\r\n  def calculate_distribution_metrics\r\n    points = @ordered_vertices\r\n    @segment_weights = []\r\n    total_w = 0.0\r\n    limit = @is_loop ? points.length : points.length - 1\r\n\r\n    (0...limit).each do |i|\r\n      p0, p1, p2, p3 = get_neighbors(i, points)\r\n      len = p1.distance(p2)\r\n      \r\n      v_prev = p1 - p0\r\n      v_curr = p2 - p1\r\n      v_next = p3 - p2\r\n\r\n      angle_start = (v_prev.length > 0 && v_curr.length > 0) ? v_prev.angle_between(v_curr) : 0\r\n      angle_end   = (v_curr.length > 0 && v_next.length > 0) ? v_curr.angle_between(v_next) : 0\r\n      \r\n      avg_curvature = (angle_start + angle_end) / 2.0\r\n      curvature_factor = 1.0 + (avg_curvature * 3.0)\r\n\r\n      weighted_len = len * curvature_factor\r\n      @segment_weights << weighted_len\r\n      total_w += weighted_len\r\n    end\r\n    @total_weighted_length = total_w\r\n  end\r\n\r\n  def calculate_spline\r\n    return if @ordered_vertices.empty?\r\n    points = @ordered_vertices\r\n    @spline_points = []\r\n    \r\n    target_total_segments = [(@original_segment_count * @density_multiplier).round, 1].max\r\n    points_accumulator = 0.0\r\n    limit = @is_loop ? points.length : points.length - 1\r\n\r\n    (0...limit).each do |i|\r\n      p0, p1, p2, p3 = get_neighbors(i, points)\r\n      @spline_points << p1\r\n      \r\n      weighted_len = @segment_weights[i]\r\n      ratio = (@total_weighted_length > 0) ? (weighted_len / @total_weighted_length) : 0\r\n\r\n      exact_steps = ratio * target_total_segments\r\n      points_accumulator += exact_steps\r\n      \r\n      steps_to_draw = points_accumulator.floor\r\n      points_accumulator -= steps_to_draw\r\n\r\n      steps_final = steps_to_draw + 1\r\n\r\n      (1...steps_final).each do |t_step|\r\n        t = t_step.to_f / steps_final\r\n        @spline_points << catmull_rom(p0, p1, p2, p3, t)\r\n      end\r\n    end\r\n    \r\n    if @is_loop\r\n      @spline_points << @spline_points.first\r\n    else\r\n      @spline_points << points.last\r\n    end\r\n  end\r\n\r\n  def catmull_rom(p0, p1, p2, p3, t)\r\n    t2 = t * t\r\n    t3 = t2 * t\r\n    x = 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * t + (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 + (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3)\r\n    y = 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3)\r\n    z = 0.5 * ((2 * p1.z) + (-p0.z + p2.z) * t + (2 * p0.z - 5 * p1.z + 4 * p2.z - p3.z) * t2 + (-p0.z + 3 * p1.z - 3 * p2.z + p3.z) * t3)\r\n    Geom::Point3d.new(x, y, z)\r\n  end\r\n\r\n  def commit_geometry\r\n    edges_to_delete = @selection.grep(Sketchup::Edge)\r\n    return if edges_to_delete.empty?\r\n    \r\n    @model.start_operation(\"Suavizar (Loop)\", true)\r\n    @model.active_entities.erase_entities(edges_to_delete)\r\n    if @spline_points.size > 1\r\n      @model.active_entities.add_curve(@spline_points)\r\n    end\r\n    @model.commit_operation\r\n    @spline_points = []\r\n  end\r\n\r\n  def get_ordered_vertices(selection)\r\n    edges = selection.grep(Sketchup::Edge)\r\n    return [] if edges.empty?\r\n\r\n    vertices = edges.map(&:vertices).flatten\r\n    counts = vertices.each_with_object(Hash.new(0)) { |v, h| h[v] += 1 }\r\n    \r\n    if counts.values.all? { |c| c == 2 }\r\n      @is_loop = true\r\n      start_vertex = edges.first.start \r\n    else\r\n      @is_loop = false\r\n      start_vertex = counts.key(1) \r\n    end\r\n    \r\n    start_vertex ||= edges.first.start \r\n\r\n    sorted_points = [start_vertex.position]\r\n    current_v = start_vertex\r\n    visited_edges = []\r\n    \r\n    while true\r\n      next_edge = current_v.edges.find { |e| edges.include?(e) && !visited_edges.include?(e) }\r\n      break unless next_edge\r\n      visited_edges << next_edge\r\n      other_v = next_edge.other_vertex(current_v)\r\n      if @is_loop && other_v == start_vertex\r\n        break\r\n      end\r\n      sorted_points << other_v.position\r\n      current_v = other_v\r\n    end\r\n\r\n    sorted_points\r\n  end\r\n  \r\n  def update_status\r\n     Sketchup.set_status_text(\"Suavizar: Loop = #{@is_loop ? 'Sim' : 'Não'}\")\r\n  end\r\nend\r\n\r\nSketchup.active_model.select_tool(SmoothPolyTool.new)",
      "es": "require 'sketchup.rb'\r\n\r\nclass SmoothPolyTool\r\n  \r\n  def initialize\r\n    @model = Sketchup.active_model\r\n    @selection = @model.selection\r\n    @view = @model.active_view\r\n    \r\n    @density_multiplier = 1\r\n    @is_loop = false \r\n    \r\n    # Coleta dados iniciais\r\n    @ordered_vertices = get_ordered_vertices(@selection)\r\n    \r\n    if @ordered_vertices.length < 2\r\n      UI.messagebox(\"Selecione uma sequência de arestas conectadas primeiro.\")\r\n      @model.select_tool(nil)\r\n      return\r\n    end\r\n\r\n    @original_segment_count = @is_loop ? @ordered_vertices.length : @ordered_vertices.length - 1\r\n    calculate_distribution_metrics\r\n\r\n    @spline_points = []\r\n    calculate_spline\r\n    \r\n    create_dialog\r\n  end\r\n\r\n  def activate\r\n    @view.invalidate\r\n    update_status\r\n  end\r\n\r\n  # Chamado quando a ferramenta é desativada (ex: usuário trocou de ferramenta ou fechou a janela)\r\n  def deactivate(view)\r\n    # Fecha a janela se ela ainda estiver aberta\r\n    if @dialog && @dialog.visible?\r\n      @dialog.close \r\n    end\r\n    @view.invalidate\r\n  end\r\n\r\n  def draw(view)\r\n    # 1. Caminho Laranja\r\n    if @spline_points && @spline_points.size > 1\r\n      view.line_width = 3\r\n      view.line_stipple = \"\" \r\n      view.drawing_color = \"orange\"\r\n      mode = @is_loop ? GL_LINE_LOOP : GL_LINE_STRIP\r\n      view.draw(mode, @spline_points)\r\n    end\r\n\r\n    # 2. Nós Vermelhos\r\n    if @spline_points && !@spline_points.empty?\r\n      if view.respond_to?(:draw_points)\r\n        view.draw_points(@spline_points, 8, 2, \"red\") \r\n      else\r\n        view.drawing_color = \"red\"\r\n        view.point_size = 8 if view.respond_to?(:point_size=)\r\n        view.draw(GL_POINTS, @spline_points)\r\n      end\r\n    end\r\n  end\r\n\r\n  # --- UI ---\r\n  def create_dialog\r\n    if defined?(UI::HtmlDialog)\r\n      @dialog = UI::HtmlDialog.new({\r\n        :dialog_title => \"Suavizar (Loop & Adaptativo)\",\r\n        :preferences_key => \"com.example.smooth_poly_final\",\r\n        :scrollable => false,\r\n        :resizable => false,\r\n        :width => 320,\r\n        :height => 260, \r\n        :style => UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n      \r\n      # --- CORREÇÃO AQUI: Detecta o fechamento da janela (botão X) ---\r\n      @dialog.set_on_closed {\r\n        # Força a saída da ferramenta selecionando 'nil' (Select Tool)\r\n        Sketchup.active_model.select_tool(nil)\r\n      }\r\n      # ---------------------------------------------------------------\r\n      \r\n    else\r\n      @dialog = UI::WebDialog.new(\"Suavizar\", false, \"SmoothPolyFinal\", 320, 260, 100, 100, true)\r\n      # WebDialog antigo não tem um set_on_closed confiável igual ao HtmlDialog,\r\n      # mas para versões modernas (2017+) o bloco acima resolve.\r\n    end\r\n\r\n    html_content = %{\r\n      <!DOCTYPE html>\r\n      <html>\r\n      <head>\r\n        <style>\r\n          body { font-family: 'Segoe UI', sans-serif; font-size: 12px; padding: 15px; background-color: #f5f5f5; color: #333; overflow: hidden; }\r\n          .container { display: flex; flex-direction: column; gap: 12px; }\r\n          .header { display: flex; justify-content: space-between; align-items: center; }\r\n          label { font-weight: 600; font-size: 13px; }\r\n          input[type=range] { width: 100%; cursor: pointer; }\r\n          .val-display { \r\n            background: #fff; border: 1px solid #ccc; padding: 2px 8px; \r\n            border-radius: 4px; font-weight: bold; color: #E65100; min-width: 30px; text-align: center;\r\n          }\r\n          button { \r\n            padding: 10px; cursor: pointer; background: #2196F3; color: white; \r\n            border: none; border-radius: 4px; font-weight: bold; font-size: 13px;\r\n            text-transform: uppercase; letter-spacing: 0.5px; transition: background 0.2s; margin-top: 5px;\r\n          }\r\n          button:hover { background: #1976D2; }\r\n          .note { font-size: 11px; color: #666; font-style: italic; line-height: 1.3; }\r\n          .tag { font-size: 10px; background: #4CAF50; color: white; padding: 2px 5px; border-radius: 3px; }\r\n        </style>\r\n      </head>\r\n      <body>\r\n        <div class=\"container\">\r\n          <div class=\"header\">\r\n            <label>Densidade:</label>\r\n            <div class=\"val-display\">x<span id=\"val\">1</span></div>\r\n          </div>\r\n          \r\n          <input type=\"range\" id=\"slider\" min=\"1\" max=\"10\" step=\"1\" value=\"1\" oninput=\"updateVal(this.value)\">\r\n          \r\n          <div class=\"note\">\r\n            <span id=\"loop-msg\" style=\"display:none;\" class=\"tag\">LOOP DETECTADO</span><br>\r\n            Ajuste a densidade. A distribuição é adaptativa (foca em curvas) e contínua.\r\n          </div>\r\n\r\n          <button onclick=\"sendApply()\">Concluir (Aplicar)</button>\r\n        </div>\r\n        <script>\r\n          function updateVal(val) {\r\n            document.getElementById('val').innerText = val;\r\n            if (window.sketchup) { sketchup.on_slide(val); } \r\n            else { window.location = 'skp:on_slide@' + val; }\r\n          }\r\n          \r\n          function sendApply() {\r\n            if (window.sketchup) { sketchup.on_apply(); } \r\n            else { window.location = 'skp:on_apply'; }\r\n          }\r\n\r\n          function setLoopStatus(isLoop) {\r\n             if(isLoop) document.getElementById('loop-msg').style.display = 'inline-block';\r\n          }\r\n        </script>\r\n      </body>\r\n      </html>\r\n    }\r\n\r\n    @dialog.set_html(html_content)\r\n    \r\n    @dialog.add_action_callback(\"on_slide\") { |_, val|\r\n      @density_multiplier = val.to_i\r\n      calculate_spline\r\n      @view.invalidate\r\n    }\r\n\r\n    @dialog.add_action_callback(\"on_apply\") { \r\n      commit_geometry\r\n      # Ao selecionar nil aqui, o método deactivate será chamado, fechando a janela\r\n      @model.select_tool(nil)\r\n    }\r\n\r\n    @dialog.add_action_callback(\"exec_js\") { |_, js| @dialog.execute_script(js) }\r\n    \r\n    if @dialog.respond_to?(:center)\r\n      @dialog.center\r\n      @dialog.show\r\n    else\r\n      @dialog.show\r\n    end\r\n\r\n    UI.start_timer(0.5, false) { \r\n      @dialog.execute_script(\"setLoopStatus(#{@is_loop});\") if @dialog.visible?\r\n    }\r\n  end\r\n\r\n  # --- Lógica Matemática ---\r\n\r\n  def get_neighbors(i, points)\r\n    n = points.length\r\n    if @is_loop\r\n      p0 = points[(i - 1) % n]\r\n      p1 = points[i]\r\n      p2 = points[(i + 1) % n]\r\n      p3 = points[(i + 2) % n]\r\n    else\r\n      p0 = i == 0 ? points[0] : points[i-1]\r\n      p1 = points[i]\r\n      p2 = (i+1 >= n) ? points[n-1] : points[i+1]\r\n      p3 = (i+2 >= n) ? points[n-1] : points[i+2]\r\n    end\r\n    return p0, p1, p2, p3\r\n  end\r\n\r\n  def calculate_distribution_metrics\r\n    points = @ordered_vertices\r\n    @segment_weights = []\r\n    total_w = 0.0\r\n    limit = @is_loop ? points.length : points.length - 1\r\n\r\n    (0...limit).each do |i|\r\n      p0, p1, p2, p3 = get_neighbors(i, points)\r\n      len = p1.distance(p2)\r\n      \r\n      v_prev = p1 - p0\r\n      v_curr = p2 - p1\r\n      v_next = p3 - p2\r\n\r\n      angle_start = (v_prev.length > 0 && v_curr.length > 0) ? v_prev.angle_between(v_curr) : 0\r\n      angle_end   = (v_curr.length > 0 && v_next.length > 0) ? v_curr.angle_between(v_next) : 0\r\n      \r\n      avg_curvature = (angle_start + angle_end) / 2.0\r\n      curvature_factor = 1.0 + (avg_curvature * 3.0)\r\n\r\n      weighted_len = len * curvature_factor\r\n      @segment_weights << weighted_len\r\n      total_w += weighted_len\r\n    end\r\n    @total_weighted_length = total_w\r\n  end\r\n\r\n  def calculate_spline\r\n    return if @ordered_vertices.empty?\r\n    points = @ordered_vertices\r\n    @spline_points = []\r\n    \r\n    target_total_segments = [(@original_segment_count * @density_multiplier).round, 1].max\r\n    points_accumulator = 0.0\r\n    limit = @is_loop ? points.length : points.length - 1\r\n\r\n    (0...limit).each do |i|\r\n      p0, p1, p2, p3 = get_neighbors(i, points)\r\n      @spline_points << p1\r\n      \r\n      weighted_len = @segment_weights[i]\r\n      ratio = (@total_weighted_length > 0) ? (weighted_len / @total_weighted_length) : 0\r\n\r\n      exact_steps = ratio * target_total_segments\r\n      points_accumulator += exact_steps\r\n      \r\n      steps_to_draw = points_accumulator.floor\r\n      points_accumulator -= steps_to_draw\r\n\r\n      steps_final = steps_to_draw + 1\r\n\r\n      (1...steps_final).each do |t_step|\r\n        t = t_step.to_f / steps_final\r\n        @spline_points << catmull_rom(p0, p1, p2, p3, t)\r\n      end\r\n    end\r\n    \r\n    if @is_loop\r\n      @spline_points << @spline_points.first\r\n    else\r\n      @spline_points << points.last\r\n    end\r\n  end\r\n\r\n  def catmull_rom(p0, p1, p2, p3, t)\r\n    t2 = t * t\r\n    t3 = t2 * t\r\n    x = 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * t + (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 + (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3)\r\n    y = 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3)\r\n    z = 0.5 * ((2 * p1.z) + (-p0.z + p2.z) * t + (2 * p0.z - 5 * p1.z + 4 * p2.z - p3.z) * t2 + (-p0.z + 3 * p1.z - 3 * p2.z + p3.z) * t3)\r\n    Geom::Point3d.new(x, y, z)\r\n  end\r\n\r\n  def commit_geometry\r\n    edges_to_delete = @selection.grep(Sketchup::Edge)\r\n    return if edges_to_delete.empty?\r\n    \r\n    @model.start_operation(\"Suavizar (Loop)\", true)\r\n    @model.active_entities.erase_entities(edges_to_delete)\r\n    if @spline_points.size > 1\r\n      @model.active_entities.add_curve(@spline_points)\r\n    end\r\n    @model.commit_operation\r\n    @spline_points = []\r\n  end\r\n\r\n  def get_ordered_vertices(selection)\r\n    edges = selection.grep(Sketchup::Edge)\r\n    return [] if edges.empty?\r\n\r\n    vertices = edges.map(&:vertices).flatten\r\n    counts = vertices.each_with_object(Hash.new(0)) { |v, h| h[v] += 1 }\r\n    \r\n    if counts.values.all? { |c| c == 2 }\r\n      @is_loop = true\r\n      start_vertex = edges.first.start \r\n    else\r\n      @is_loop = false\r\n      start_vertex = counts.key(1) \r\n    end\r\n    \r\n    start_vertex ||= edges.first.start \r\n\r\n    sorted_points = [start_vertex.position]\r\n    current_v = start_vertex\r\n    visited_edges = []\r\n    \r\n    while true\r\n      next_edge = current_v.edges.find { |e| edges.include?(e) && !visited_edges.include?(e) }\r\n      break unless next_edge\r\n      visited_edges << next_edge\r\n      other_v = next_edge.other_vertex(current_v)\r\n      if @is_loop && other_v == start_vertex\r\n        break\r\n      end\r\n      sorted_points << other_v.position\r\n      current_v = other_v\r\n    end\r\n\r\n    sorted_points\r\n  end\r\n  \r\n  def update_status\r\n     Sketchup.set_status_text(\"Suavizar: Loop = #{@is_loop ? 'Sim' : 'Não'}\")\r\n  end\r\nend\r\n\r\nSketchup.active_model.select_tool(SmoothPolyTool.new)"
    },
    "enabled": false,
    "execute": true,
    "video": "https://youtu.be/nd8rkwn6BlU?si=a7OmdvWuj5juB07S"
  }
]