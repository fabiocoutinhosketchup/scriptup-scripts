[
  {
    "id": "achatar-c445d",
    "title": {
      "pt": "Achatar",
      "en": "Flatten",
      "es": "Aplanar"
    },
    "author": "Henrique Barsa",
    "version": "1.0",
    "description": {
      "pt": "Nivela todos os elementos no eixo Z = 0",
      "en": "Level all elements on the Z = 0 axis.",
      "es": "Nivele todos los elementos en el eje Z = 0."
    },
    "keywords": {
      "pt": [
        "flatten",
        "achatar",
        "aplanar"
      ],
      "en": [
        "flatten",
        "flatten",
        "flatten"
      ],
      "es": [
        "aplanar",
        "aplanar",
        "aplanar"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module AchatarModelo\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :pergunta_modelo  => \"Nenhum objeto selecionado. Deseja achatar o modelo inteiro?\",\r\n        :msg_sucesso_full => \"Foram achatados %d objetos no modelo inteiro.\",\r\n        :cancelado        => \"Opera√ß√£o cancelada.\",\r\n        :msg_sucesso_sel  => \"Foram achatados %d objetos na sele√ß√£o.\",\r\n        :op_nome          => \"Achatar\"\r\n      },\r\n      'en-US' => {\r\n        :pergunta_modelo  => \"No objects selected. Do you want to flatten the entire model?\",\r\n        :msg_sucesso_full => \"%d objects were flattened in the entire model.\",\r\n        :cancelado        => \"Operation canceled.\",\r\n        :msg_sucesso_sel  => \"%d objects were flattened in the selection.\",\r\n        :op_nome          => \"Flatten\"\r\n      },\r\n      'es' => {\r\n        :pergunta_modelo  => \"¬øNing√∫n objeto seleccionado. Desea aplanar el modelo completo?\",\r\n        :msg_sucesso_full => \"Se aplanaron %d objetos en el modelo completo.\",\r\n        :cancelado        => \"Operaci√≥n cancelada.\",\r\n        :msg_sucesso_sel  => \"Se aplanaron %d objetos en la selecci√≥n.\",\r\n        :op_nome          => \"Aplanar\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    # M√©todo principal que decide se vai achatar a sele√ß√£o ou o modelo inteiro\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n      \r\n      if selection.empty?\r\n        # Pergunta se deseja processar o modelo inteiro\r\n        resposta = UI.messagebox(obter_texto(:pergunta_modelo), MB_YESNO)\r\n        if resposta == IDYES\r\n          stats = flatten_entities(model.entities)\r\n          UI.messagebox(obter_texto(:msg_sucesso_full) % stats)\r\n        else\r\n          UI.messagebox(obter_texto(:cancelado))\r\n          model.abort_operation\r\n          return\r\n        end\r\n      else\r\n        stats = flatten_entities(selection)\r\n        UI.messagebox(obter_texto(:msg_sucesso_sel) % stats)\r\n      end\r\n\r\n      model.commit_operation\r\n    end\r\n\r\n    # M√©todo recursivo para achatar as entidades\r\n    def self.flatten_entities(ents)\r\n      stats = 0\r\n      vertices = []\r\n\r\n      ents.each do |e|\r\n        if e.is_a?(Sketchup::ComponentInstance) || e.is_a?(Sketchup::Group)\r\n          # Processa recursivamente as entidades da defini√ß√£o do componente ou grupo\r\n          stats += flatten_entities(Instance.definition(e).entities)\r\n          # Move a inst√¢ncia para z=0\r\n          p = e.transformation.origin.clone\r\n          p.z = 0\r\n          v = e.transformation.origin.vector_to(p)\r\n          e.transform!(Geom::Transformation.new(v))\r\n        end\r\n\r\n        vertices << e if e.is_a?(Sketchup::ConstructionPoint)\r\n        vertices << e.vertices if e.respond_to?(:vertices)\r\n        e.explode_curve if e.is_a?(Sketchup::Edge)\r\n      end\r\n\r\n      vertices.flatten!\r\n      vertices.uniq!\r\n\r\n      entities = []\r\n      vectors = []\r\n\r\n      # Ajusta todos os v√©rtices para o n√≠vel z=0\r\n      vertices.each do |v|\r\n        point = v.position\r\n        next if point.z == 0\r\n        entities << v\r\n        point.z = 0\r\n        vectors << v.position.vector_to(point)\r\n      end\r\n\r\n      if ents.is_a?(Sketchup::Selection)\r\n        ents.model.active_entities.transform_by_vectors(entities, vectors)\r\n      else\r\n        ents.transform_by_vectors(entities, vectors)\r\n      end\r\n\r\n      return entities.length + stats\r\n    end\r\n\r\n    # M√≥dulo auxiliar para tratar defini√ß√µes de grupos e componentes\r\n    module Instance\r\n      def self.definition(instance)\r\n        if instance.respond_to?(:definition)\r\n          begin\r\n            return instance.definition\r\n          rescue\r\n            # Em caso de erro, prossegue para a busca manual\r\n          end\r\n        end\r\n\r\n        if instance.is_a?(Sketchup::Group)\r\n          if instance.entities.parent.instances.include?(instance)\r\n            return instance.entities.parent\r\n          else\r\n            Sketchup.active_model.definitions.each do |definition|\r\n              return definition if definition.instances.include?(instance)\r\n            end\r\n          end\r\n        elsif instance.is_a?(Sketchup::Image)\r\n          Sketchup.active_model.definitions.each do |definition|\r\n            if definition.image? && definition.instances.include?(instance)\r\n              return definition\r\n            end\r\n          end\r\n        end\r\n\r\n        return nil\r\n      end\r\n\r\n      def self.is?(entity)\r\n        entity.is_a?(Sketchup::Group) || entity.is_a?(Sketchup::ComponentInstance)\r\n      end\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::AchatarModelo.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "ajustar-escala-da-definicao-c45nc",
    "title": {
      "pt": "Ajustar Escala da Defini√ß√£o",
      "en": "Adjust Definition Scale",
      "es": "Ajustar escala de definici√≥n"
    },
    "author": "F√°bio Coutinho",
    "version": "1.2",
    "description": {
      "pt": "Ajusta a escala da defini√ß√£o fazendo com que as texturas aplicadas nos grupos e componentes assumam suas propor√ß√µes corretas para n√£o ficarem distorcidas. Essa vers√£o consegue promover o ajuste em grupos e componentes em qualquer n√≠vel de aninhamento.",
      "en": "Adjusts the scaling of the definition so that the textures applied to groups and components assume their correct proportions and do not become distorted. This version can adjust groups and components at any nesting level.",
      "es": "Ajusta la escala de la definici√≥n para que las texturas aplicadas a grupos y componentes adquieran las proporciones correctas y no se distorsionen. Esta versi√≥n permite ajustar grupos y componentes en cualquier nivel de anidamiento."
    },
    "keywords": {
      "pt": [
        "escala da defini√ß√£o",
        "ajustar texturas"
      ],
      "en": [
        "scale of definition",
        "adjust textures"
      ],
      "es": [
        "escala de definici√≥n",
        "ajustar texturas"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module NormalizarEscala\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :selecao_vazia    => \"Nenhum elemento selecionado.\",\r\n        :ja_processado    => \"Defini√ß√£o j√° processada, ignorando: \",\r\n        :escala_ajustada  => \"A escala foi normalizada para 1 no elemento: \",\r\n        :escala_correta   => \"O elemento j√° est√° com escala normalizada: \",\r\n        :elemento_ignorado => \"Elemento ignorado, n√£o √© um componente ou grupo v√°lido: \",\r\n        :op_nome          => \"Normalizar Escala\",\r\n        :concluido        => \"Processo conclu√≠do.\"\r\n      },\r\n      'en-US' => {\r\n        :selecao_vazia    => \"No elements selected.\",\r\n        :ja_processado    => \"Definition already processed, skipping: \",\r\n        :escala_ajustada  => \"Scale was normalized to 1 for element: \",\r\n        :escala_correta   => \"Element already has normalized scale: \",\r\n        :elemento_ignorado => \"Element ignored, not a valid component or group: \",\r\n        :op_nome          => \"Normalize Scale\",\r\n        :concluido        => \"Process completed.\"\r\n      },\r\n      'es' => {\r\n        :selecao_vazia    => \"Ning√∫n elemento seleccionado.\",\r\n        :ja_processado    => \"Definici√≥n ya procesada, ignorando: \",\r\n        :escala_ajustada  => \"La escala fue normalizada a 1 en el elemento: \",\r\n        :escala_correta   => \"El elemento ya tiene la escala normalizada: \",\r\n        :elemento_ignorado => \"Elemento ignorado, no es un componente o grupo v√°lido: \",\r\n        :op_nome          => \"Normalizar Escala\",\r\n        :concluido        => \"Proceso completado.\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      if selection.empty?\r\n        puts obter_texto(:selecao_vazia)\r\n      else\r\n        processed_definitions = []\r\n\r\n        model.start_operation(obter_texto(:op_nome), true)\r\n\r\n        selection.each do |entity|\r\n          normalize_scale_recursively(entity, processed_definitions)\r\n        end\r\n\r\n        model.commit_operation\r\n        puts obter_texto(:concluido)\r\n      end\r\n    end\r\n\r\n    def self.normalize_scale_recursively(entity, processed_definitions)\r\n      if entity.is_a?(Sketchup::ComponentInstance) || entity.is_a?(Sketchup::Group)\r\n        entity.make_unique if entity.is_a?(Sketchup::ComponentInstance)\r\n\r\n        definition = entity.is_a?(Sketchup::ComponentInstance) ? entity.definition : nil\r\n        entities = definition ? definition.entities : entity.entities\r\n\r\n        if definition && processed_definitions.include?(definition)\r\n          puts \"#{obter_texto(:ja_processado)}#{entity}\"\r\n          return\r\n        end\r\n\r\n        processed_definitions << definition if definition\r\n\r\n        transform = entity.transformation\r\n        scale_x = transform.xscale\r\n        scale_y = transform.yscale\r\n        scale_z = transform.zscale\r\n\r\n        if scale_x != 1 || scale_y != 1 || scale_z != 1\r\n          scaling_transform = Geom::Transformation.scaling(scale_x, scale_y, scale_z)\r\n          entities.transform_entities(scaling_transform, entities.to_a)\r\n\r\n          origin = transform.origin\r\n          xaxis = transform.xaxis\r\n          yaxis = transform.yaxis\r\n          zaxis = transform.zaxis\r\n\r\n          normalized_transform = Geom::Transformation.axes(origin, xaxis, yaxis, zaxis)\r\n          entity.transformation = normalized_transform\r\n\r\n          puts \"#{obter_texto(:escala_ajustada)}#{entity}\"\r\n\r\n          temp_group = entities.add_group\r\n          temp_face = temp_group.entities.add_face([0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0])\r\n          temp_group.erase! if temp_face\r\n        else\r\n          puts \"#{obter_texto(:escala_correta)}#{entity}\"\r\n        end\r\n\r\n        entities.grep(Sketchup::ComponentInstance).each do |child_entity|\r\n          normalize_scale_recursively(child_entity, processed_definitions)\r\n        end\r\n        entities.grep(Sketchup::Group).each do |child_group|\r\n          normalize_scale_recursively(child_group, processed_definitions)\r\n        end\r\n      else\r\n        puts \"#{obter_texto(:elemento_ignorado)}#{entity}\"\r\n      end\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::NormalizarEscala.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "cortar-com-secao-c471p",
    "title": {
      "pt": "Cortar com Se√ß√£o",
      "en": "Cut with Section",
      "es": "Corte con secci√≥n"
    },
    "author": "Henrique Barsa",
    "version": "1.0",
    "description": {
      "pt": "Use o Plano de Se√ß√£o para cortar o que voc√™ quiser.",
      "en": "Use the Section Plan to cut out whatever you want.",
      "es": "Utilice el plano de secci√≥n para cortar lo que desee."
    },
    "keywords": {
      "pt": [
        "cortar",
        "se√ß√£o"
      ],
      "en": [
        "cut",
        "section"
      ],
      "es": [
        "cortar",
        "secci√≥n"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module CortarPlanoSecao\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :status_cortando   => \"Cortando %s...\",\r\n        :status_excluindo  => \"Excluindo entidades atr√°s do plano para %s...\",\r\n        :status_preparando => \"Tornando componentes √∫nicos, excluindo grupos e componentes atr√°s do plano de se√ß√£o...\",\r\n        :op_nome           => \"Corte via SectionPlane\",\r\n        :sucesso           => \"Corte via SectionPlane conclu√≠do.\",\r\n        :erro_selecao      => \"Selecione uma SectionPlane para cortar o modelo.\"\r\n      },\r\n      'en-US' => {\r\n        :status_cortando   => \"Slicing %s...\",\r\n        :status_excluindo  => \"Deleting entities behind plane for %s...\",\r\n        :status_preparando => \"Making components unique, deleting groups and components behind section plane...\",\r\n        :op_nome           => \"Slice at Section Plane\",\r\n        :sucesso           => \"Slice at Section Plane completed.\",\r\n        :erro_selecao      => \"Select a SectionPlane to slice the model.\"\r\n      },\r\n      'es' => {\r\n        :status_cortando   => \"Cortando %s...\",\r\n        :status_excluindo  => \"Eliminando entidades detr√°s del plano para %s...\",\r\n        :status_preparando => \"Haciendo componentes √∫nicos, eliminando grupos y componentes detr√°s del plano de secci√≥n...\",\r\n        :op_nome           => \"Corte por Plano de Secci√≥n\",\r\n        :sucesso           => \"Corte por Plano de Secci√≥n completado.\",\r\n        :erro_selecao      => \"Seleccione un SectionPlane para cortar el modelo.\"\r\n      }\r\n    }\r\n\r\n    $helper_group = nil\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.get_entities(object)\r\n      if object.is_a?(Sketchup::Model)\r\n        object.entities\r\n      elsif object.is_a?(Sketchup::Group)\r\n        object.entities\r\n      elsif object.is_a?(Sketchup::ComponentInstance)\r\n        object.definition.entities\r\n      elsif object.is_a?(Sketchup::ComponentDefinition)\r\n        object.entities\r\n      else\r\n        nil\r\n      end\r\n    end\r\n\r\n    def self.bounds_intersects_plane?(inst1, t1, plane)\r\n      bounds = inst1.bounds\r\n      bmin = bounds.min\r\n      bmax = bounds.max\r\n      pts = [\r\n        Geom::Point3d.new(bmin.x, bmin.y, bmin.z),\r\n        Geom::Point3d.new(bmax.x, bmin.y, bmin.z),\r\n        Geom::Point3d.new(bmin.x, bmin.y, bmax.z),\r\n        Geom::Point3d.new(bmax.x, bmin.y, bmax.z),\r\n        Geom::Point3d.new(bmin.x, bmax.y, bmax.z),\r\n        Geom::Point3d.new(bmax.x, bmax.y, bmax.z),\r\n        Geom::Point3d.new(bmin.x, bmax.y, bmin.z),\r\n        Geom::Point3d.new(bmax.x, bmax.y, bmin.z)\r\n      ]\r\n      pts = pts.map { |p| p.transform(t1) }\r\n\r\n      behind = pts.find { |p| (plane[0]*p.x + plane[1]*p.y + plane[2]*p.z + plane[3]) < -0.001 }\r\n      in_front = pts.find { |p| (plane[0]*p.x + plane[1]*p.y + plane[2]*p.z + plane[3]) > 0.001 }\r\n\r\n      if behind && in_front\r\n        0\r\n      elsif behind && !in_front\r\n        -1\r\n      elsif !behind && in_front\r\n        1\r\n      end\r\n    end\r\n\r\n    def self.make_unique_section_cut(ents, t1, plane)\r\n      delete = []\r\n      ents.each do |e|\r\n        next unless e.valid? && e.visible?\r\n        if e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance)\r\n          res = bounds_intersects_plane?(e, t1, plane)\r\n          if res == 0\r\n            e.make_unique\r\n            make_unique_section_cut(get_entities(e), t1 * e.transformation, plane)\r\n          elsif res == -1\r\n            delete << e\r\n          end\r\n        end\r\n      end\r\n      ents.erase_entities(delete) unless delete.empty?\r\n    end\r\n\r\n    def self.create_face_from_section(section)\r\n      plane = section.get_plane\r\n      bounds = Sketchup.active_model.bounds\r\n      entities = Sketchup.active_model.active_entities\r\n      bmin = bounds.min\r\n      bmax = bounds.max\r\n\r\n      newgroup = entities.add_group\r\n      newgroupentities = newgroup.entities\r\n\r\n      c1 = [bmin.x, bmin.y, bmin.z]\r\n      c2 = [bmax.x, bmin.y, bmin.z]\r\n      c3 = [bmin.x, bmin.y, bmax.z]\r\n      c4 = [bmax.x, bmin.y, bmax.z]\r\n      c5 = [bmin.x, bmax.y, bmax.z]\r\n      c6 = [bmax.x, bmax.y, bmax.z]\r\n      c7 = [bmin.x, bmax.y, bmin.z]\r\n      c8 = [bmax.x, bmax.y, bmin.z]\r\n\r\n      e1 = newgroupentities.add_edges(c1, c2)\r\n      e2 = newgroupentities.add_edges(c3, c4)\r\n      e3 = newgroupentities.add_edges(c5, c6)\r\n      e4 = newgroupentities.add_edges(c7, c8)\r\n      e5 = newgroupentities.add_edges(c1, c3)\r\n      e6 = newgroupentities.add_edges(c2, c4)\r\n      e7 = newgroupentities.add_edges(c7, c5)\r\n      e8 = newgroupentities.add_edges(c8, c6)\r\n      e9 = newgroupentities.add_edges(c1, c7)\r\n      e10 = newgroupentities.add_edges(c3, c5)\r\n      e11 = newgroupentities.add_edges(c4, c6)\r\n      e12 = newgroupentities.add_edges(c2, c8)\r\n\r\n      lines = [e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12].map{|arr| arr[0]}\r\n      line_objs = lines.map(&:line)\r\n      lines.each(&:erase!)\r\n\r\n      pts_intersect = line_objs.map { |l| Geom.intersect_line_plane(l, plane) }.compact\r\n      \r\n      # L√≥gica simplificada para gerar a face de corte baseada nos pontos de interse√ß√£o do bounding box\r\n      if pts_intersect.length >= 3\r\n        newgroupentities.add_face(pts_intersect) rescue nil\r\n      end\r\n\r\n      return newgroup\r\n    end\r\n\r\n    def self.nested_slash(first, t1, second, t2)\r\n      ents = get_entities(first)\r\n      ents.each do |e|\r\n        if e.valid? && e.visible? && (e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance))\r\n          Sketchup.set_status_text(obter_texto(:status_cortando) % get_entities(e).parent.name)\r\n          nested_slash(e, t1 * e.transformation, second, t2)\r\n        end\r\n      end\r\n      slash(first, t1, second, t2)\r\n    end\r\n\r\n    def self.slash(inst1, t1, inst2, t2)\r\n      if intersects_plane?(inst1, t1, inst2, t2)\r\n        ents1 = get_entities(inst1)\r\n        ents1.intersect_with(false, t1, ents1, t1, false, [inst2])\r\n      end\r\n    end\r\n\r\n    def self.intersects_plane?(inst1, t1, plane_group, t2)\r\n      if $helper_group.nil? || !$helper_group.valid?\r\n        $helper_group = Sketchup.active_model.active_entities.add_group\r\n        $helper_group.entities.add_cpoint([0,0,0])\r\n      end\r\n      ents1 = get_entities(inst1)\r\n      ents2 = $helper_group.entities\r\n      new_edges = ents1.intersect_with(false, t1, ents2, $helper_group.transformation, false, [plane_group])\r\n      new_edges.length > 0\r\n    end\r\n\r\n    def self.delete_model_behind_plane(first, t1, plane)\r\n      ents = get_entities(first)\r\n      ents.each do |e|\r\n        if e.valid? && e.visible? && (e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance))\r\n          Sketchup.set_status_text(obter_texto(:status_excluindo) % get_entities(e).parent.name)\r\n          delete_model_behind_plane(e, t1 * e.transformation, plane)\r\n        end\r\n      end\r\n      delete_ents_behind_plane(first, t1, plane)\r\n    end\r\n\r\n    def self.delete_ents_behind_plane(first, t1, plane)\r\n      ents = get_entities(first)\r\n      deletar = []\r\n      ents.each do |e|\r\n        next unless e.valid?\r\n        if e.is_a?(Sketchup::Face)\r\n          cent = e.bounds.center.transform(t1)\r\n          result = plane[0]*cent.x + plane[1]*cent.y + plane[2]*cent.z + plane[3]\r\n          deletar << e if result < -0.001\r\n        elsif e.is_a?(Sketchup::Edge)\r\n          p1 = e.start.position.transform(t1)\r\n          p2 = e.end.position.transform(t1)\r\n          cent = Geom::Point3d.new((p1.x+p2.x)/2.0, (p1.y+p2.y)/2.0, (p1.z+p2.z)/2.0)\r\n          result = plane[0]*cent.x + plane[1]*cent.y + plane[2]*cent.z + plane[3]\r\n          deletar << e if result < -0.001 && cent.distance_to_plane(plane) > 0.001\r\n        end\r\n      end\r\n      ents.erase_entities(deletar) unless deletar.empty?\r\n    end\r\n\r\n    def self.delete_helpers\r\n      if $helper_group && $helper_group.valid?\r\n        Sketchup.active_model.active_entities.erase_entities($helper_group)\r\n      end\r\n      $helper_group = nil\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      section = model.selection.first\r\n      \r\n      unless section.is_a?(Sketchup::SectionPlane)\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n\r\n      plane = section.get_plane\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n\r\n      ents = model.active_entities\r\n      Sketchup.set_status_text(obter_texto(:status_preparando))\r\n\r\n      make_unique_section_cut(ents, Geom::Transformation.new, plane)\r\n      knife_group = create_face_from_section(section)\r\n      \r\n      nested_slash(ents.parent, Geom::Transformation.new, knife_group, knife_group.transformation)\r\n      \r\n      ents.erase_entities(knife_group) if knife_group.valid?\r\n      delete_model_behind_plane(ents.parent, Geom::Transformation.new, plane)\r\n      delete_helpers()\r\n\r\n      model.commit_operation\r\n      UI.messagebox(obter_texto(:sucesso))\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::CortarPlanoSecao.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "cria-cena-com-elementos-isolados-c48ua",
    "title": {
      "pt": "Cria Cena com Elementos Isolados",
      "en": "Create a Scene with Isolated Elements",
      "es": "Crear una escena con elementos aislados"
    },
    "author": "Jos√© Ricardo",
    "version": "1.0",
    "description": {
      "pt": "Isola os elementos selecionados ocultando os demais e criando uma cena com os elementos em sele√ß√£o de zoom.",
      "en": "Isolate the selected elements, hiding the others and creating a scene with the zoomed-in selection of the elements.",
      "es": "A√≠sla los elementos seleccionados, ocultando los dem√°s y creando una escena con la selecci√≥n ampliada de los elementos."
    },
    "keywords": {
      "pt": [
        "isola elemento",
        "cena com sele√ß√£o"
      ],
      "en": [
        "isolates element",
        "scene with selection"
      ],
      "es": [
        "elemento aislado",
        "escena con selecci√≥n"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module CriarCenaFiltrada\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao    => \"Nenhuma entidade selecionada. Por favor, selecione objetos para manter vis√≠veis.\",\r\n        :label_cena      => \"Nome da Cena:\",\r\n        :default_cena    => \"Cena Filtrada\",\r\n        :titulo_input    => \"Criar Nova Cena\",\r\n        :cancelado       => \"Opera√ß√£o cancelada pelo usu√°rio.\",\r\n        :op_nome         => \"Ocultar N√£o Selecionados e Criar Cena\",\r\n        :sucesso         => \"Cena '%s' criada com sucesso, com zoom na sele√ß√£o e entidades ocultas.\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao    => \"No entities selected. Please select objects to keep visible.\",\r\n        :label_cena      => \"Scene Name:\",\r\n        :default_cena    => \"Filtered Scene\",\r\n        :titulo_input    => \"Create New Scene\",\r\n        :cancelado       => \"Operation canceled by user.\",\r\n        :op_nome         => \"Hide Unselected and Create Scene\",\r\n        :sucesso         => \"Scene '%s' successfully created with zoom on selection and hidden entities.\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao    => \"Ninguna entidad seleccionada. Por favor, seleccione objetos para mantener visibles.\",\r\n        :label_cena      => \"Nombre de la Escena:\",\r\n        :default_cena    => \"Escena Filtrada\",\r\n        :titulo_input    => \"Crear Nueva Escena\",\r\n        :cancelado       => \"Operaci√≥n cancelada por el usuario.\",\r\n        :op_nome         => \"Ocultar no seleccionados y Crear Escena\",\r\n        :sucesso         => \"Escena '%s' creada con √©xito, con zoom en la selecci√≥n y entidades ocultas.\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      entities = model.active_entities\r\n      selection = model.selection\r\n\r\n      if selection.empty?\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n      else\r\n        # Solicita o nome da nova cena\r\n        prompts = [obter_texto(:label_cena)]\r\n        defaults = [obter_texto(:default_cena)]\r\n        input = UI.inputbox(prompts, defaults, obter_texto(:titulo_input))\r\n        \r\n        unless input\r\n          puts obter_texto(:cancelado)\r\n          return\r\n        end\r\n\r\n        scene_name = input[0]\r\n\r\n        # Inicia opera√ß√£o\r\n        model.start_operation(obter_texto(:op_nome), true)\r\n\r\n        # Oculta entidades n√£o selecionadas (e ocult√°veis)\r\n        entities.each do |ent|\r\n          next if selection.include?(ent)\r\n          ent.hidden = true if ent.respond_to?(:hidden=)\r\n        end\r\n\r\n        # Faz zoom na sele√ß√£o\r\n        Sketchup.send_action(\"viewZoomToSelection:\")\r\n\r\n        # Aguarda um pequeno tempo para garantir o zoom e cria a cena\r\n        UI.start_timer(0.2, false) {\r\n          page = model.pages.add(scene_name)\r\n          page.use_camera = true\r\n\r\n          model.commit_operation\r\n          UI.messagebox(obter_texto(:sucesso) % scene_name)\r\n        }\r\n      end\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::CriarCenaFiltrada.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "cria-cenas-do-modelo-isolado-em-projecao-c4ad3",
    "title": {
      "pt": "Cria Cenas do Modelo Isolado em Proje√ß√£o Paralela",
      "en": "Creates Scenes of the Isolated Model in Parallel Projection",
      "es": "Crea escenas del modelo aislado en proyecci√≥n paralela"
    },
    "author": "Andr√© Silva",
    "version": "1.3",
    "description": {
      "pt": "Cria todas as exibi√ß√µes padr√µes, em proje√ß√£o paralela, do(s) elemento(s) selecionado(s) de forma isolada, ou seja, ocultando o restante do modelo. As cenas s√£o criadas usando no nome o prefixo que voc√™ informar.",
      "en": "Creates all standard views, in parallel projection, of the selected element(s) in isolation, that is, hiding the rest of the model. Scenes are created using the prefix you specify in the name.",
      "es": "Crea todas las vistas est√°ndar, en proyecci√≥n paralela, de los elementos seleccionados de forma aislada, es decir, ocultando el resto del modelo. Las escenas se crean con el prefijo especificado en el nombre."
    },
    "keywords": {
      "pt": [
        "cenas",
        "proje√ß√£o paralela"
      ],
      "en": [
        "scenes",
        "parallel projection"
      ],
      "es": [
        "escenas",
        "proyecci√≥n paralela"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module CriarVistasPadrao\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :label_prefixo => \"Prefixo das cenas:\",\r\n        :titulo_input  => \"Prefixo para os nomes das cenas\",\r\n        :op_nome       => \"Isolar Sele√ß√£o para Cenas\",\r\n        :superior      => \"Superior\",\r\n        :inferior      => \"Inferior\",\r\n        :direita       => \"Direita\",\r\n        :esquerda      => \"Esquerda\",\r\n        :posterior     => \"Posterior\",\r\n        :frontal       => \"Frontal\",\r\n        :iso           => \"ISO\"\r\n      },\r\n      'en-US' => {\r\n        :label_prefixo => \"Scene prefix:\",\r\n        :titulo_input  => \"Prefix for scene names\",\r\n        :op_nome       => \"Isolate Selection for Scenes\",\r\n        :superior      => \"Top\",\r\n        :inferior      => \"Bottom\",\r\n        :direita       => \"Right\",\r\n        :esquerda      => \"Left\",\r\n        :posterior     => \"Back\",\r\n        :frontal       => \"Front\",\r\n        :iso           => \"ISO\"\r\n      },\r\n      'es' => {\r\n        :label_prefixo => \"Prefijo de las escenas:\",\r\n        :titulo_input  => \"Prefijo para los nombres de las escenas\",\r\n        :op_nome       => \"Aislar Selecci√≥n para Escenas\",\r\n        :superior      => \"Superior\",\r\n        :inferior      => \"Inferior\",\r\n        :direita       => \"Derecha\",\r\n        :esquerda      => \"Izquierda\",\r\n        :posterior     => \"Posterior\",\r\n        :frontal       => \"Frontal\",\r\n        :iso           => \"ISO\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      entities = model.active_entities\r\n      views = model.pages\r\n      view = model.active_view\r\n      selection = model.selection\r\n\r\n      # Pergunta o prefixo\r\n      res = UI.inputbox([obter_texto(:label_prefixo)], [\"\"], obter_texto(:titulo_input))\r\n\r\n      if res # S√≥ continua se n√£o cancelou\r\n        prefixo = res[0].strip\r\n        prefixo += \" - \" unless prefixo.empty?\r\n\r\n        # Oculta tudo menos a sele√ß√£o\r\n        model.start_operation(obter_texto(:op_nome), true)\r\n        entities.each do |e|\r\n          next if selection.include?(e)\r\n          e.visible = false if e.respond_to?(:visible=)\r\n        end\r\n\r\n        # Obter centro do modelo\r\n        bounding_box = model.bounds\r\n        centro = bounding_box.center\r\n\r\n        # Dicion√°rio de vistas corrigido\r\n        vistas = {\r\n          obter_texto(:superior)  => { dir: Geom::Vector3d.new(0, 0, -1),  up: Geom::Vector3d.new(0, -1, 0) },\r\n          obter_texto(:inferior)  => { dir: Geom::Vector3d.new(0, 0, 1),   up: Geom::Vector3d.new(0, 1, 0) },\r\n          obter_texto(:direita)   => { dir: Geom::Vector3d.new(-1, 0, 0),  up: Geom::Vector3d.new(0, 0, 1) },\r\n          obter_texto(:esquerda)  => { dir: Geom::Vector3d.new(1, 0, 0),   up: Geom::Vector3d.new(0, 0, 1) },\r\n          obter_texto(:posterior) => { dir: Geom::Vector3d.new(0, -1, 0),  up: Geom::Vector3d.new(0, 0, 1) },\r\n          obter_texto(:frontal)   => { dir: Geom::Vector3d.new(0, 1, 0),   up: Geom::Vector3d.new(0, 0, 1) },\r\n          obter_texto(:iso)       => { dir: Geom::Vector3d.new(1, 1, -1),  up: Geom::Vector3d.new(0, 0, 1) }\r\n        }\r\n\r\n        # Criar cada cena\r\n        vistas.each do |nome, dados|\r\n          dir = dados[:dir].clone.normalize!\r\n          up  = dados[:up]\r\n\r\n          from_point = centro.offset(dir.reverse!.transform(300))\r\n          to_point = centro\r\n\r\n          camera = Sketchup::Camera.new(from_point, to_point, up)\r\n          camera.perspective = false  # Proje√ß√£o paralela\r\n\r\n          view.camera = camera\r\n          view.zoom_extents\r\n\r\n          # Criar cena com prefixo\r\n          page = views.add(\"#{prefixo}#{nome}\")\r\n          page.use_camera = true\r\n        end\r\n\r\n        model.commit_operation\r\n      end\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::CriarVistasPadrao.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "criar-faces-c4bvl",
    "title": {
      "pt": "Criar Faces",
      "en": "Create Faces",
      "es": "Crear caras"
    },
    "author": "Henrique Barsa",
    "version": "1.0",
    "description": {
      "pt": "Faz o preenchimento de superf√≠cies.",
      "en": "It fills surfaces.",
      "es": "Rellena superficies."
    },
    "keywords": {
      "pt": [
        "faces",
        "buracos"
      ],
      "en": [
        "faces",
        "holes"
      ],
      "es": [
        "caras",
        "agujeros"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module BarsaFace\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :aviso_selecao => \"Nenhuma sele√ß√£o encontrada. Deseja processar todo o modelo? Essa opera√ß√£o pode demorar.\",\r\n        :op_nome       => \"Criar Faces\"\r\n      },\r\n      'en-US' => {\r\n        :aviso_selecao => \"No selection found. Do you want to process the entire model? This operation may take some time.\",\r\n        :op_nome       => \"Create Faces\"\r\n      },\r\n      'es' => {\r\n        :aviso_selecao => \"No se encontr√≥ ninguna selecci√≥n. ¬øDesea procesar todo el modelo? Esta operaci√≥n puede tardar.\",\r\n        :op_nome       => \"Crear Caras\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n\r\n      if model.selection.empty?\r\n        response = UI.messagebox(obter_texto(:aviso_selecao), MB_YESNO)\r\n        return if response != IDYES\r\n        entities = model.active_entities\r\n      else\r\n        entities = model.selection\r\n      end\r\n\r\n      entities_array = entities.to_a\r\n\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n      create_faces_recursive(entities_array)\r\n      model.commit_operation\r\n    end\r\n\r\n    def self.create_faces_recursive(entities)\r\n      entities.each do |entity|\r\n        case entity\r\n        when Sketchup::Edge\r\n          faces_before = entity.faces.to_a\r\n          entity.find_faces\r\n          new_faces = entity.faces.to_a - faces_before\r\n          new_faces.each do |face|\r\n            correct_face_orientation(face)\r\n          end\r\n        when Sketchup::Group\r\n          create_faces_recursive(entity.entities)\r\n        when Sketchup::ComponentInstance\r\n          create_faces_recursive(entity.definition.entities)\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.correct_face_orientation(face)\r\n      # Define um vetor \"cima\", pode ser Z global\r\n      up = Z_AXIS\r\n      # Se a face estiver voltada para baixo (comparado ao eixo Z)\r\n      if face.normal.angle_between(up) > 90.degrees\r\n        face.reverse!\r\n      end\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::BarsaFace.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "desbloquear-tudo-c4dts",
    "title": {
      "pt": "Desbloquear Tudo",
      "en": "Unlock Everything",
      "es": "Desbloquea todo"
    },
    "author": "F√°bio Coutinho",
    "version": "1.0",
    "description": {
      "pt": "Script para desbloquear tudo, na sele√ß√£o ou no modelo. Aninhados ou n√£o.",
      "en": "Script to unlock everything, in the selection or in the model. Nested or not.",
      "es": "Script para desbloquear todo, en la selecci√≥n o en el modelo. Anidado o no."
    },
    "keywords": {
      "pt": [
        "desbloquear",
        "unlock"
      ],
      "en": [
        "unlock",
        "unlock"
      ],
      "es": [
        "descubrir",
        "descubrir"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module DesbloquearElementos\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :pergunta_modo => \"Deseja desbloquear apenas os elementos selecionados? (Sim para Sele√ß√£o, N√£o para Todo o Modelo)\",\r\n        :op_nome       => \"Desbloquear Elementos\",\r\n        :sucesso       => \"Todos os grupos e componentes foram desbloqueados!\"\r\n      },\r\n      'en-US' => {\r\n        :pergunta_modo => \"Do you want to unlock only the selected elements? (Yes for Selection, No for Entire Model)\",\r\n        :op_nome       => \"Unlock Elements\",\r\n        :sucesso       => \"All groups and components have been unlocked!\"\r\n      },\r\n      'es' => {\r\n        :pergunta_modo => \"¬øDesea desbloquear solo los elementos seleccionados? (S√≠ para Selecci√≥n, No para todo el Modelo)\",\r\n        :op_nome       => \"Desbloquear Elementos\",\r\n        :sucesso       => \"¬°Todos los grupos y componentes han sido desbloqueados!\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.ask_user(question)\r\n      result = UI.messagebox(question, MB_YESNO)\r\n      result == IDYES\r\n    end\r\n\r\n    def self.unlock_entities(entities)\r\n      # Primeiro, desbloqueia os grupos e componentes no n√≠vel atual\r\n      entities.each do |entity|\r\n        if entity.is_a?(Sketchup::Group) || entity.is_a?(Sketchup::ComponentInstance)\r\n          if entity.locked?\r\n            entity.locked = false\r\n          end\r\n        end\r\n      end\r\n\r\n      # Depois, entra nos grupos/componentes desbloqueados para desbloquear os aninhados\r\n      entities.each do |entity|\r\n        if entity.is_a?(Sketchup::Group) || entity.is_a?(Sketchup::ComponentInstance)\r\n          unlock_entities(entity.definition.entities) # Recurs√£o para desbloquear subgrupos/subcomponentes\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      # Perguntar se deseja agir na sele√ß√£o ou no modelo inteiro\r\n      use_selection = ask_user(obter_texto(:pergunta_modo))\r\n\r\n      entities = use_selection && !selection.empty? ? selection : model.active_entities\r\n\r\n      # Processar os elementos\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n\r\n      # Desbloquear todos os grupos e componentes recursivamente\r\n      unlock_entities(entities)\r\n\r\n      model.commit_operation\r\n\r\n      UI.messagebox(obter_texto(:sucesso))\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::DesbloquearElementos.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "descer-objetos-c4g8r",
    "title": {
      "pt": "Descer Objetos",
      "en": "Lower Objects",
      "es": "Objetos inferiores"
    },
    "author": "Henrique Barsa",
    "version": "1.0",
    "description": {
      "pt": "Desce o objeto at√© o abaixo dele.",
      "en": "Lower the object to the one below it.",
      "es": "Baja el objeto hasta el que est√° debajo de √©l."
    },
    "keywords": {
      "pt": [
        "drop",
        "descer"
      ],
      "en": [
        "drop",
        "to descend"
      ],
      "es": [
        "gota",
        "descender"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module ProjetarNoChao\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao => \"Nenhum objeto selecionado. Selecione ao menos um grupo ou componente.\",\r\n        :erro_raytest => \"Nenhuma geometria foi encontrada abaixo de %s para a interse√ß√£o.\",\r\n        :op_nome      => \"Projetar no Solo\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao => \"No objects selected. Please select at least one group or component.\",\r\n        :erro_raytest => \"No geometry was found below %s for intersection.\",\r\n        :op_nome      => \"Drop to Ground\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao => \"Ning√∫n objeto seleccionado. Seleccione al menos un grupo o componente.\",\r\n        :erro_raytest => \"No se encontr√≥ geometr√≠a debajo de %s para la intersecci√≥n.\",\r\n        :op_nome      => \"Proyectar al Suelo\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      ss = model.selection\r\n      \r\n      # Verifica se h√° algo selecionado\r\n      if ss.empty?\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n\r\n      dir = [0, 0, -1] # vetor para baixo (Z negativo)\r\n\r\n      ss.each do |entity|\r\n        next unless entity.respond_to?(:transformation)\r\n        \r\n        position = entity.transformation.origin\r\n        # Retorna [Geom::Point3d, entidade_intersectada]\r\n        rt = model.raytest(position, dir)\r\n\r\n        if rt.nil?\r\n          UI.messagebox(obter_texto(:erro_raytest) % entity.to_s)\r\n        else\r\n          intersect_pt = rt[0]\r\n          new_z = intersect_pt.z\r\n          \r\n          # Aplica a transforma√ß√£o mantendo X e Y, alterando apenas Z\r\n          tr = entity.transformation.to_a\r\n          tr[14] = new_z\r\n          entity.transformation = tr\r\n        end\r\n      end\r\n\r\n      model.commit_operation\r\n      \r\n      # For√ßa uma atualiza√ß√£o visual\r\n      model.active_view.invalidate\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::ProjetarNoChao.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "escala-por-eixo-mantendo-proporcao-c4hre",
    "title": {
      "pt": "Escala por Eixo Mantendo Propor√ß√£o",
      "en": "Scaling by Axis Maintaining Proportion",
      "es": "Escalado por eje manteniendo la proporci√≥n"
    },
    "author": "Ludimila Siqueira",
    "version": "1.0",
    "description": {
      "pt": "Altera a escala por eixo com possibilidade de manter a propor√ß√£o nos demais eixos.",
      "en": "It changes the scale on each axis while maintaining the aspect ratio on the other axes.",
      "es": "Cambia la escala en cada eje mientras mantiene la relaci√≥n de aspecto en los otros ejes."
    },
    "keywords": {
      "pt": [
        "escala por eixo",
        "propor√ß√£o"
      ],
      "en": [
        "scale by axis",
        "proportion"
      ],
      "es": [
        "escala por eje",
        "proporci√≥n"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module EscalarPorEixo\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :titulo_janela    => \"Escalar Componente por Eixo\",\r\n        :label_eixo       => \"Eixo de refer√™ncia:\",\r\n        :label_comprimento => \"Comprimento desejado:\",\r\n        :label_proporcao  => \"Manter propor√ß√£o\",\r\n        :btn_aplicar      => \"Aplicar Escala\",\r\n        :erro_selecao     => \"Selecione um √∫nico componente ou grupo.\",\r\n        :erro_eixo        => \"Eixo inv√°lido. Use X, Y ou Z.\",\r\n        :erro_dimensao    => \"A dimens√£o atual no eixo %s √© zero.\",\r\n        :op_nome          => \"Escalar por eixo\"\r\n      },\r\n      'en-US' => {\r\n        :titulo_janela    => \"Scale Component by Axis\",\r\n        :label_eixo       => \"Reference axis:\",\r\n        :label_comprimento => \"Desired length:\",\r\n        :label_proporcao  => \"Maintain proportion\",\r\n        :btn_aplicar      => \"Apply Scale\",\r\n        :erro_selecao     => \"Select a single component or group.\",\r\n        :erro_eixo        => \"Invalid axis. Use X, Y or Z.\",\r\n        :erro_dimensao    => \"The current dimension on axis %s is zero.\",\r\n        :op_nome          => \"Scale by axis\"\r\n      },\r\n      'es' => {\r\n        :titulo_janela    => \"Escalar Componente por Eje\",\r\n        :label_eixo       => \"Eje de referencia:\",\r\n        :label_comprimento => \"Longitud deseada:\",\r\n        :label_proporcao  => \"Mantener proporci√≥n\",\r\n        :btn_aplicar      => \"Aplicar Escala\",\r\n        :erro_selecao     => \"Seleccione un solo componente o grupo.\",\r\n        :erro_eixo        => \"Eje inv√°lido. Use X, Y o Z.\",\r\n        :erro_dimensao    => \"La dimensi√≥n actual en el eje %s es cero.\",\r\n        :op_nome          => \"Escalar por eje\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.show_ui\r\n      dlg = UI::HtmlDialog.new({\r\n        dialog_title: obter_texto(:titulo_janela),\r\n        preferences_key: \"scale_by_axis\",\r\n        scrollable: true,\r\n        resizable: false,\r\n        width: 320,\r\n        height: 260,\r\n        style: UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n\r\n      html = <<-HTML\r\n        <!DOCTYPE html>\r\n        <html>\r\n        <body style=\"font-family: sans-serif; margin: 10px;\">\r\n          <label for=\"axis\">#{obter_texto(:label_eixo)}</label><br>\r\n          <select id=\"axis\">\r\n            <option value=\"X\">X</option>\r\n            <option value=\"Y\">Y</option>\r\n            <option value=\"Z\">Z</option>\r\n          </select><br><br>\r\n\r\n          <label for=\"length\">#{obter_texto(:label_comprimento)}</label><br>\r\n          <input type=\"number\" id=\"length\" value=\"100\" />\r\n          <select id=\"unit\">\r\n            <option value=\"cm\" selected>cm</option>\r\n            <option value=\"m\">m</option>\r\n            <option value=\"mm\">mm</option>\r\n          </select><br><br>\r\n\r\n          <input type=\"checkbox\" id=\"proportional\" checked />\r\n          <label for=\"proportional\">#{obter_texto(:label_proporcao)}</label><br><br>\r\n\r\n          <button onclick=\"applyScale()\">#{obter_texto(:btn_aplicar)}</button>\r\n\r\n          <script>\r\n            function applyScale() {\r\n              const axis = document.getElementById('axis').value;\r\n              const length = parseFloat(document.getElementById('length').value);\r\n              const unit = document.getElementById('unit').value;\r\n              const proportional = document.getElementById('proportional').checked;\r\n              window.sketchup.apply_scale(axis, length, proportional, unit);\r\n            }\r\n          </script>\r\n        </body>\r\n        </html>\r\n      HTML\r\n\r\n      dlg.set_html(html)\r\n\r\n      dlg.add_action_callback(\"apply_scale\") do |_, axis, length, proportional, unit|\r\n        apply_scale(axis, length.to_f, proportional == true || proportional == \"true\", unit)\r\n      end\r\n\r\n      dlg.show\r\n    end\r\n\r\n    def self.apply_scale(axis, target_length, keep_proportion, unit)\r\n      model = Sketchup.active_model\r\n      sel = model.selection\r\n\r\n      unless sel.length == 1 && (sel.first.is_a?(Sketchup::ComponentInstance) || sel.first.is_a?(Sketchup::Group))\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n\r\n      instance = sel.first\r\n      bbox = instance.bounds\r\n\r\n      current_size = case axis\r\n      when 'X' then bbox.width\r\n      when 'Y' then bbox.height\r\n      when 'Z' then bbox.depth\r\n      else\r\n        UI.messagebox(obter_texto(:erro_eixo))\r\n        return\r\n      end\r\n\r\n      if current_size <= 0\r\n        UI.messagebox(obter_texto(:erro_dimensao) % axis)\r\n        return\r\n      end\r\n\r\n      length_inches = case unit\r\n      when 'cm' then target_length.cm\r\n      when 'm'  then target_length.m\r\n      when 'mm' then target_length.mm\r\n      else target_length.cm\r\n      end\r\n\r\n      scale_factor = length_inches / current_size\r\n\r\n      x_scale = (keep_proportion || axis == 'X') ? scale_factor : 1.0\r\n      y_scale = (keep_proportion || axis == 'Y') ? scale_factor : 1.0\r\n      z_scale = (keep_proportion || axis == 'Z') ? scale_factor : 1.0\r\n\r\n      t = Geom::Transformation.scaling(instance.transformation.origin, x_scale, y_scale, z_scale)\r\n\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n      instance.transform!(t)\r\n      model.commit_operation\r\n    end\r\n  end\r\nend\r\n\r\nScriptUpComunidade::EscalarPorEixo.show_ui"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "mapeamento-uv-em-malha-curva-c4jfl",
    "title": {
      "pt": "Mapeamento UV em Malha Curva",
      "en": "UV Mapping on Curved Mesh",
      "es": "Mapeo UV en malla curva"
    },
    "author": "F√°bio Coutinho",
    "version": "1.6",
    "description": {
      "pt": "Promove o mapeamento UV de texturas aplicadas em superf√≠cie curva.",
      "en": "It promotes UV mapping of textures applied to curved surfaces.",
      "es": "Promueve el mapeo UV de texturas aplicadas a superficies curvas."
    },
    "keywords": {
      "pt": [
        "uv map"
      ],
      "en": [
        "uv map"
      ],
      "es": [
        "mapa uv"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module MapeadorUV\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :ativar_msg      => \"üñ±Ô∏è Clique em uma face com textura aplicada (ou com material aplicado em grupo acima).\",\r\n        :status_inicio   => \"Mova o mouse sobre a malha para escolher a face e o ponto inicial.\",\r\n        :erro_face       => \"‚ùå Clique em uma face v√°lida com textura aplicada ou grupo com material.\",\r\n        :status_erro     => \"‚ùå Nenhuma face v√°lida foi selecionada. Clique em uma face com textura.\",\r\n        :ponto1_capt     => \"üìå Ponto 1 capturado: %s\",\r\n        :msg_ponto2      => \"üñ±Ô∏è Mova o mouse e clique no segundo ponto para ajustar a dire√ß√£o do mapeamento.\",\r\n        :status_ponto2   => \"Agora clique em um segundo ponto na face para definir o sentido do mapeamento.\",\r\n        :op_nome         => \"Mapeamento UV Din√¢mico\",\r\n        :ponto2_capt     => \"üìå Ponto 2 capturado: %s\",\r\n        :finalizado      => \"‚úÖ Mapeamento finalizado. Clique em nova face ou mude de ferramenta para sair.\",\r\n        :status_final    => \"Mapeamento aplicado! Clique em nova face ou mude de ferramenta.\",\r\n        :erro_dinamico   => \"‚ö†Ô∏è Erro durante mapeamento din√¢mico: %s\",\r\n        :erro_material   => \"‚ùå Nenhum material com textura encontrado na hierarquia. Aplique um material primeiro.\",\r\n        :aviso_triang    => \"üî∫ Face com mais de 4 v√©rtices ‚Äî mapeando via triangula√ß√£o inicial\",\r\n        :aviso_limitacao => \"‚ö†Ô∏è Face com mais de 4 v√©rtices ‚Äì aplicando apenas nos 4 primeiros v√©rtices para evitar erro.\",\r\n        :erro_sketchup   => \"‚ö†Ô∏è Face ignorada (SketchUp): %s\",\r\n        :insuficiente    => \"‚õî Mapeamento insuficiente em face adjacente, ignorada.\"\r\n      },\r\n      'en-US' => {\r\n        :ativar_msg      => \"üñ±Ô∏è Click on a face with texture applied (or material applied to a group above).\",\r\n        :status_inicio   => \"Move mouse over the mesh to choose face and start point.\",\r\n        :erro_face       => \"‚ùå Click on a valid face with texture or group with material.\",\r\n        :status_erro     => \"‚ùå No valid face selected. Click on a face with texture.\",\r\n        :ponto1_capt     => \"üìå Point 1 captured: %s\",\r\n        :msg_ponto2      => \"üñ±Ô∏è Move mouse and click on second point to adjust mapping direction.\",\r\n        :status_ponto2   => \"Now click a second point on the face to define mapping direction.\",\r\n        :op_nome         => \"Dynamic UV Mapping\",\r\n        :ponto2_capt     => \"üìå Point 2 captured: %s\",\r\n        :finalizado      => \"‚úÖ Mapping finished. Click a new face or change tool to exit.\",\r\n        :status_final    => \"Mapping applied! Click a new face or change tool.\",\r\n        :erro_dinamico   => \"‚ö†Ô∏è Error during dynamic mapping: %s\",\r\n        :erro_material   => \"‚ùå No textured material found in hierarchy. Apply a material first.\",\r\n        :aviso_triang    => \"üî∫ Face with more than 4 vertices ‚Äî mapping via initial triangulation\",\r\n        :aviso_limitacao => \"‚ö†Ô∏è Face with more than 4 vertices ‚Äì applying only to first 4 vertices to avoid error.\",\r\n        :erro_sketchup   => \"‚ö†Ô∏è Face ignored (SketchUp): %s\",\r\n        :insuficiente    => \"‚õî Insufficient mapping on adjacent face, ignored.\"\r\n      },\r\n      'es' => {\r\n        :ativar_msg      => \"üñ±Ô∏è Haga clic en una cara con textura aplicada (o material aplicado en grupo superior).\",\r\n        :status_inicio   => \"Mueva el rat√≥n sobre la malla para elegir la cara y el punto inicial.\",\r\n        :erro_face       => \"‚ùå Haga clic en una cara v√°lida con textura o grupo con material.\",\r\n        :status_erro     => \"‚ùå No se seleccion√≥ ninguna cara v√°lida. Haga clic en una cara con textura.\",\r\n        :ponto1_capt     => \"üìå Punto 1 capturado: %s\",\r\n        :msg_ponto2      => \"üñ±Ô∏è Mueva el rat√≥n y haga clic en el segundo punto para ajustar la direcci√≥n.\",\r\n        :status_ponto2   => \"Ahora haga clic en un segundo punto en la cara para definir el sentido del mapeo.\",\r\n        :op_nome         => \"Mapeo UV Din√°mico\",\r\n        :ponto2_capt     => \"üìå Punto 2 capturado: %s\",\r\n        :finalizado      => \"‚úÖ Mapeo finalizado. Haga clic en una nueva cara o cambie de herramienta para salir.\",\r\n        :status_final    => \"¬°Mapeo aplicado! Haga clic en una nueva cara o cambie de herramienta.\",\r\n        :erro_dinamico   => \"‚ö†Ô∏è Error durante el mapeo din√°mico: %s\",\r\n        :erro_material   => \"‚ùå No se encontr√≥ material con textura en la jerarqu√≠a. Aplique un material primero.\",\r\n        :aviso_triang    => \"üî∫ Cara con m√°s de 4 v√©rtices ‚Äî mapeando v√≠a triangulaci√≥n inicial\",\r\n        :aviso_limitacao => \"‚ö†Ô∏è Cara con m√°s de 4 v√©rtices ‚Äì aplicando solo a los primeros 4 para evitar errores.\",\r\n        :erro_sketchup   => \"‚ö†Ô∏è Cara ignorada (SketchUp): %s\",\r\n        :insuficiente    => \"‚õî Mapeo insuficiente en cara adyacente, ignorada.\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    TOLERANCE = 0.001 unless defined?(TOLERANCE)\r\n\r\n    class DynamicDirectionTool\r\n      def initialize\r\n        reset\r\n      end\r\n\r\n      def reset\r\n        @state = 0\r\n        @picked_face = nil\r\n        @input1 = Sketchup::InputPoint.new\r\n        @input2 = Sketchup::InputPoint.new\r\n        @ip_temp = Sketchup::InputPoint.new\r\n        @last_vector = nil\r\n      end\r\n\r\n      def activate\r\n        puts MapeadorUV.obter_texto(:ativar_msg)\r\n        Sketchup.set_status_text(MapeadorUV.obter_texto(:status_inicio), SB_PROMPT)\r\n      end\r\n\r\n      def onMouseMove(flags, x, y, view)\r\n        if @state == 0\r\n          @ip_temp.pick(view, x, y)\r\n          view.invalidate\r\n        elsif @state == 1\r\n          @input2.pick(view, x, y, @input1)\r\n          view.invalidate\r\n\r\n          return unless @input2.valid?\r\n\r\n          new_vec = @input2.position - @input1.position\r\n          return if new_vec.length < 1e-4\r\n\r\n          unless @last_vector && MapeadorUV.safe_samedirection?(@last_vector, new_vec)\r\n            @last_vector = new_vec\r\n            begin\r\n              success = MapeadorUV.reapply_mapping_on_face(@picked_face, @input1.position, @input2.position, @input1)\r\n              MapeadorUV.propagate_uv_using_uvhelper(@picked_face) if success\r\n            rescue => e\r\n              puts MapeadorUV.obter_texto(:erro_dinamico) % e.message\r\n            end\r\n          end\r\n        end\r\n      end\r\n\r\n      def onLButtonDown(flags, x, y, view)\r\n        model = Sketchup.active_model\r\n\r\n        if @state == 0\r\n          @input1.pick(view, x, y)\r\n          if !@input1.face\r\n            puts MapeadorUV.obter_texto(:erro_face)\r\n            Sketchup.set_status_text(MapeadorUV.obter_texto(:status_erro), SB_PROMPT)\r\n            return\r\n          end\r\n          @picked_face = @input1.face\r\n          puts MapeadorUV.obter_texto(:ponto1_capt) % @input1.position.to_s\r\n          puts MapeadorUV.obter_texto(:msg_ponto2)\r\n          Sketchup.set_status_text(MapeadorUV.obter_texto(:status_ponto2), SB_PROMPT)\r\n          model.start_operation(MapeadorUV.obter_texto(:op_nome), true)\r\n          @state = 1\r\n        elsif @state == 1\r\n          @input2.pick(view, x, y, @input1)\r\n          puts MapeadorUV.obter_texto(:ponto2_capt) % @input2.position.to_s\r\n          model.commit_operation\r\n          reset\r\n          puts MapeadorUV.obter_texto(:finalizado)\r\n          Sketchup.set_status_text(MapeadorUV.obter_texto(:status_final), SB_PROMPT)\r\n        end\r\n      end\r\n\r\n      def draw(view)\r\n        if @state == 0 && @ip_temp.valid? && @ip_temp.face\r\n          path = @ip_temp.instance_path\r\n          trans = path ? path.transformation : IDENTITY\r\n          view.drawing_color = 'red'\r\n          points = @ip_temp.face.outer_loop.vertices.map { |v| v.position.transform(trans) }\r\n          view.draw(GL_LINE_LOOP, points)\r\n        end\r\n\r\n        if @input1.valid?\r\n          view.drawing_color = 'green'\r\n          view.draw_points([@input1.position], 10, 3)\r\n        end\r\n\r\n        if @input2.valid?\r\n          view.drawing_color = 'green'\r\n          view.draw_points([@input2.position], 10, 3)\r\n          view.drawing_color = 'red'\r\n          view.draw_line(@input1.position, @input2.position)\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      Sketchup.active_model.tools.push_tool(DynamicDirectionTool.new)\r\n      true\r\n    end\r\n\r\n    def self.safe_samedirection?(vec1, vec2)\r\n      return false unless vec1.is_a?(Geom::Vector3d) && vec2.is_a?(Geom::Vector3d)\r\n      return false if vec1.length < 1e-4 || vec2.length < 1e-4\r\n      vec1.samedirection?(vec2)\r\n    rescue\r\n      false\r\n    end\r\n\r\n    def self.find_material_in_path(input_point)\r\n      return nil unless input_point\r\n      path = input_point.instance_path\r\n      return nil unless path\r\n      path.reverse_each do |entity|\r\n        next unless entity.respond_to?(:material)\r\n        mat = entity.material\r\n        return mat if mat && mat.texture\r\n      end\r\n      nil\r\n    end\r\n\r\n    def self.reapply_mapping_on_face(face, pt1, pt2, input_point)\r\n      material = face.material\r\n      material ||= find_material_in_path(input_point)\r\n\r\n      unless material && material.texture\r\n        puts obter_texto(:erro_material)\r\n        return false\r\n      end\r\n\r\n      return false if pt1.distance(pt2) < 1e-4\r\n\r\n      tex = material.texture\r\n      tex_w = tex.width.to_f\r\n      tex_h = tex.height.to_f\r\n\r\n      u_axis = (pt2 - pt1).normalize\r\n      z_axis = face.normal\r\n      v_axis = z_axis.cross(u_axis)\r\n      return false if v_axis.length < 1e-6\r\n      v_axis.normalize!\r\n      origin = pt1\r\n\r\n      if face.vertices.size > 4\r\n        puts obter_texto(:aviso_triang)\r\n        mesh = face.mesh(7)\r\n        points = mesh.points\r\n        uv_by_point = {}\r\n\r\n        points.each do |pos|\r\n          vec = pos - origin\r\n          u = vec.dot(u_axis) / tex_w\r\n          v = vec.dot(v_axis) / tex_h\r\n          uv_by_point[pos] = Geom::Point3d.new(u, v, 0)\r\n        end\r\n\r\n        triangles = mesh.polygons.map do |indices|\r\n          indices = indices.map { |i| i.abs - 1 }\r\n          [points[indices[0]], points[indices[1]], points[indices[2]]]\r\n        end\r\n\r\n        ents = face.parent.entities\r\n        ents.erase_entities(face)\r\n\r\n        triangles.each do |tri_pts|\r\n          new_face = ents.add_face(tri_pts)\r\n          next unless new_face && new_face.valid?\r\n          new_face.material = material\r\n\r\n          mapping = tri_pts.map { |pt| [pt, uv_by_point[pt]] }.flatten\r\n          begin\r\n            new_face.position_material(material, mapping, true)\r\n          rescue => e\r\n            puts \"‚ö†Ô∏è Erro: #{e.message}\"\r\n          end\r\n\r\n          new_face.edges.each do |edge|\r\n            edge.soft = true\r\n            edge.smooth = true\r\n            edge.hidden = false\r\n          end\r\n        end\r\n        return true\r\n      end\r\n\r\n      mapping = []\r\n      face.vertices.each do |v|\r\n        pos = v.position\r\n        vec = pos - origin\r\n        u = vec.dot(u_axis) / tex_w\r\n        v = vec.dot(v_axis) / tex_h\r\n        mapping << pos\r\n        mapping << Geom::Point3d.new(u, v, 0)\r\n      end\r\n\r\n      mapping = mapping[0, 8] if mapping.size > 8\r\n      face.material = material\r\n      face.position_material(material, mapping, true)\r\n      true\r\n    rescue => e\r\n      puts \"‚ö†Ô∏è Erro: #{e.message}\"\r\n      false\r\n    end\r\n\r\n    def self.propagate_uv_using_uvhelper(start_face)\r\n      material = start_face.material || find_material_in_path(Sketchup::InputPoint.new.tap { |ip| ip.pick(start_face.vertices.first.position) })\r\n      return unless material && material.texture\r\n\r\n      visited = {}\r\n      queue = [start_face]\r\n      visited[start_face] = true\r\n\r\n      while !queue.empty?\r\n        current_face = queue.shift\r\n        current_face.material = material\r\n\r\n        tw = Sketchup.create_texture_writer\r\n        tw.load(current_face, true)\r\n        uv_helper = current_face.get_UVHelper(true, true, tw)\r\n\r\n        current_face.edges.each do |edge|\r\n          next unless edge.soft?\r\n          edge.faces.each do |adj_face|\r\n            next if adj_face == current_face || visited[adj_face]\r\n            visited[adj_face] = true\r\n            shared_vertices = adj_face.vertices.select { |v1|\r\n              current_face.vertices.any? { |v2| v1.position.distance(v2.position) < TOLERANCE }\r\n            }\r\n            next if shared_vertices.size < 2\r\n\r\n            if adj_face.vertices.size <= 4\r\n              mapping_array = adj_face.vertices.map do |v|\r\n                pos = v.position\r\n                uvq = uv_helper.get_front_UVQ(pos)\r\n                (uvq && uvq.z != 0) ? [pos, Geom::Point3d.new(uvq.x / uvq.z, uvq.y / uvq.z, 0)] : nil\r\n              end.compact.flatten\r\n\r\n              if mapping_array.size > 8\r\n                puts obter_texto(:aviso_limitacao)\r\n                mapping_array = mapping_array[0, 8]\r\n              end\r\n\r\n              if mapping_array.size >= 6\r\n                begin\r\n                  adj_face.material = material\r\n                  adj_face.position_material(material, mapping_array, true)\r\n                  queue << adj_face\r\n                rescue ArgumentError => e\r\n                  puts obter_texto(:erro_sketchup) % e.message\r\n                end\r\n              else\r\n                puts obter_texto(:insuficiente)\r\n              end\r\n            else\r\n              triangulate_and_map_face(adj_face, uv_helper, material)\r\n            end\r\n          end\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.triangulate_and_map_face(face, uv_helper, material)\r\n      mesh = face.mesh(7)\r\n      ents = face.parent.entities\r\n      points = mesh.points\r\n      uv_by_point = {}\r\n      points.each do |pt|\r\n        uvq = uv_helper.get_front_UVQ(pt)\r\n        uv = (uvq && uvq.z != 0) ? Geom::Point3d.new(uvq.x / uvq.z, uvq.y / uvq.z, 0) : Geom::Point3d.new(0, 0, 0)\r\n        uv_by_point[pt] = uv\r\n      end\r\n      model_edges_before = ents.grep(Sketchup::Edge).to_set\r\n      ents.erase_entities(face)\r\n      mesh.polygons.each do |indices|\r\n        tri_pts = indices.map { |i| points[i.abs - 1] }\r\n        new_face = ents.add_face(tri_pts)\r\n        next unless new_face && new_face.valid?\r\n        new_face.material = material\r\n        mapping = tri_pts.map { |pt| [pt, uv_by_point[pt]] }.flatten\r\n        begin\r\n          new_face.position_material(material, mapping, true)\r\n        rescue => e\r\n          puts \"‚ö†Ô∏è Erro: #{e.message}\"\r\n        end\r\n        new_face.edges.each do |edge|\r\n          unless model_edges_before.include?(edge)\r\n            edge.soft = true\r\n            edge.smooth = true\r\n            edge.hidden = false\r\n          end\r\n        end\r\n      end\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::MapeadorUV.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "nivelador-de-grupos-e-componentes-c4l8s",
    "title": {
      "pt": "Nivelador de Grupos e Componentes",
      "en": "Group and Component Leveler",
      "es": "Nivelador de grupos y componentes"
    },
    "author": "Irene Magalh√£es",
    "version": "1.0",
    "description": {
      "pt": "Define o n√≠vel (altura Z) de grupos e componentes respeitando a unidade do modelo. Inspirado no drop of level.",
      "en": "Defines the level (Z-height) of groups and components while respecting the model's unity. Inspired by the drop-of-level principle.",
      "es": "Define el nivel (altura Z) de grupos y componentes, respetando la unidad del modelo. Inspirado en el principio de ca√≠da de nivel."
    },
    "keywords": {
      "pt": [
        "altura",
        "n√≠vel"
      ],
      "en": [
        "height",
        "level"
      ],
      "es": [
        "altura",
        "nivel"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module DefinirNivel\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :label_altura  => \"Altura (na unidade do modelo):\",\r\n        :titulo_input  => \"Definir N√≠vel do Objeto\",\r\n        :erro_selecao  => \"Por favor, selecione pelo menos um elemento.\",\r\n        :op_nome       => \"Ajustar N√≠vel\",\r\n        :log_info      => \"Comando 'N√≠vel' executado por Irene Magalh√£es ‚îÇ arq ‚Äì v1.00\"\r\n      },\r\n      'en-US' => {\r\n        :label_altura  => \"Height (model unit):\",\r\n        :titulo_input  => \"Set Object Level\",\r\n        :erro_selecao  => \"Please select at least one element.\",\r\n        :op_nome       => \"Adjust Level\",\r\n        :log_info      => \"Command 'Level' executed by Irene Magalh√£es ‚îÇ arq ‚Äì v1.00\"\r\n      },\r\n      'es' => {\r\n        :label_altura  => \"Altura (unidad del modelo):\",\r\n        :titulo_input  => \"Definir Nivel del Objeto\",\r\n        :erro_selecao  => \"Por favor, seleccione al menos un elemento.\",\r\n        :op_nome       => \"Ajustar Nivel\",\r\n        :log_info      => \"Comando 'Nivel' ejecutado por Irene Magalh√£es ‚îÇ arq ‚Äì v1.00\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.get_height_from_user\r\n      prompts = [obter_texto(:label_altura)]\r\n      defaults = [\"0\"]\r\n      input = UI.inputbox(prompts, defaults, obter_texto(:titulo_input))\r\n      return nil unless input\r\n      input[0].to_l\r\n    end\r\n\r\n    def self.validate_selection\r\n      selection = Sketchup.active_model.selection\r\n      if selection.empty?\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return false\r\n      end\r\n      true\r\n    end\r\n\r\n    def self.perform_drop(entity, height)\r\n      case entity\r\n      when Sketchup::Group, Sketchup::ComponentInstance\r\n        current_z = entity.transformation.origin.z\r\n        delta_z = height - current_z\r\n        entity.transform!(Geom::Transformation.translation([0, 0, delta_z]))\r\n      when Sketchup::Edge\r\n        entity.vertices.each do |vertex|\r\n          pos = vertex.position\r\n          vertex.position = Geom::Point3d.new(pos.x, pos.y, height)\r\n        end\r\n      when Sketchup::Face\r\n        # Usando o centro do bounding box para faces para determinar o deslocamento Z\r\n        current_z = entity.bounds.center.z\r\n        delta_z = height - current_z\r\n        entity.transform!(Geom::Transformation.translation([0, 0, delta_z]))\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      return unless validate_selection\r\n\r\n      height = get_height_from_user\r\n      return unless height\r\n\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n      \r\n      selection = model.selection\r\n      selection.each { |entity| perform_drop(entity, height) }\r\n\r\n      model.commit_operation\r\n      model.active_view.invalidate\r\n\r\n      puts obter_texto(:log_info)\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::DefinirNivel.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "ocultar-linhas-do-bloco-c4ms5",
    "title": {
      "pt": "Ocultar Linhas do Bloco",
      "en": "Hide Block Lines",
      "es": "Ocultar l√≠neas de bloque"
    },
    "author": "Matheus Narita",
    "version": "1.0",
    "description": {
      "pt": "Oculta todas as arestas dentro dos grupos e componentes selecionados, incluindo os aninhados.",
      "en": "Hides all edges within the selected groups and components, including nested ones.",
      "es": "Oculta todos los bordes dentro de los grupos y componentes seleccionados, incluidos los anidados."
    },
    "keywords": {
      "pt": [
        "ocultar linhas"
      ],
      "en": [
        "hide lines"
      ],
      "es": [
        "ocultar l√≠neas"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module OcultarLinhasBlocos\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :op_nome => \"Ocultar Linhas do Bloco\",\r\n        :sucesso => \"Linhas ocultadas dentro dos blocos selecionados!\"\r\n      },\r\n      'en-US' => {\r\n        :op_nome => \"Hide Block Edges\",\r\n        :sucesso => \"Edges hidden inside selected blocks!\"\r\n      },\r\n      'es' => {\r\n        :op_nome => \"Ocultar L√≠neas del Bloque\",\r\n        :sucesso => \"¬°L√≠neas ocultadas dentro de los bloques seleccionados!\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.ocultar_linhas(entities)\r\n      entities.grep(Sketchup::Edge).each do |edge|\r\n        edge.hidden = true\r\n      end\r\n\r\n      # Percorrer grupos e componentes aninhados tamb√©m\r\n      entities.grep(Sketchup::Group).each { |group| ocultar_linhas(group.entities) }\r\n      entities.grep(Sketchup::ComponentInstance).each { |comp| ocultar_linhas(comp.definition.entities) }\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n\r\n      selection.each do |entity|\r\n        if entity.is_a?(Sketchup::Group)\r\n          ocultar_linhas(entity.entities)\r\n        elsif entity.is_a?(Sketchup::ComponentInstance)\r\n          ocultar_linhas(entity.definition.entities)\r\n        end\r\n      end\r\n\r\n      model.commit_operation\r\n\r\n      puts obter_texto(:sucesso)\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::OcultarLinhasBlocos.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "orbitar-360-c4oua",
    "title": {
      "pt": "Orbitar 360¬∫",
      "en": "Orbit 360¬∫",
      "es": "√ìrbita 360¬∫"
    },
    "author": "F√°bio Couitnho",
    "version": "1.0",
    "description": {
      "pt": "Orbita, de forma cont√≠nua, 360¬∫ ao redor de um elemento selecionado, podendo controlar a velorcidade, √¢ngulo de observa√ß√£o e dist√¢ncia do objetivo.",
      "en": "It orbits continuously 360¬∫ around a selected element, allowing control over speed, viewing angle, and distance from the target.",
      "es": "Orbita continuamente 360¬∫ alrededor de un elemento seleccionado, lo que permite controlar la velocidad, el √°ngulo de visi√≥n y la distancia al objetivo."
    },
    "keywords": {
      "pt": [
        "orbitar 360"
      ],
      "en": [
        "orbit 360"
      ],
      "es": [
        "√≥rbita 360"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module VisualizacaoOrbital\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao   => \"‚ùå Selecione algum elemento antes de executar.\",\r\n        :erro_volume    => \"‚ùå Nenhum elemento com volume vis√≠vel foi encontrado na sele√ß√£o.\",\r\n        :titulo_janela  => \"Visualiza√ß√£o Orbital Cont√≠nua\",\r\n        :label_rpm      => \"Velocidade (voltas por minuto):\",\r\n        :label_pitch    => \"Inclina√ß√£o (√¢ngulo vertical):\",\r\n        :label_dist     => \"Dist√¢ncia do observador:\",\r\n        :btn_encerrar   => \"üõë Encerrar Visualiza√ß√£o\",\r\n        :msg_encerrado  => \"‚èπÔ∏è Visualiza√ß√£o orbital encerrada.\",\r\n        :op_nome        => \"√ìrbita de C√¢mera\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao   => \"‚ùå Select an element before running.\",\r\n        :erro_volume    => \"‚ùå No visible elements with volume found in selection.\",\r\n        :titulo_janela  => \"Continuous Orbit View\",\r\n        :label_rpm      => \"Speed (rotations per minute):\",\r\n        :label_pitch    => \"Pitch (vertical angle):\",\r\n        :label_dist     => \"Observer distance:\",\r\n        :btn_encerrar   => \"üõë Stop Visualization\",\r\n        :msg_encerrado  => \"‚èπÔ∏è Orbital visualization stopped.\",\r\n        :op_nome        => \"Camera Orbit\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao   => \"‚ùå Seleccione alg√∫n elemento antes de ejecutar.\",\r\n        :erro_volume    => \"‚ùå No se encontraron elementos con volumen visible en la selecci√≥n.\",\r\n        :titulo_janela  => \"Visualizaci√≥n Orbital Continua\",\r\n        :label_rpm      => \"Velocidad (vueltas por minuto):\",\r\n        :label_pitch    => \"Inclinaci√≥n (√°ngulo vertical):\",\r\n        :label_dist     => \"Distancia del observador:\",\r\n        :btn_encerrar   => \"üõë Finalizar Visualizaci√≥n\",\r\n        :msg_encerrado  => \"‚èπÔ∏è Visualizaci√≥n orbital finalizada.\",\r\n        :op_nome        => \"√ìrbita de C√°mara\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.rpm_to_rad_per_frame(rpm)\r\n      (rpm * 2 * Math::PI) / 60.0 / 60.0\r\n    end\r\n\r\n    def self.deg_to_rad(deg)\r\n      deg * Math::PI / 180.0\r\n    end\r\n\r\n    def self.update_camera_orbit\r\n      view = Sketchup.active_model.active_view\r\n      camera = view.camera\r\n\r\n      $orbita_angle += rpm_to_rad_per_frame($orbita_rpm)\r\n      radius = $orbita_base_radius * $orbita_radius_multiplier\r\n      pitch_rad = deg_to_rad($orbita_pitch_deg)\r\n\r\n      x = radius * Math.cos($orbita_angle)\r\n      y = radius * Math.sin($orbita_angle)\r\n      horizontal_distance = Math.sqrt(x**2 + y**2)\r\n      dz = Math.tan(pitch_rad) * horizontal_distance\r\n      z = $orbita_center.z + dz\r\n\r\n      eye = Geom::Point3d.new($orbita_center.x + x, $orbita_center.y + y, z)\r\n      target = $orbita_center\r\n\r\n      direction = target - eye\r\n      z_axis = Geom::Vector3d.new(0, 0, 1)\r\n      right = direction.cross(z_axis).normalize\r\n      up = right.cross(direction).normalize\r\n\r\n      camera.set(eye, target, up)\r\n      view.camera = camera\r\n      view.refresh\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      if selection.empty?\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n\r\n      bounds = Geom::BoundingBox.new\r\n      tem_bounds = false\r\n\r\n      selection.each do |e|\r\n        if e.respond_to?(:bounds)\r\n          bounds.add(e.bounds)\r\n          tem_bounds = true\r\n        end\r\n      end\r\n\r\n      if !tem_bounds\r\n        UI.messagebox(obter_texto(:erro_volume))\r\n        return\r\n      end\r\n\r\n      $orbita_center = bounds.center\r\n      model.selection.clear\r\n      $orbita_base_radius = bounds.diagonal * 1.5\r\n\r\n      $orbita_angle = 0.0\r\n      $orbita_rpm = 2.0\r\n      $orbita_pitch_deg = 15.0\r\n      $orbita_radius_multiplier = 1.0\r\n\r\n      $orbita_timer = UI.start_timer(0.016, true) { update_camera_orbit }\r\n\r\n      html = <<-HTML\r\n      <html>\r\n        <body style=\"font-family:system-ui; margin:16px; background:#f9f9f9;\">\r\n          <h2>üé• #{obter_texto(:titulo_janela)}</h2>\r\n\r\n          <label for=\"rpm\"><b>#{obter_texto(:label_rpm)}</b></label><br>\r\n          <input type=\"range\" id=\"rpm\" min=\"0.1\" max=\"20\" step=\"0.1\" value=\"#{$orbita_rpm}\" style=\"width:100%;\">\r\n          <div><span id=\"rpm_val\">#{$orbita_rpm.round(1)}</span> RPM</div>\r\n\r\n          <label for=\"pitch\"><b>#{obter_texto(:label_pitch)}</b></label><br>\r\n          <input type=\"range\" id=\"pitch\" min=\"-60\" max=\"60\" step=\"1\" value=\"#{$orbita_pitch_deg}\" style=\"width:100%;\">\r\n          <div><span id=\"pitch_val\">#{$orbita_pitch_deg.round(1)}</span>¬∞</div>\r\n\r\n          <label for=\"dist\"><b>#{obter_texto(:label_dist)}</b></label><br>\r\n          <input type=\"range\" id=\"dist\" min=\"0.5\" max=\"5\" step=\"0.1\" value=\"#{$orbita_radius_multiplier}\" style=\"width:100%;\">\r\n          <div><span id=\"dist_val\">#{$orbita_radius_multiplier.round(1)}</span>x</div>\r\n\r\n          <hr style=\"margin:16px 0;\">\r\n          <button onclick=\"window.location='skp:stop_orbit@'\" style=\"padding:8px 16px; font-weight:bold; background:#d33; color:#fff; border:none; border-radius:4px; cursor:pointer;\">\r\n            #{obter_texto(:btn_encerrar)}\r\n          </button>\r\n\r\n          <script>\r\n            function bindSlider(id, callback) {\r\n              const slider = document.getElementById(id);\r\n              const valSpan = document.getElementById(id + \"_val\");\r\n              slider.addEventListener(\"input\", () => {\r\n                valSpan.innerText = slider.value;\r\n                window.location = 'skp:' + callback + '@' + slider.value;\r\n              });\r\n            }\r\n\r\n            bindSlider(\"rpm\", \"update_rpm\");\r\n            bindSlider(\"pitch\", \"update_pitch\");\r\n            bindSlider(\"dist\", \"update_distance\");\r\n          </script>\r\n        </body>\r\n      </html>\r\n      HTML\r\n\r\n      dlg = UI::HtmlDialog.new({\r\n        dialog_title: obter_texto(:titulo_janela),\r\n        preferences_key: \"orbita_dinamica_gui\",\r\n        resizable: false,\r\n        width: 360,\r\n        height: 420,\r\n        style: UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n\r\n      dlg.set_html(html)\r\n\r\n      dlg.set_on_closed {\r\n        UI.stop_timer($orbita_timer) if $orbita_timer\r\n        $orbita_timer = nil\r\n        puts obter_texto(:msg_encerrado)\r\n      }\r\n\r\n      dlg.add_action_callback(\"update_rpm\") { |_, val| $orbita_rpm = val.to_f }\r\n      dlg.add_action_callback(\"update_pitch\") { |_, val| $orbita_pitch_deg = val.to_f }\r\n      dlg.add_action_callback(\"update_distance\") { |_, val| $orbita_radius_multiplier = val.to_f }\r\n\r\n      dlg.add_action_callback(\"stop_orbit\") do |_|\r\n        UI.stop_timer($orbita_timer) if $orbita_timer\r\n        $orbita_timer = nil\r\n        dlg.close\r\n      end\r\n\r\n      dlg.show\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::VisualizacaoOrbital.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "gerenciador-de-pavimentos-c4q93",
    "title": {
      "pt": "Gerenciador de Pavimentos",
      "en": "Floor Manager",
      "es": "Gerente de piso"
    },
    "author": "Kalylla | Arquiteta",
    "version": "1.0",
    "description": {
      "pt": "Permite criar se√ß√µes de planta-baixa, forro e cortes automaticamente de acordo com configura√ß√µes de quantidade de pavimentos e alturas personalizadas pelo usu√°rio.",
      "en": "Allows you to automatically create floor plan, ceiling, and section plans according to user-customized settings for the number of floors and heights.",
      "es": "Le permite crear autom√°ticamente planos de planta, techo y secciones seg√∫n la configuraci√≥n personalizada del usuario para la cantidad de pisos y alturas."
    },
    "keywords": {
      "pt": [
        "pavimentos"
      ],
      "en": [
        "floors"
      ],
      "es": [
        "pisos"
      ]
    },
    "code": {
      "pt": "# -------------------------------------------------------------\r\n# # Script: Gerenciador de Pavimentos\r\n# Autor: Kalylla | Arquiteta\r\n# Inspiracao: 5D Auto\r\n# Versao: v1.00\r\n# Idiomas: PT/BR | EN | ES\r\n# Descricao: Permite criar secoes de planta-baixa, forro e cortes\r\n# automaticamente de acordo com configuracoes de quantidade de\r\n# pavimentos e alturas personalizadas pelo usuario.\r\n# -------------------------------------------------------------\r\n\r\nmodule ScriptUpComunidade\r\n  module GerenciadorPavimentos\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :titulo                      => \"Gerenciador de Niveis\",\r\n        :selecionar_pavimento        => \"-- Selecione um pavimento --\",\r\n        :editar_pavimento            => \"Editar Pavimento:\",\r\n        :selecionar_unidade          => \"Unidade de Medida:\",\r\n        :nome_pavimento              => \"Nome do Pavimento:\",\r\n        :placeholder_nome            => \"Digite o nome do pavimento\",\r\n        :nivel_pavimento             => \"Nivel do Pavimento:\",\r\n        :altura_pavimento            => \"Altura do Pavimento:\",\r\n        :planta_baixa_altura         => \"Planta Baixa (altura):\",\r\n        :botao_salvar                => \"Salvar edicoes\",\r\n        :botao_criar                 => \"Criar Pavimento\",\r\n        :titulo_niveis               => \"Niveis no Projeto:\",\r\n        :carregar_dados              => \"Carregar dados\",\r\n        :botao_excluir               => \"Excluir\",\r\n        :botao_salvar_dados          => \"Salvar\",\r\n        :secoes_forro                => \"Secoes Forro\",\r\n        :secoes_planta               => \"Secoes Planta\",\r\n        :secoes_corte                => \"Secoes Corte\",\r\n        :corte_extra_x               => \"Corte Extra X\",\r\n        :corte_extra_y               => \"Corte Extra Y\",\r\n        :idioma                      => \"Idioma\",\r\n        :tema_claro                  => \"Tema Claro\",\r\n        :tema_escuro                 => \"Tema Escuro\",\r\n        :sem_geometria               => \"Nenhuma geometria encontrada para posicionar os cortes!\",\r\n        :confirmar_exclusao_titulo   => \"Deseja excluir os pavimentos selecionados?\",\r\n        :confirmar_exclusao_mensagem => \"Esta acao e irreversivel e ira apagar toda a configuracao dos pavimentos selecionados.\",\r\n        :botao_cancelar              => \"Cancelar\",\r\n        :botao_confirmar             => \"Confirmar\",\r\n        :titulo_alerta               => \"Atencao\",\r\n        :numero_invalido             => \"Por favor, insira valores numericos validos\",\r\n        :nenhum_selecionado          => \"Selecione pelo menos um pavimento\",\r\n        :dados_salvos                => \"Dados salvos com sucesso em:\",\r\n        :erro                        => \"Erro\",\r\n        :secao_frente                => \"Frente\",\r\n        :secao_tras                  => \"Tras\",\r\n        :secao_direita               => \"Direita\",\r\n        :secao_esquerda              => \"Esquerda\",\r\n        :secao                       => \"Secao\",\r\n        :nome_duplicado              => \"Ja existe um pavimento com este nome, escolha um nome exclusivo para o novo pavimento\",\r\n        :nivel_duplicado             => \"A cota do pavimento ja existe, verifique na tabela para nao criar pavimentos duplicados\",\r\n        :criar_secoes_primeiro       => \"Crie as secoes verticais primeiro ou verifique se ha geometria visivel!\",\r\n        :arquivo_invalido            => \"Arquivo invalido\",\r\n        :cabecalho_nome              => \"Pavimento\",\r\n        :cabecalho_nivel             => \"Nivel\",\r\n        :cabecalho_altura            => \"Altura\",\r\n        :cabecalho_planta            => \"Planta Baixa\",\r\n        :cabecalho_planta_z          => \"PB(z)\",\r\n        :unit_metros                 => \"Metros\",\r\n        :unit_centimetros            => \"Centimetros\",\r\n        :unit_milimetros             => \"Milimetros\",\r\n        :unit_polegadas              => \"Polegadas\",\r\n        :unit_jardas                 => \"Jardas\",\r\n        :unit_pes                    => \"Pes\"\r\n      },\r\n      'en-US' => {\r\n        :titulo                      => \"Sections Management\",\r\n        :selecionar_pavimento        => \"-- Select a floor --\",\r\n        :editar_pavimento            => \"Edit Floor:\",\r\n        :selecionar_unidade          => \"Measurement Unit:\",\r\n        :nome_pavimento              => \"Floor Name:\",\r\n        :placeholder_nome            => \"Enter floor name\",\r\n        :nivel_pavimento             => \"Floor Elevation:\",\r\n        :altura_pavimento            => \"Floor Height:\",\r\n        :planta_baixa_altura         => \"Floor Plan (height):\",\r\n        :botao_salvar                => \"Save changes\",\r\n        :botao_criar                 => \"Create Floor\",\r\n        :titulo_niveis               => \"Floors:\",\r\n        :carregar_dados              => \"Load data\",\r\n        :botao_excluir               => \"Delete\",\r\n        :botao_salvar_dados          => \"Save\",\r\n        :secoes_forro                => \"Ceiling Sections\",\r\n        :secoes_planta               => \"Plan Sections\",\r\n        :secoes_corte                => \"Sections\",\r\n        :corte_extra_x               => \"Extra Cut X\",\r\n        :corte_extra_y               => \"Extra Cut Y\",\r\n        :idioma                      => \"Language\",\r\n        :tema_claro                  => \"Light Theme\",\r\n        :tema_escuro                 => \"Dark Theme\",\r\n        :sem_geometria               => \"No geometry found to place cuts!\",\r\n        :confirmar_exclusao_titulo   => \"Do you want to delete selected floors?\",\r\n        :confirmar_exclusao_mensagem => \"This action is irreversible and will delete all configuration for selected floors.\",\r\n        :botao_cancelar              => \"Cancel\",\r\n        :botao_confirmar             => \"Confirm\",\r\n        :titulo_alerta               => \"Warning\",\r\n        :numero_invalido             => \"Please enter valid numeric values\",\r\n        :nenhum_selecionado          => \"Select at least one floor\",\r\n        :dados_salvos                => \"Data successfully saved at:\",\r\n        :erro                        => \"Error\",\r\n        :secao_frente                => \"Front\",\r\n        :secao_tras                  => \"Back\",\r\n        :secao_direita               => \"Right\",\r\n        :secao_esquerda              => \"Left\",\r\n        :secao                       => \"Section\",\r\n        :nome_duplicado              => \"A floor with this name already exists, please choose a unique name\",\r\n        :nivel_duplicado             => \"Floor elevation already exists, check the table to avoid duplicate floors\",\r\n        :criar_secoes_primeiro       => \"Create vertical sections first or check if there is visible geometry!\",\r\n        :arquivo_invalido            => \"Invalid file\",\r\n        :cabecalho_nome              => \"Floor Name\",\r\n        :cabecalho_nivel             => \"Elevation\",\r\n        :cabecalho_altura            => \"Height\",\r\n        :cabecalho_planta            => \"Floor Plan\",\r\n        :cabecalho_planta_z          => \"FP(z)\",\r\n        :unit_metros                 => \"Meters\",\r\n        :unit_centimetros            => \"Centimeters\",\r\n        :unit_milimetros             => \"Millimeters\",\r\n        :unit_polegadas              => \"Inches\",\r\n        :unit_jardas                 => \"Yards\",\r\n        :unit_pes                    => \"Feet\"\r\n      },\r\n      'es' => {\r\n        :titulo                      => \"Gestor de Pisos\",\r\n        :selecionar_pavimento        => \"-- Seleccione un piso --\",\r\n        :editar_pavimento            => \"Editar Piso:\",\r\n        :selecionar_unidade          => \"Unidad de Medida:\",\r\n        :nome_pavimento              => \"Nombre del Piso:\",\r\n        :placeholder_nome            => \"Ingrese nombre del piso\",\r\n        :nivel_pavimento             => \"Elevacion del Piso:\",\r\n        :altura_pavimento            => \"Altura del Piso:\",\r\n        :planta_baixa_altura         => \"Plano de Planta (altura):\",\r\n        :botao_salvar                => \"Guardar cambios\",\r\n        :botao_criar                 => \"Crear Piso\",\r\n        :titulo_niveis               => \"Pisos en el Proyecto:\",\r\n        :carregar_dados              => \"Cargar datos\",\r\n        :botao_excluir               => \"Eliminar\",\r\n        :botao_salvar_dados          => \"Guardar\",\r\n        :secoes_forro                => \"Secciones de Techo\",\r\n        :secoes_planta               => \"Secciones de Planta\",\r\n        :secoes_corte                => \"Secciones\",\r\n        :corte_extra_x               => \"Corte Extra X\",\r\n        :corte_extra_y               => \"Corte Extra Y\",\r\n        :idioma                      => \"Idioma\",\r\n        :tema_claro                  => \"Tema Claro\",\r\n        :tema_escuro                 => \"Tema Oscuro\",\r\n        :sem_geometria               => \"No se encontro geometria para colocar cortes!\",\r\n        :confirmar_exclusao_titulo   => \"Desea eliminar los pisos seleccionados?\",\r\n        :confirmar_exclusao_mensagem => \"Esta accion es irreversible y eliminara toda la configuracion de los pisos seleccionados.\",\r\n        :botao_cancelar              => \"Cancelar\",\r\n        :botao_confirmar             => \"Confirmar\",\r\n        :titulo_alerta               => \"Atencion\",\r\n        :numero_invalido             => \"Por favor ingrese valores numericos validos\",\r\n        :nenhum_selecionado          => \"Seleccione al menos un piso\",\r\n        :dados_salvos                => \"Datos guardados exitosamente en:\",\r\n        :erro                        => \"Error\",\r\n        :secao_frente                => \"Frente\",\r\n        :secao_tras                  => \"Atras\",\r\n        :secao_direita               => \"Derecha\",\r\n        :secao_esquerda              => \"Izquierda\",\r\n        :secao                       => \"Seccion\",\r\n        :nome_duplicado              => \"Ya existe un piso con este nombre, elija un nombre unico para el nuevo piso\",\r\n        :nivel_duplicado             => \"La elevacion del piso ya existe, verifique en la tabla para no crear pisos duplicados\",\r\n        :criar_secoes_primeiro       => \"Cree las secciones verticales primero o verifique si hay geometria visible!\",\r\n        :arquivo_invalido            => \"Archivo invalido\",\r\n        :cabecalho_nome              => \"Piso\",\r\n        :cabecalho_nivel             => \"Elevacion\",\r\n        :cabecalho_altura            => \"Altura\",\r\n        :cabecalho_planta            => \"Plano de Planta\",\r\n        :cabecalho_planta_z          => \"PL(z)\",\r\n        :unit_metros                 => \"Metros\",\r\n        :unit_centimetros            => \"Centimetros\",\r\n        :unit_milimetros             => \"Milimetros\",\r\n        :unit_polegadas              => \"Pulgadas\",\r\n        :unit_jardas                 => \"Yardas\",\r\n        :unit_pes                    => \"Pies\"\r\n      }\r\n    }\r\n\r\n    LANG_MAP = { 'pt' => 'pt-BR', 'en' => 'en-US', 'es' => 'es' }\r\n    LANG_SHORT = { 'pt-BR' => 'pt', 'en-US' => 'en', 'es' => 'es' }\r\n\r\n    UNIT_KEYS = [\r\n      ['metros',      :unit_metros],\r\n      ['centimetros', :unit_centimetros],\r\n      ['milimetros',  :unit_milimetros],\r\n      ['polegadas',   :unit_polegadas],\r\n      ['jardas',      :unit_jardas],\r\n      ['pes',         :unit_pes]\r\n    ]\r\n\r\n    # Inicializa variaveis de classe\r\n    @levels = []\r\n    @dialog = nil\r\n    @current_unit = 'metros'\r\n    @current_theme = Sketchup.read_default(\"level_manager\", \"theme\", \"day\")\r\n    @levels_mutex = Mutex.new\r\n\r\n    # Detecta idioma inicial via Sketchup.get_locale ou preferencia salva\r\n    saved_lang = Sketchup.read_default(\"level_manager\", \"language\", nil)\r\n    if saved_lang && IDIOMAS.key?(saved_lang)\r\n      @current_language = saved_lang\r\n    elsif saved_lang && LANG_MAP.key?(saved_lang)\r\n      @current_language = LANG_MAP[saved_lang]\r\n    else\r\n      locale = Sketchup.get_locale\r\n      @current_language = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n    end\r\n\r\n    def self.obter_texto(chave)\r\n      lang = @current_language || begin\r\n        locale = Sketchup.get_locale\r\n        IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      end\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    # Metodo principal para criar a interface\r\n    def self.criar_interface_niveis\r\n      begin\r\n        # Fecha o dialogo existente se estiver aberto\r\n        @dialog.close if @dialog && @dialog.visible?\r\n\r\n        options = {\r\n          :dialog_title => obter_texto(:titulo),\r\n          :preferences_key => 'com.example.levelmanager',\r\n          :width => 650,\r\n          :height => 580,\r\n          :resizable => true,\r\n          :style => UI::HtmlDialog::STYLE_DIALOG,\r\n          :min_width => 650,\r\n          :min_height => 580\r\n        }\r\n\r\n        @dialog = UI::HtmlDialog.new(options)\r\n\r\n        unit_options = UNIT_KEYS.map { |val, key| \"<option value='#{val}'>#{obter_texto(key)}</option>\" }.join\r\n        short_lang = LANG_SHORT[@current_language] || 'en'\r\n\r\n        html = <<-HTML\r\n          <!DOCTYPE html>\r\n          <html>\r\n          <head>\r\n            <meta charset=\"UTF-8\">\r\n            <style>\r\n              /* ====== ESTILOS GERAIS ====== */\r\n              body {\r\n                font-family: Arial, sans-serif;\r\n                padding: 10px;\r\n                margin: 0;\r\n                height: 100%;\r\n                box-sizing: border-box;\r\n                background-color: #ffffff;\r\n                color: #000000;\r\n              }\r\n\r\n              /* Tema noturno */\r\n              body.night {\r\n                background-color: #000000;\r\n                color: #ffffff;\r\n              }\r\n\r\n              /* ====== LAYOUT PRINCIPAL ====== */\r\n              #main-container {\r\n                display: flex;\r\n                flex-direction: column;\r\n                height: 100%;\r\n              }\r\n\r\n              /* Container da tabela */\r\n              #table-container {\r\n                flex-grow: 1;\r\n                overflow-y: auto;\r\n                margin-bottom: 10px;\r\n              }\r\n\r\n              /* ====== CABECALHOS E TITULOS ====== */\r\n              h3 {\r\n                margin-top: 0;\r\n              }\r\n\r\n              h4 {\r\n                margin-bottom: 5px;\r\n                display: flex;\r\n                align-items: center;\r\n              }\r\n\r\n              /* ====== FORMULARIOS E INPUTS ====== */\r\n              /* Grupos de inputs */\r\n              .input-group {\r\n                margin-bottom: 12px;\r\n              }\r\n\r\n              .name-input-group {\r\n                margin-top: 8px;\r\n                margin-bottom: 15px;\r\n              }\r\n\r\n              /* Linhas de inputs */\r\n              .input-row {\r\n                display: flex;\r\n                justify-content: space-between;\r\n                margin-bottom: 12px;\r\n              }\r\n\r\n              .selector-row {\r\n                display: flex;\r\n                justify-content: space-between;\r\n                margin-bottom: 15px;\r\n              }\r\n\r\n              /* Seletor de idioma */\r\n              .language-selector {\r\n                position: absolute;\r\n                top: 10px;\r\n                right: 60px;\r\n                display: flex;\r\n                align-items: center;\r\n                gap: 5px;\r\n                font-size: 9pt;\r\n              }\r\n\r\n              .language-selector select {\r\n                padding: 2px;\r\n                font-size: 9pt;\r\n              }\r\n\r\n              /* Campos individuais */\r\n              .input-field {\r\n                width: 30%;\r\n              }\r\n\r\n              .unit-selector,\r\n              .level-selector {\r\n                width: 48%;\r\n              }\r\n\r\n              /* Labels */\r\n              .input-label {\r\n                font-size: 10pt;\r\n                margin-bottom: 2px;\r\n              }\r\n\r\n              .input-field label {\r\n                font-size: 10pt;\r\n                display: block;\r\n                margin-bottom: 2px;\r\n              }\r\n\r\n              /* Inputs e selects */\r\n              .input-field input,\r\n              select,\r\n              #level_name {\r\n                width: 100%;\r\n                padding: 4px;\r\n                font-size: 11pt;\r\n                box-sizing: border-box;\r\n                background-color: #ffffff;\r\n                color: #000000;\r\n                border: 1px solid #ddd;\r\n              }\r\n\r\n              /* Input de nome do nivel */\r\n              #level_name {\r\n                width: 100%;\r\n              }\r\n\r\n              /* ====== TABELA DE NIVEIS ====== */\r\n              table {\r\n                width: 100%;\r\n                border-collapse: collapse;\r\n                margin-top: 8px;\r\n                font-size: 11pt;\r\n                table-layout: fixed;\r\n              }\r\n\r\n              th, td {\r\n                border: 1px solid #ddd;\r\n                padding: 6px;\r\n                text-align: left;\r\n                overflow: hidden;\r\n              }\r\n\r\n              th {\r\n                background-color: #f2f2f2;\r\n                font-size: 10pt;\r\n                white-space: nowrap;\r\n              }\r\n\r\n              /* Celulas editaveis */\r\n              .editable-cell {\r\n                cursor: pointer;\r\n                white-space: nowrap;\r\n                overflow: hidden;\r\n                text-overflow: ellipsis;\r\n              }\r\n\r\n              .editable-cell:hover {\r\n                background-color: #f5f5f5;\r\n              }\r\n\r\n              /* Checkbox na tabela */\r\n              .checkbox-column {\r\n                width: 30px;\r\n                text-align: center;\r\n              }\r\n\r\n              /* Input dentro da tabela */\r\n              .table-input {\r\n                width: 100%;\r\n                border: none;\r\n                padding: 0;\r\n                margin: 0;\r\n                font-size: 11pt;\r\n                background: transparent;\r\n                color: inherit;\r\n              }\r\n\r\n              /* ====== BOTOES ====== */\r\n              /* Containers de botoes */\r\n              .button-container {\r\n                display: flex;\r\n                justify-content: space-between;\r\n                margin-top: 15px;\r\n                margin-bottom: 10px;\r\n              }\r\n\r\n              .button-row {\r\n                display: flex;\r\n                justify-content: space-between;\r\n                margin-top: 10px;\r\n              }\r\n\r\n              .delete-save-container {\r\n                display: flex;\r\n                gap: 5px;\r\n              }\r\n\r\n              /* Estilo base para todos os botoes */\r\n              button {\r\n                padding: 5px 12px;\r\n                margin: 3px;\r\n                font-size: 11pt;\r\n                cursor: pointer;\r\n                border: none;\r\n                border-radius: 8px;\r\n              }\r\n\r\n              /* Cores especificas para botoes */\r\n              .delete-btn {\r\n                background-color: #f44336;\r\n                color: white;\r\n              }\r\n\r\n              .create-btn {\r\n                background-color: #2196F3;\r\n                color: white;\r\n              }\r\n\r\n              .save-btn {\r\n                background-color: #4CAF50;\r\n                color: white;\r\n              }\r\n\r\n              .section-btn {\r\n                background-color: #2196F3;\r\n                color: white;\r\n              }\r\n\r\n              .cut-btn {\r\n                background-color: #42A5F5;\r\n                color: white;\r\n              }\r\n\r\n              .load-btn {\r\n                background-color: #9E9E9E;\r\n                color: white;\r\n                padding: 3px 8px;\r\n                font-size: 10pt;\r\n                height: 24px;\r\n                margin-left: 5px;\r\n              }\r\n\r\n              /* ====== SECOES ESPECIFICAS ====== */\r\n              /* Seletor de tema */\r\n              .theme-switcher {\r\n                position: absolute;\r\n                top: 10px;\r\n                right: 10px;\r\n                display: flex;\r\n                gap: 0;\r\n              }\r\n\r\n              .theme-btn {\r\n                width: 24px;\r\n                height: 24px;\r\n                padding: 0;\r\n                margin: 0;\r\n                display: flex;\r\n                align-items: center;\r\n                justify-content: center;\r\n                border: 1px solid #ccc;\r\n                background-color: #f0f0f0;\r\n                border-radius: 0;\r\n                color: #000;\r\n              }\r\n\r\n              .theme-btn:first-child {\r\n                border-top-left-radius: 3px;\r\n                border-bottom-left-radius: 3px;\r\n              }\r\n\r\n              .theme-btn:last-child {\r\n                border-top-right-radius: 3px;\r\n                border-bottom-right-radius: 3px;\r\n              }\r\n\r\n              .theme-btn.active {\r\n                background-color: #ddd;\r\n                border: 1px solid #999;\r\n                box-shadow: inset 0 2px 3px rgba(0,0,0,0.2);\r\n              }\r\n\r\n              /* ====== DIALOGOS PERSONALIZADOS ====== */\r\n              .custom-dialog {\r\n                position: fixed;\r\n                top: 50%;\r\n                left: 50%;\r\n                transform: translate(-50%, -50%);\r\n                background-color: white;\r\n                padding: 20px;\r\n                border-radius: 5px;\r\n                box-shadow: 0 4px 8px rgba(0,0,0,0.2);\r\n                z-index: 1000;\r\n                width: 400px;\r\n                max-width: 90%;\r\n              }\r\n\r\n              .custom-dialog-title {\r\n                font-weight: bold;\r\n                margin-bottom: 15px;\r\n                font-size: 14pt;\r\n              }\r\n\r\n              .custom-dialog-message {\r\n                margin-bottom: 20px;\r\n              }\r\n\r\n              .custom-dialog-buttons {\r\n                display: flex;\r\n                justify-content: flex-end;\r\n                gap: 10px;\r\n              }\r\n\r\n              .custom-dialog-button {\r\n                padding: 8px 16px;\r\n                border: none;\r\n                border-radius: 4px;\r\n                cursor: pointer;\r\n                font-size: 11pt;\r\n              }\r\n\r\n              .custom-dialog-confirm {\r\n                background-color: #f44336;\r\n                color: white;\r\n              }\r\n\r\n              .custom-dialog-cancel {\r\n                background-color: #e0e0e0;\r\n              }\r\n\r\n              /* ====== TEMA NOTURNO ====== */\r\n              body.night .input-field input,\r\n              body.night select,\r\n              body.night #level_name,\r\n              body.night .table-input {\r\n                background-color: #333333;\r\n                color: #ffffff;\r\n                border-color: #555;\r\n              }\r\n\r\n              body.night th,\r\n              body.night td {\r\n                border-color: #555;\r\n              }\r\n\r\n              body.night th {\r\n                background-color: #333;\r\n              }\r\n\r\n              body.night .editable-cell:hover {\r\n                background-color: #333;\r\n              }\r\n\r\n              body.night .theme-btn {\r\n                background-color: #333;\r\n                border-color: #555;\r\n                color: #fff;\r\n              }\r\n\r\n              body.night .theme-btn.active {\r\n                background-color: #555;\r\n                border-color: #777;\r\n              }\r\n\r\n              body.night .custom-dialog {\r\n                background-color: #222;\r\n                color: white;\r\n              }\r\n\r\n              body.night .custom-dialog-cancel {\r\n                background-color: #444;\r\n                color: white;\r\n              }\r\n            </style>\r\n          </head>\r\n          <body class=\"#{@current_theme}\">\r\n            <div class=\"language-selector\">\r\n              <label>#{obter_texto(:idioma)}:</label>\r\n              <select id=\"language_selector\" onchange=\"changeLanguage()\">\r\n                <option value=\"pt\" #{@current_language == 'pt-BR' ? 'selected' : ''}>Portugu&#234;s</option>\r\n                <option value=\"en\" #{@current_language == 'en-US' ? 'selected' : ''}>English</option>\r\n                <option value=\"es\" #{@current_language == 'es' ? 'selected' : ''}>Espa&#241;ol</option>\r\n              </select>\r\n            </div>\r\n\r\n            <div class=\"theme-switcher\">\r\n              <button id=\"day-theme\" class=\"theme-btn #{@current_theme == 'day' ? 'active' : ''}\" onclick=\"setTheme('day')\" title=\"#{obter_texto(:tema_claro)}\">&#128262;</button>\r\n              <button id=\"night-theme\" class=\"theme-btn #{@current_theme == 'night' ? 'active' : ''}\" onclick=\"setTheme('night')\" title=\"#{obter_texto(:tema_escuro)}\">&#127769;</button>\r\n            </div>\r\n\r\n            <div id='main-container'>\r\n              <h3>#{obter_texto(:titulo)}</h3>\r\n\r\n              <div class='selector-row'>\r\n                <div class='level-selector'>\r\n                  <label class='input-label'>#{obter_texto(:editar_pavimento)}</label>\r\n                  <select id='level_selector' onchange='levelSelected()'>\r\n                    <option value=''>#{obter_texto(:selecionar_pavimento)}</option>\r\n                  </select>\r\n                </div>\r\n                <div class='unit-selector'>\r\n                  <label class='input-label'>#{obter_texto(:selecionar_unidade)}</label>\r\n                  <select id='unit_selector' onchange='unitChanged()'>\r\n                    #{unit_options}\r\n                  </select>\r\n                </div>\r\n              </div>\r\n\r\n              <div class='name-input-group'>\r\n                <label class='input-label'>#{obter_texto(:nome_pavimento)}</label>\r\n                <input type='text' id='level_name' placeholder=\"#{obter_texto(:placeholder_nome)}\" onkeypress=\"handleKeyPress(event)\">\r\n              </div>\r\n\r\n              <div class='input-row'>\r\n                <div class='input-field'>\r\n                  <label class='input-label'>#{obter_texto(:nivel_pavimento)}</label>\r\n                  <input type='text' id='base_level' value='0,00' onfocus=\"this.select();\" onkeypress=\"handleKeyPress(event)\">\r\n                </div>\r\n                <div class='input-field'>\r\n                  <label class='input-label'>#{obter_texto(:altura_pavimento)}</label>\r\n                  <input type='text' id='level_height' value='3,00' onfocus=\"this.select();\" onkeypress=\"handleKeyPress(event)\">\r\n                </div>\r\n                <div class='input-field'>\r\n                  <label class='input-label'>#{obter_texto(:planta_baixa_altura)}</label>\r\n                  <input type='text' id='plan_height' value='1,50' onfocus=\"this.select();\" onkeypress=\"handleKeyPress(event)\">\r\n                </div>\r\n              </div>\r\n\r\n              <div class='button-row'>\r\n                <button onclick='saveLevel()' class='save-btn'>#{obter_texto(:botao_salvar)}</button>\r\n                <button onclick='addLevel()' class='create-btn'>#{obter_texto(:botao_criar)}</button>\r\n              </div>\r\n\r\n              <div id='table-container'>\r\n                <h4>#{obter_texto(:titulo_niveis)}<button class='load-btn' onclick='loadData()'>#{obter_texto(:carregar_dados)}</button></h4>\r\n                <table id='levels_table'>\r\n                  <thead>\r\n                    <tr>\r\n                      <th class='checkbox-column'><input type='checkbox' id='select_all' onclick='toggleSelectAll()'></th>\r\n                      <th width='25%'>#{obter_texto(:cabecalho_nome)}</th>\r\n                      <th width='15%'>#{obter_texto(:cabecalho_nivel)}</th>\r\n                      <th width='15%'>#{obter_texto(:cabecalho_altura)}</th>\r\n                      <th width='15%'>#{obter_texto(:cabecalho_planta)}</th>\r\n                      <th width='15%'>#{obter_texto(:cabecalho_planta_z)}</th>\r\n                    </tr>\r\n                  </thead>\r\n                  <tbody id='levels_list'>\r\n                  </tbody>\r\n                </table>\r\n              </div>\r\n\r\n              <div class='button-container'>\r\n                  <div class='delete-save-container'>\r\n                      <button onclick='showDeleteConfirmation()' class='delete-btn'>#{obter_texto(:botao_excluir)}</button>\r\n                      <button onclick='saveData()' class='save-btn'>#{obter_texto(:botao_salvar_dados)}</button>\r\n                  </div>\r\n\r\n                  <div class='horizontal-sections'>\r\n                      <button onclick='createCeilingSections()' class='section-btn'>#{obter_texto(:secoes_forro)}</button>\r\n                      <button onclick='createSections()' class='section-btn'>#{obter_texto(:secoes_planta)}</button>\r\n                  </div>\r\n              </div>\r\n\r\n              <div class='button-container'>\r\n                  <div style='width: 100%; display: flex; justify-content: flex-end; gap: 5px;'>\r\n                      <button onclick='createExtraCutX()' class='section-btn'>#{obter_texto(:corte_extra_x)}</button>\r\n                      <button onclick='createExtraCutY()' class='section-btn'>#{obter_texto(:corte_extra_y)}</button>\r\n                      <button onclick='createVerticalSections()' class='section-btn cut-main-btn'>#{obter_texto(:secoes_corte)}</button>\r\n                  </div>\r\n              </div>\r\n\r\n            <script>\r\n              function validateNumber(input) {\r\n                const num = parseFloat(input.replace(',', '.'));\r\n                return !isNaN(num) && isFinite(num);\r\n              }\r\n\r\n              function formatNumber(value) {\r\n                return parseFloat(value).toFixed(2).replace('.', ',');\r\n              }\r\n\r\n              function handleKeyPress(e) {\r\n                if (e.key === 'Enter') {\r\n                  e.preventDefault();\r\n                  const levelSelector = document.getElementById('level_selector');\r\n                  if (levelSelector.value) {\r\n                    saveLevel();\r\n                  } else {\r\n                    addLevel();\r\n                  }\r\n                }\r\n              }\r\n\r\n              function toggleSelectAll() {\r\n                const selectAll = document.getElementById('select_all');\r\n                const checkboxes = document.querySelectorAll('#levels_list input[type=\"checkbox\"]');\r\n                checkboxes.forEach(checkbox => {\r\n                  checkbox.checked = selectAll.checked;\r\n                });\r\n              }\r\n\r\n              function editLevelField(levelId, field, value) {\r\n                sketchup.editLevelField(levelId, field, value);\r\n              }\r\n\r\n              function setTheme(theme) {\r\n                document.body.className = theme;\r\n                document.getElementById('day-theme').className = theme === 'day' ? 'theme-btn active' : 'theme-btn';\r\n                document.getElementById('night-theme').className = theme === 'night' ? 'theme-btn active' : 'theme-btn';\r\n                sketchup.setCurrentTheme(theme);\r\n              }\r\n\r\n              function changeLanguage() {\r\n                const langSelector = document.getElementById('language_selector');\r\n                sketchup.changeLanguage(langSelector.value);\r\n              }\r\n\r\n              function addLevel() {\r\n                const name = document.getElementById('level_name').value.trim();\r\n                if (!name) {\r\n                  showAlert('#{obter_texto(:titulo_alerta)}', '#{obter_texto(:placeholder_nome)}');\r\n                  return;\r\n                }\r\n\r\n                const baseZ = document.getElementById('base_level').value;\r\n                const height = document.getElementById('level_height').value;\r\n                const planHeight = document.getElementById('plan_height').value;\r\n\r\n                if (!validateNumber(baseZ) || !validateNumber(height) || !validateNumber(planHeight)) {\r\n                  showAlert('#{obter_texto(:titulo_alerta)}', '#{obter_texto(:numero_invalido)}');\r\n                  return;\r\n                }\r\n\r\n                sketchup.addLevel(name, baseZ.replace(',', '.'), height.replace(',', '.'), planHeight.replace(',', '.'));\r\n              }\r\n\r\n              function saveLevel() {\r\n                const levelId = document.getElementById('level_selector').value;\r\n                if (!levelId) {\r\n                  showAlert('#{obter_texto(:titulo_alerta)}', '#{obter_texto(:selecionar_pavimento)}');\r\n                  return;\r\n                }\r\n\r\n                const name = document.getElementById('level_name').value.trim();\r\n                const baseZ = document.getElementById('base_level').value;\r\n                const height = document.getElementById('level_height').value;\r\n                const planHeight = document.getElementById('plan_height').value;\r\n\r\n                if (!validateNumber(baseZ) || !validateNumber(height) || !validateNumber(planHeight)) {\r\n                  showAlert('#{obter_texto(:titulo_alerta)}', '#{obter_texto(:numero_invalido)}');\r\n                  return;\r\n                }\r\n\r\n                sketchup.saveLevel(levelId, name, baseZ.replace(',', '.'), height.replace(',', '.'), planHeight.replace(',', '.'));\r\n              }\r\n\r\n              function createSections() {\r\n                const checkboxes = document.querySelectorAll('#levels_list input[type=\"checkbox\"]:checked');\r\n                if (checkboxes.length === 0) {\r\n                  showAlert('#{obter_texto(:titulo_alerta)}', '#{obter_texto(:nenhum_selecionado)}');\r\n                  return;\r\n                }\r\n                const levelsToCreate = Array.from(checkboxes).map(cb => {\r\n                  return {\r\n                    id: cb.getAttribute('data-id'),\r\n                    height: parseFloat(cb.closest('tr').querySelector('td:nth-child(6)').textContent.replace('m', '').replace(',', '.'))\r\n                  };\r\n                });\r\n                sketchup.createSections(levelsToCreate);\r\n              }\r\n\r\n              function showAlert(title, message) {\r\n                const dialog = document.createElement('div');\r\n                dialog.className = 'custom-dialog';\r\n                dialog.innerHTML = `\r\n                  <div class=\"custom-dialog-title\">${title}</div>\r\n                  <div class=\"custom-dialog-message\">${message}</div>\r\n                  <div class=\"custom-dialog-buttons\">\r\n                    <button class=\"custom-dialog-button custom-dialog-cancel\" onclick=\"this.parentNode.parentNode.remove()\">#{obter_texto(:botao_cancelar)}</button>\r\n                  </div>\r\n                `;\r\n                document.body.appendChild(dialog);\r\n              }\r\n\r\n              function showDeleteConfirmation() {\r\n                const checkboxes = document.querySelectorAll('#levels_list input[type=\"checkbox\"]:checked');\r\n                if (checkboxes.length === 0) {\r\n                  showAlert('#{obter_texto(:titulo_alerta)}', '#{obter_texto(:nenhum_selecionado)}');\r\n                  return;\r\n                }\r\n\r\n                const dialog = document.createElement('div');\r\n                dialog.className = 'custom-dialog';\r\n                dialog.innerHTML = `\r\n                  <div class=\"custom-dialog-title\">#{obter_texto(:confirmar_exclusao_titulo)}</div>\r\n                  <div class=\"custom-dialog-message\">#{obter_texto(:confirmar_exclusao_mensagem)}</div>\r\n                  <div class=\"custom-dialog-buttons\">\r\n                    <button class=\"custom-dialog-button custom-dialog-cancel\" onclick=\"this.parentNode.parentNode.remove()\">#{obter_texto(:botao_cancelar)}</button>\r\n                    <button class=\"custom-dialog-button custom-dialog-confirm\" onclick=\"confirmDelete()\">#{obter_texto(:botao_confirmar)}</button>\r\n                  </div>\r\n                `;\r\n\r\n                document.body.appendChild(dialog);\r\n\r\n                window.confirmDelete = function() {\r\n                  const levelsToDelete = Array.from(checkboxes).map(cb => cb.getAttribute('data-id'));\r\n                  sketchup.deleteLevels(levelsToDelete);\r\n                  dialog.remove();\r\n                };\r\n              }\r\n\r\n              function levelSelected() {\r\n                const selector = document.getElementById('level_selector');\r\n                if (selector.value) {\r\n                  sketchup.loadLevel(selector.value);\r\n                }\r\n              }\r\n\r\n              function unitChanged() {\r\n                const unitSelector = document.getElementById('unit_selector');\r\n                sketchup.setCurrentUnit(unitSelector.value);\r\n              }\r\n\r\n              function updateUI() {\r\n                sketchup.updateUI();\r\n              }\r\n\r\n              function editCell(cell, levelId, field, isText = false) {\r\n                const currentValue = cell.textContent.replace('m', '').trim();\r\n                const input = document.createElement('input');\r\n                input.type = 'text';\r\n                input.className = 'table-input';\r\n                input.value = currentValue;\r\n\r\n                input.onblur = function() {\r\n                  if (input.value !== currentValue) {\r\n                    if (!isText && !validateNumber(input.value)) {\r\n                      showAlert('#{obter_texto(:titulo_alerta)}', '#{obter_texto(:numero_invalido)}');\r\n                      return;\r\n                    }\r\n                    sketchup.editLevelField(levelId, field, isText ? input.value : input.value.replace(',', '.'));\r\n                  }\r\n                  cell.textContent = isText ? input.value : formatNumber(parseFloat(input.value.replace(',', '.'))) + 'm';\r\n                };\r\n\r\n                input.onkeypress = function(e) {\r\n                  if (e.key === 'Enter') {\r\n                    input.blur();\r\n                  }\r\n                };\r\n\r\n                cell.innerHTML = '';\r\n                cell.appendChild(input);\r\n                input.focus();\r\n\r\n                setTimeout(() => {\r\n                  input.selectionStart = input.selectionEnd = input.value.length;\r\n                }, 0);\r\n              }\r\n\r\n              function loadData() {\r\n                sketchup.loadData();\r\n              }\r\n\r\n              function saveData() {\r\n                sketchup.saveData();\r\n              }\r\n\r\n              function createCeilingSections() {\r\n                const checkboxes = document.querySelectorAll('#levels_list input[type=\"checkbox\"]:checked');\r\n                if (checkboxes.length === 0) {\r\n                  showAlert('#{obter_texto(:titulo_alerta)}', '#{obter_texto(:nenhum_selecionado)}');\r\n                  return;\r\n                }\r\n                const levelsToCreate = Array.from(checkboxes).map(cb => {\r\n                  return {\r\n                    id: cb.getAttribute('data-id'),\r\n                    height: parseFloat(cb.closest('tr').querySelector('td:nth-child(6)').textContent.replace('m', '').replace(',', '.'))\r\n                  };\r\n                });\r\n                sketchup.createCeilingSections(levelsToCreate);\r\n              }\r\n\r\n              function createVerticalSections() {\r\n                sketchup.createVerticalSections();\r\n              }\r\n\r\n              function createExtraCutX() {\r\n                sketchup.createExtraCutX();\r\n              }\r\n\r\n              function createExtraCutY() {\r\n                sketchup.createExtraCutY();\r\n              }\r\n            </script>\r\n          </body>\r\n          </html>\r\n        HTML\r\n\r\n        @dialog.set_html(html)\r\n\r\n        # Callbacks\r\n        @dialog.add_action_callback('addLevel') do |action_context, name, base_z, height, plan_height|\r\n          begin\r\n            @levels_mutex.synchronize do\r\n              if @levels.any? { |l| l[:name].casecmp(name.downcase) == 0 }\r\n                show_alert(obter_texto(:titulo_alerta), obter_texto(:nome_duplicado))\r\n                next\r\n              end\r\n\r\n              if @levels.any? { |l| (l[:base_z] - base_z.to_f).abs < 0.001 }\r\n                show_alert(obter_texto(:titulo_alerta), obter_texto(:nivel_duplicado))\r\n                next\r\n              end\r\n\r\n              add_level(name, base_z.to_f, height.to_f, plan_height.to_f)\r\n            end\r\n          rescue => e\r\n            puts \"Error adding level: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('saveLevel') do |action_context, level_id, name, base_z, height, plan_height|\r\n          begin\r\n            @levels_mutex.synchronize do\r\n              save_level(level_id, name, base_z.to_f, height.to_f, plan_height.to_f)\r\n            end\r\n          rescue => e\r\n            puts \"Error saving level: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('createSections') do |action_context, levels_data|\r\n          begin\r\n            create_sections(levels_data)\r\n          rescue => e\r\n            puts \"Error creating sections: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('createVerticalSections') do |action_context|\r\n          begin\r\n            create_vertical_sections\r\n          rescue => e\r\n            puts \"Error creating vertical sections: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('createExtraCutX') do |action_context|\r\n          begin\r\n            create_extra_cut_x\r\n          rescue => e\r\n            puts \"Error creating extra cut X: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('createExtraCutY') do |action_context|\r\n          begin\r\n            create_extra_cut_y\r\n          rescue => e\r\n            puts \"Error creating extra cut Y: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('deleteLevels') do |action_context, level_ids|\r\n          begin\r\n            @levels_mutex.synchronize do\r\n              delete_levels(level_ids)\r\n            end\r\n          rescue => e\r\n            puts \"Error deleting levels: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('loadLevel') do |action_context, level_id|\r\n          begin\r\n            load_level(level_id.to_i)\r\n          rescue => e\r\n            puts \"Error loading level: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('setCurrentUnit') do |action_context, unit|\r\n          @current_unit = unit\r\n        end\r\n\r\n        @dialog.add_action_callback('updateUI') do\r\n          begin\r\n            update_ui\r\n          rescue => e\r\n            puts \"Error updating UI: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('editLevelField') do |action_context, level_id, field, value|\r\n          begin\r\n            @levels_mutex.synchronize do\r\n              edit_level_field(level_id, field, value)\r\n            end\r\n          rescue => e\r\n            puts \"Error editing field: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('setCurrentTheme') do |action_context, theme|\r\n          @current_theme = theme\r\n          Sketchup.write_default(\"level_manager\", \"theme\", theme)\r\n        end\r\n\r\n        @dialog.add_action_callback('loadData') do |action_context|\r\n          begin\r\n            load_data_from_file\r\n          rescue => e\r\n            puts \"Error loading data: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('saveData') do |action_context|\r\n          begin\r\n            save_data_to_file\r\n          rescue => e\r\n            puts \"Error saving data: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('createCeilingSections') do |action_context, levels_data|\r\n          begin\r\n            create_ceiling_sections(levels_data)\r\n          rescue => e\r\n            puts \"Error creating ceiling sections: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('changeLanguage') do |action_context, lang|\r\n          @current_language = LANG_MAP[lang] || 'en-US'\r\n          Sketchup.write_default(\"level_manager\", \"language\", @current_language)\r\n          criar_interface_niveis\r\n        end\r\n\r\n        # Configuracao inicial\r\n        @dialog.execute_script(\"document.getElementById('language_selector').value = '#{short_lang}';\")\r\n        @dialog.execute_script(\"document.getElementById('unit_selector').value = '#{@current_unit}';\")\r\n        @dialog.execute_script(\"document.body.className = '#{@current_theme}';\")\r\n\r\n        @dialog.show\r\n      rescue => e\r\n        puts \"Error creating interface: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n        UI.messagebox(\"#{obter_texto(:erro)}: #{e.message}\")\r\n      end\r\n    end\r\n\r\n    # Metodos auxiliares\r\n    def self.show_alert(title, message)\r\n      js = <<-JS\r\n        showAlert(#{title.to_json}, #{message.to_json});\r\n      JS\r\n      @dialog.execute_script(js)\r\n    rescue\r\n      UI.messagebox(\"#{title}: #{message}\")\r\n    end\r\n\r\n    def self.add_level(name, base_z, height, plan_height)\r\n      model = Sketchup.active_model\r\n      return unless model.valid?\r\n\r\n      model.start_operation(\"#{obter_texto(:botao_criar)} #{name}\", true)\r\n\r\n      level = {\r\n        id: Time.now.to_i,\r\n        name: name,\r\n        base_z: base_z,\r\n        height: height,\r\n        plan_height: plan_height,\r\n        created_at: Time.now\r\n      }\r\n\r\n      @levels << level\r\n      @levels.sort_by! { |l| l[:base_z] }\r\n\r\n      model.commit_operation\r\n\r\n      update_ui\r\n    end\r\n\r\n    def self.save_level(level_id, name, base_z, height, plan_height)\r\n      model = Sketchup.active_model\r\n      return unless model.valid?\r\n\r\n      model.start_operation(\"#{obter_texto(:botao_salvar)} #{name}\", true)\r\n\r\n      level = @levels.find { |l| l[:id].to_s == level_id }\r\n      return unless level\r\n\r\n      if name != level[:name] && @levels.any? { |l| l[:name].casecmp(name.downcase) == 0 }\r\n        show_alert(obter_texto(:titulo_alerta), obter_texto(:nome_duplicado))\r\n        return\r\n      end\r\n\r\n      level[:name] = name unless name.empty?\r\n      level[:base_z] = base_z\r\n      level[:height] = height\r\n      level[:plan_height] = plan_height\r\n\r\n      @levels.sort_by! { |l| l[:base_z] }\r\n\r\n      model.commit_operation\r\n\r\n      update_ui\r\n    end\r\n\r\n    def self.edit_level_field(level_id, field, value)\r\n      model = Sketchup.active_model\r\n      return unless model.valid?\r\n\r\n      model.start_operation(\"#{obter_texto(:editar_pavimento)}\", true)\r\n\r\n      level = @levels.find { |l| l[:id].to_s == level_id }\r\n      return unless level\r\n\r\n      case field\r\n      when 'name'\r\n        level[:name] = value.to_s\r\n      when 'base_z'\r\n        level[:base_z] = value.to_s.gsub(',', '.').to_f\r\n        @levels.sort_by! { |l| l[:base_z] }\r\n      when 'height'\r\n        level[:height] = value.to_s.gsub(',', '.').to_f\r\n      when 'plan_height'\r\n        level[:plan_height] = value.to_s.gsub(',', '.').to_f\r\n      end\r\n\r\n      model.commit_operation\r\n\r\n      update_ui\r\n    end\r\n\r\n    def self.create_sections(levels_data)\r\n      model = Sketchup.active_model\r\n      return unless model.valid?\r\n\r\n      model.start_operation(obter_texto(:secoes_planta), true)\r\n\r\n      layers = model.layers\r\n      section_layer = layers.add(obter_texto(:secoes_planta)) unless layers[obter_texto(:secoes_planta)]\r\n      section_layer ||= layers[obter_texto(:secoes_planta)]\r\n\r\n      model.entities.grep(Sketchup::SectionPlane) do |e|\r\n        e.erase! if e.layer == section_layer\r\n      end\r\n\r\n      created = 0\r\n      levels_data.each do |level_data|\r\n        level = @levels.find { |l| l[:id].to_s == level_data['id'] }\r\n        next unless level\r\n\r\n        begin\r\n          z_position = level[:base_z] + level[:plan_height]\r\n\r\n          z_position_in_inches = case @current_unit\r\n            when 'metros' then z_position.m\r\n            when 'centimetros' then (z_position * 100).cm\r\n            when 'milimetros' then (z_position * 1000).mm\r\n            when 'polegadas' then z_position.inch\r\n            when 'jardas' then z_position.yd\r\n            when 'pes' then z_position.ft\r\n            else z_position.m\r\n          end\r\n\r\n          plane = [0, 0, -1, z_position_in_inches]\r\n          section = model.entities.add_section_plane(plane)\r\n          section.name = \"#{level[:name]} - #{obter_texto(:secoes_planta)}\"\r\n          section.layer = section_layer\r\n          section.visible = true\r\n\r\n          if section.respond_to?(:cutting_plane_visible=)\r\n            section.cutting_plane_visible = true\r\n          end\r\n\r\n          created += 1\r\n        rescue => e\r\n          puts \"Error creating section for level #{level[:name]}: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n          show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n        end\r\n      end\r\n\r\n      model.commit_operation\r\n    end\r\n\r\n    def self.create_ceiling_sections(levels_data)\r\n      model = Sketchup.active_model\r\n      return unless model.valid?\r\n\r\n      model.start_operation(obter_texto(:secoes_forro), true)\r\n\r\n      layers = model.layers\r\n      section_layer = layers.add(obter_texto(:secoes_forro)) unless layers[obter_texto(:secoes_forro)]\r\n      section_layer ||= layers[obter_texto(:secoes_forro)]\r\n\r\n      model.entities.grep(Sketchup::SectionPlane) do |e|\r\n        e.erase! if e.layer == section_layer\r\n      end\r\n\r\n      created = 0\r\n      levels_data.each do |level_data|\r\n        level = @levels.find { |l| l[:id].to_s == level_data['id'] }\r\n        next unless level\r\n\r\n        begin\r\n          z_position = level[:base_z] + level[:plan_height]\r\n\r\n          z_position_in_inches = case @current_unit\r\n            when 'metros' then z_position.m\r\n            when 'centimetros' then (z_position * 100).cm\r\n            when 'milimetros' then (z_position * 1000).mm\r\n            when 'polegadas' then z_position.inch\r\n            when 'jardas' then z_position.yd\r\n            when 'pes' then z_position.ft\r\n            else z_position.m\r\n          end\r\n\r\n          plane = [0, 0, 1, -z_position_in_inches]\r\n          section = model.entities.add_section_plane(plane)\r\n          section.name = \"#{level[:name]} - #{obter_texto(:secoes_forro)}\"\r\n          section.layer = section_layer\r\n          section.visible = true\r\n\r\n          if section.respond_to?(:cutting_plane_visible=)\r\n            section.cutting_plane_visible = true\r\n          end\r\n\r\n          created += 1\r\n        rescue => e\r\n          puts \"Error creating ceiling section for level #{level[:name]}: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n          show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n        end\r\n      end\r\n\r\n      model.commit_operation\r\n    end\r\n\r\n   def self.create_vertical_sections\r\n    model = Sketchup.active_model\r\n    return unless model.valid?\r\n\r\n    model.start_operation(obter_texto(:secoes_corte), true)\r\n\r\n    # Abordagem HIBRIDA: primeiro tenta o metodo rapido, depois fallback para metodo completo\r\n    bounding_box = Geom::BoundingBox.new\r\n\r\n    # 1. Tenta o metodo rapido primeiro (funciona na maioria dos casos)\r\n    quick_bb = model.bounds\r\n    unless quick_bb.empty?\r\n      bounding_box.add(quick_bb)\r\n    else\r\n      # 2. Fallback: metodo manual otimizado para XRefs\r\n      model.entities.each do |entity|\r\n        next unless entity.visible?\r\n\r\n        if entity.is_a?(Sketchup::Face)\r\n          entity.vertices.each { |v| bounding_box.add(v.position) }\r\n        elsif entity.is_a?(Sketchup::Group) && entity.visible?\r\n          entity.bounds.each { |point| bounding_box.add(point.transform(entity.transformation)) }\r\n        elsif entity.is_a?(Sketchup::ComponentInstance) && entity.visible?\r\n          # Para componentes e XRefs, usa a bounding box transformada\r\n          entity.bounds.each { |point| bounding_box.add(point.transform(entity.transformation)) }\r\n        end\r\n      end\r\n    end\r\n\r\n    if bounding_box.empty?\r\n      UI.messagebox(obter_texto(:sem_geometria))\r\n      model.abort_operation\r\n      return\r\n    end\r\n\r\n    min_point = bounding_box.min\r\n    max_point = bounding_box.max\r\n\r\n    # Calcula o centro REAL da geometria\r\n    center_x = (min_point.x + max_point.x) / 2.0\r\n    center_y = (min_point.y + max_point.y) / 2.0\r\n\r\n    # Offset a partir do centro (em metros)\r\n    offset = @section_offset || 1.0.m\r\n\r\n    layers = model.layers\r\n    section_layer = layers.add(obter_texto(:secoes_corte)) unless layers[obter_texto(:secoes_corte)]\r\n    section_layer ||= layers[obter_texto(:secoes_corte)]\r\n\r\n    # Remove secoes existentes apenas desta camada\r\n    model.entities.grep(Sketchup::SectionPlane) do |e|\r\n      e.erase! if e.layer == section_layer\r\n    end\r\n\r\n    # Cortes posicionados com offset A PARTIR DO CENTRO\r\n    # Secoes no eixo Y (frente/tras) - offset a partir do centro Y\r\n    create_section_plane([0, 1, 0, -(center_y - offset)], \"#{obter_texto(:secao)} #{obter_texto(:secao_frente)}\", section_layer)\r\n    create_section_plane([0, -1, 0, center_y + offset], \"#{obter_texto(:secao)} #{obter_texto(:secao_tras)}\", section_layer)\r\n\r\n    # Secoes no eixo X (direita/esquerda) - offset a partir do centro X\r\n    create_section_plane([1, 0, 0, -(center_x - offset)], \"#{obter_texto(:secao)} #{obter_texto(:secao_direita)}\", section_layer)\r\n    create_section_plane([-1, 0, 0, center_x + offset], \"#{obter_texto(:secao)} #{obter_texto(:secao_esquerda)}\", section_layer)\r\n\r\n    model.commit_operation\r\n   end\r\n\r\n   def self.create_extra_cut_x\r\n    model = Sketchup.active_model\r\n    return unless model.valid?\r\n\r\n    model.start_operation(obter_texto(:corte_extra_x), true)\r\n\r\n    # Metodo otimizado para cortes extras\r\n    bounding_box = Geom::BoundingBox.new\r\n    quick_bb = model.bounds\r\n\r\n    unless quick_bb.empty?\r\n      bounding_box.add(quick_bb)\r\n    else\r\n      # Fallback manual\r\n      model.entities.grep(Sketchup::ComponentInstance) do |instance|\r\n        next unless instance.visible?\r\n        instance.bounds.each { |point| bounding_box.add(point.transform(instance.transformation)) }\r\n      end\r\n    end\r\n\r\n    if bounding_box.empty?\r\n      UI.messagebox(obter_texto(:criar_secoes_primeiro))\r\n      model.abort_operation\r\n      return\r\n    end\r\n\r\n    center_x = (bounding_box.min.x + bounding_box.max.x) / 2.0\r\n\r\n    layers = model.layers\r\n    section_layer = layers[obter_texto(:secoes_corte)] || layers.add(obter_texto(:secoes_corte))\r\n\r\n    # Cria o corte extra exatamente no centro do eixo X\r\n    create_section_plane([0, 1, 0, -center_x], \"#{obter_texto(:secao)} #{obter_texto(:corte_extra_x)}\", section_layer)\r\n\r\n    model.commit_operation\r\n   end\r\n\r\n   def self.create_extra_cut_y\r\n    model = Sketchup.active_model\r\n    return unless model.valid?\r\n\r\n    model.start_operation(obter_texto(:corte_extra_y), true)\r\n\r\n    # Metodo otimizado para cortes extras\r\n    bounding_box = Geom::BoundingBox.new\r\n    quick_bb = model.bounds\r\n\r\n    unless quick_bb.empty?\r\n      bounding_box.add(quick_bb)\r\n    else\r\n      # Fallback manual\r\n      model.entities.grep(Sketchup::ComponentInstance) do |instance|\r\n        next unless instance.visible?\r\n        instance.bounds.each { |point| bounding_box.add(point.transform(instance.transformation)) }\r\n      end\r\n    end\r\n\r\n    if bounding_box.empty?\r\n      UI.messagebox(obter_texto(:criar_secoes_primeiro))\r\n      model.abort_operation\r\n      return\r\n    end\r\n\r\n    center_y = (bounding_box.min.y + bounding_box.max.y) / 2.0\r\n\r\n    layers = model.layers\r\n    section_layer = layers[obter_texto(:secoes_corte)] || layers.add(obter_texto(:secoes_corte))\r\n\r\n    # Cria o corte extra exatamente no centro do eixo Y\r\n    create_section_plane([1, 0, 0, -center_y], \"#{obter_texto(:secao)} #{obter_texto(:corte_extra_y)}\", section_layer)\r\n\r\n    model.commit_operation\r\n   end\r\n\r\n    def self.create_section_plane(plane_equation, name, layer)\r\n      section = Sketchup.active_model.entities.add_section_plane(plane_equation)\r\n      section.name = name\r\n      section.layer = layer\r\n      section.visible = true\r\n      if section.respond_to?(:cutting_plane_visible=)\r\n        section.cutting_plane_visible = true\r\n      end\r\n      section\r\n    end\r\n\r\n    def self.delete_levels(level_ids)\r\n      model = Sketchup.active_model\r\n      return unless model.valid?\r\n\r\n      model.start_operation(obter_texto(:botao_excluir), true)\r\n\r\n      @levels.delete_if { |l| level_ids.include?(l[:id].to_s) }\r\n\r\n      update_ui\r\n      model.commit_operation\r\n    end\r\n\r\n    def self.load_level(level_id)\r\n      level = @levels.find { |l| l[:id] == level_id.to_i }\r\n      return unless level\r\n\r\n      js = <<-JS\r\n        try {\r\n          document.getElementById('level_name').value = #{level[:name].to_json};\r\n          document.getElementById('base_level').value = #{'%.2f' % level[:base_z]}.replace('.', ',');\r\n          document.getElementById('level_height').value = #{'%.2f' % level[:height]}.replace('.', ',');\r\n          document.getElementById('plan_height').value = #{'%.2f' % level[:plan_height]}.replace('.', ',');\r\n        } catch(e) { console.error(e); }\r\n      JS\r\n\r\n      @dialog.execute_script(js)\r\n    rescue => e\r\n      puts \"Error loading level: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n    end\r\n\r\n    def self.update_ui\r\n      js = <<-JS\r\n        try {\r\n          const levelsList = document.getElementById('levels_list');\r\n          const levelSelector = document.getElementById('level_selector');\r\n          const unitSelector = document.getElementById('unit_selector');\r\n\r\n          levelsList.innerHTML = '';\r\n          levelSelector.innerHTML = '<option value=\"\">#{obter_texto(:selecionar_pavimento)}</option>';\r\n\r\n          unitSelector.value = #{@current_unit.to_json};\r\n\r\n          #{@levels.sort_by { |l| l[:base_z] }.map do |level|\r\n            pb_z = level[:base_z] + level[:plan_height]\r\n\r\n            <<-JS\r\n              var option = document.createElement('option');\r\n              option.value = '#{level[:id]}';\r\n              option.text = #{level[:name].to_json};\r\n              levelSelector.appendChild(option);\r\n\r\n              var row = document.createElement('tr');\r\n              row.innerHTML = `\r\n                <td class=\"checkbox-column\"><input type=\"checkbox\" data-id=\"#{level[:id]}\"></td>\r\n                <td class=\"editable-cell\" onclick=\"editCell(this, '#{level[:id]}', 'name', true)\">#{level[:name]}</td>\r\n                <td class=\"editable-cell\" onclick=\"editCell(this, '#{level[:id]}', 'base_z')\">#{'%.2f' % level[:base_z]}m</td>\r\n                <td class=\"editable-cell\" onclick=\"editCell(this, '#{level[:id]}', 'height')\">#{'%.2f' % level[:height]}m</td>\r\n                <td class=\"editable-cell\" onclick=\"editCell(this, '#{level[:id]}', 'plan_height')\">#{'%.2f' % level[:plan_height]}m</td>\r\n                <td>#{'%.2f' % pb_z}m</td>\r\n              `;\r\n              levelsList.appendChild(row);\r\n            JS\r\n          end.join}\r\n        } catch(e) { console.error(e); }\r\n      JS\r\n\r\n      @dialog.execute_script(js)\r\n    rescue => e\r\n      puts \"Error updating UI: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n    end\r\n\r\n    def self.load_data_from_file\r\n      path = UI.openpanel(obter_texto(:carregar_dados), \"\", \"JSON Files|*.json||\")\r\n      return unless path && File.exist?(path)\r\n\r\n      unless File.extname(path).downcase == '.json'\r\n        show_alert(obter_texto(:erro), obter_texto(:arquivo_invalido))\r\n        return\r\n      end\r\n\r\n      model = Sketchup.active_model\r\n      return unless model.valid?\r\n\r\n      model.start_operation(obter_texto(:carregar_dados), true)\r\n\r\n      json_data = File.read(path)\r\n      data = JSON.parse(json_data)\r\n\r\n      @levels = data.map do |level|\r\n        {\r\n          id: level['id'] || Time.now.to_i,\r\n          name: level['name'],\r\n          base_z: level['base_z'].to_f,\r\n          height: level['height'].to_f,\r\n          plan_height: level['plan_height'].to_f,\r\n          created_at: level['created_at'] ? Time.parse(level['created_at']) : Time.now\r\n        }\r\n      end\r\n\r\n      @levels.sort_by! { |l| l[:base_z] }\r\n\r\n      if data.first && data.first['preferences']\r\n        prefs = data.first['preferences']\r\n        @current_unit = prefs['unit'] if prefs['unit']\r\n        @current_theme = prefs['theme'] if prefs['theme']\r\n        @current_language = prefs['language'] if prefs['language']\r\n      end\r\n\r\n      model.commit_operation\r\n      update_ui\r\n    rescue => e\r\n      model.abort_operation if model\r\n      show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n    end\r\n\r\n    def self.save_data_to_file\r\n      return if @levels.empty?\r\n\r\n      path = UI.savepanel(obter_texto(:botao_salvar_dados), \"\", \"niveis_pavimentos.json\", \"JSON Files|*.json||\")\r\n      return unless path\r\n\r\n      path += \".json\" unless path.downcase.end_with?('.json')\r\n\r\n      data = @levels.map do |level|\r\n        {\r\n          id: level[:id],\r\n          name: level[:name],\r\n          base_z: level[:base_z],\r\n          height: level[:height],\r\n          plan_height: level[:plan_height],\r\n          created_at: level[:created_at].to_s\r\n        }\r\n      end\r\n\r\n      data.first[:preferences] = {\r\n        unit: @current_unit,\r\n        theme: @current_theme,\r\n        language: @current_language.to_s\r\n      }\r\n\r\n      File.open(path, 'w') { |f| f.write(JSON.pretty_generate(data)) }\r\n\r\n      show_alert(obter_texto(:dados_salvos), path)\r\n    rescue => e\r\n      show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n    end\r\n\r\n    def self.executar\r\n      criar_interface_niveis\r\n    end\r\n\r\n    unless file_loaded?(__FILE__)\r\n      UI.menu('Plugins').add_item(obter_texto(:titulo)) { executar }\r\n      file_loaded(__FILE__)\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::GerenciadorPavimentos.executar"
    },
    "enabled": false,
    "execute": true,
    "video": "https://youtu.be/LO2alFq6e0Y"
  },
  {
    "id": "posiciona-ou-centraliza-c4s9d",
    "title": {
      "pt": "Posiciona ou Centraliza",
      "en": "Position or Center",
      "es": "Posici√≥n o Centro"
    },
    "author": "Comunidade ScriptUp",
    "version": "1.9",
    "description": {
      "pt": "Posiciona ou centraliza um ou v√°rios grupos/componentes de acordo com refer√™ncia selecionadas no modelo. Use as setas para direita ou para esquerda para rotacionar. Voc√™ tamb√©m pode digitar quantos graus deseja rotacionar por clique.",
      "en": "Positions or centers one or more groups/components according to selected references in the model. Use the right or left arrows to rotate. You can also type how many degrees you want to rotate per click.",
      "es": "Posiciona o centra uno o m√°s grupos/componentes seg√∫n las referencias seleccionadas en el modelo. Usa las flechas derecha o izquierda para rotar. Tambi√©n puedes indicar cu√°ntos grados quieres rotar por clic."
    },
    "keywords": {
      "pt": [
        "centralizar;posicionar"
      ],
      "en": [
        "center; position"
      ],
      "es": [
        "centro; posici√≥n"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module CentralizadorInterativo\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao => \"Selecione um ou mais grupos ou componentes para centralizar.\",\r\n        :modo_centralizar => \"Centralizar\",\r\n        :modo_posicionar => \"Posicionar\",\r\n        :status_texto => \"Modo: %s. Clique em refer√™ncias. CTRL alterna modo. ‚Üê/‚Üí rotaciona. VCB define √¢ngulo.\",\r\n        :op_nome => \"Reposicionar bloco\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao => \"Select one or more groups or components to center.\",\r\n        :modo_centralizar => \"Center\",\r\n        :modo_posicionar => \"Position\",\r\n        :status_texto => \"Mode: %s. Click references. CTRL toggles mode. ‚Üê/‚Üí rotates. VCB sets angle.\",\r\n        :op_nome => \"Reposition block\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao => \"Seleccione uno o m√°s grupos o componentes para centrar.\",\r\n        :modo_centralizar => \"Centrar\",\r\n        :modo_posicionar => \"Posicionar\",\r\n        :status_texto => \"Modo: %s. Clic en referencias. CTRL cambia modo. ‚Üê/‚Üí rota. VCB define √°ngulo.\",\r\n        :op_nome => \"Reposicionar bloque\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    VK_LEFT     = 0x25\r\n    VK_RIGHT    = 0x27\r\n    VK_CONTROL  = 0x11\r\n\r\n    class CentralizadorTool\r\n      def initialize(alvo)\r\n        @alvo = alvo\r\n        @ref1 = nil\r\n        @ref2 = nil\r\n        @tmp_refs = []\r\n        @context = Sketchup.active_model.active_entities\r\n        @hover_preview_inst = nil\r\n        @ref1_ent = nil\r\n        @ref2_ent = nil\r\n        @modo = :centralizar\r\n        @angulo_input = 90.degrees\r\n        atualizar_mensagem_padrao\r\n      end\r\n\r\n      def atualizar_status(msg)\r\n        Sketchup.set_status_text(msg)\r\n      end\r\n\r\n      def atualizar_mensagem_padrao\r\n        modo_str = @modo == :centralizar ? CentralizadorInterativo.obter_texto(:modo_centralizar) : CentralizadorInterativo.obter_texto(:modo_posicionar)\r\n        msg = sprintf(CentralizadorInterativo.obter_texto(:status_texto), modo_str)\r\n        atualizar_status(msg)\r\n      end\r\n\r\n      def resume(view); atualizar_mensagem_padrao; end\r\n      def onResume(view); atualizar_mensagem_padrao; end\r\n      def activate; atualizar_mensagem_padrao; end\r\n\r\n      def onUserText(text, view)\r\n        valor = text.to_f\r\n        @angulo_input = valor.degrees if valor.abs > 0\r\n      end\r\n\r\n      def onKeyDown(key, repeat, flags, view)\r\n        case key\r\n        when VK_CONTROL\r\n          @modo = (@modo == :centralizar ? :posicionar : :centralizar)\r\n          atualizar_mensagem_padrao\r\n          view.invalidate\r\n        when VK_LEFT\r\n          aplicar_rotacao(-@angulo_input)\r\n        when VK_RIGHT\r\n          aplicar_rotacao(@angulo_input)\r\n        end\r\n      end\r\n\r\n      def aplicar_rotacao(angulo)\r\n        centro = bounding_box_global(@alvo).center\r\n        transform = Geom::Transformation.rotation(centro, [0, 0, 1], angulo)\r\n        @alvo.each { |ent| ent.transform!(transform) }\r\n      end\r\n\r\n      def limpar_temporarios\r\n        @tmp_refs.each { |inst| inst.erase! if inst.valid? }\r\n        @tmp_refs.clear\r\n        limpar_preview\r\n      end\r\n\r\n      def onMouseMove(flags, x, y, view)\r\n        ph = view.pick_helper\r\n        ph.do_pick(x, y)\r\n        path = ph.path_at(0)\r\n        ent = path&.reverse&.find { |e| e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance) }\r\n\r\n        if ent && !@alvo.include?(ent) && ent.valid?\r\n          limpar_preview\r\n          transf = path.reduce(Geom::Transformation.new) { |acc, e| acc *= e.transformation if e.respond_to?(:transformation); acc }\r\n          defn = ent.definition\r\n          @hover_preview_inst = @context.add_instance(defn, transf)\r\n          @hover_preview_inst.hidden = true\r\n        else\r\n          limpar_preview\r\n        end\r\n        view.invalidate\r\n      end\r\n\r\n      def draw(view)\r\n        return unless @hover_preview_inst && @hover_preview_inst.valid?\r\n        view.line_width = 3\r\n        view.drawing_color = 'red'\r\n        defn_bounds = @hover_preview_inst.definition.bounds\r\n        transf = @hover_preview_inst.transformation\r\n        corners = (0..7).map { |i| defn_bounds.corner(i).transform(transf) }\r\n        arestas = [[0,1],[1,3],[3,2],[2,0],[4,5],[5,7],[7,6],[6,4],[0,4],[1,5],[2,6],[3,7]]\r\n        linhas = arestas.flat_map { |i,j| [corners[i], corners[j]] }\r\n        view.draw(GL_LINES, *linhas)\r\n      end\r\n\r\n      def limpar_preview\r\n        @hover_preview_inst.erase! if @hover_preview_inst&.valid?\r\n        @hover_preview_inst = nil\r\n      end\r\n\r\n      def onLButtonDown(flags, x, y, view)\r\n        ph = view.pick_helper\r\n        ph.do_pick(x, y)\r\n        path = ph.path_at(0)\r\n        return unless path && !path.empty?\r\n\r\n        ref_ent = path.reverse.find { |e| e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance) }\r\n        return unless ref_ent\r\n        return if @alvo.include?(ref_ent)\r\n\r\n        ref_tmp = criar_instancia_temporaria(ref_ent, path)\r\n        return unless ref_tmp\r\n\r\n        if @modo == :posicionar\r\n          centralizar_entre(ref_tmp, ref_tmp, true)\r\n          atualizar_mensagem_padrao\r\n          return\r\n        end\r\n\r\n        if @ref1 && @ref2\r\n          @ref1 = nil\r\n          @ref2 = nil\r\n        end\r\n\r\n        if @ref1.nil?\r\n          @ref1 = ref_tmp\r\n          @ref1_ent = ref_ent\r\n        elsif @ref2.nil?\r\n          @ref2 = ref_tmp\r\n          @ref2_ent = ref_ent\r\n          mesmas_instancias = @ref1_ent == @ref2_ent && @ref1_ent.transformation == @ref2_ent.transformation\r\n          centralizar_entre(@ref1, @ref2, mesmas_instancias)\r\n          @ref1 = nil\r\n          @ref2 = nil\r\n        end\r\n\r\n        atualizar_mensagem_padrao\r\n        view.invalidate\r\n      end\r\n\r\n      def criar_instancia_temporaria(orig_ent, path)\r\n        transf_global = path.reduce(Geom::Transformation.new) { |acc, ent| acc *= ent.transformation if ent.respond_to?(:transformation); acc }\r\n        defn = orig_ent.definition\r\n        inst = @context.add_instance(defn, transf_global)\r\n        inst.hidden = true\r\n        @tmp_refs << inst\r\n        inst\r\n      end\r\n\r\n      def centralizar_entre(ref1, ref2, mesmas_entidades)\r\n        model = Sketchup.active_model\r\n        model.start_operation(CentralizadorInterativo.obter_texto(:op_nome), true)\r\n\r\n        bounds_ref = bounding_box_global(ref1)\r\n        bounds_bloco = bounding_box_global(@alvo)\r\n        centro_ref = bounds_ref.center\r\n        centro_bloco = bounds_bloco.center\r\n\r\n        deslocamento = if mesmas_entidades\r\n          eixo = detectar_eixo_de_maior_separacao(bounds_bloco, bounds_ref)\r\n          case eixo\r\n          when :x\r\n            dx = centro_bloco.x < centro_ref.x ? bounds_ref.min.x - bounds_bloco.max.x : bounds_ref.max.x - bounds_bloco.min.x\r\n            Geom::Vector3d.new(dx, 0, 0)\r\n          when :y\r\n            dy = centro_bloco.y < centro_ref.y ? bounds_ref.min.y - bounds_bloco.max.y : bounds_ref.max.y - bounds_bloco.min.y\r\n            Geom::Vector3d.new(0, dy, 0)\r\n          when :z\r\n            dz = centro_bloco.z < centro_ref.z ? bounds_ref.min.z - bounds_bloco.max.z : bounds_ref.max.z - bounds_bloco.min.z\r\n            Geom::Vector3d.new(0, 0, dz)\r\n          end\r\n        else\r\n          bb1 = bounding_box_global(ref1)\r\n          bb2 = bounding_box_global(ref2)\r\n          bb_bloco = bounding_box_global(@alvo)\r\n          eixo = detectar_eixo_de_maior_separacao(bb1, bb2)\r\n          min1, max1 = bb1.min.send(eixo), bb1.max.send(eixo)\r\n          min2, max2 = bb2.min.send(eixo), bb2.max.send(eixo)\r\n          min_face = [min1, min2].max\r\n          max_face = [max1, max2].min\r\n          centro_alvo = bb_bloco.center\r\n          meio = (min_face + max_face) / 2.0\r\n          distancia = meio - centro_alvo.send(eixo)\r\n          case eixo\r\n          when :x then Geom::Vector3d.new(distancia, 0, 0)\r\n          when :y then Geom::Vector3d.new(0, distancia, 0)\r\n          when :z then Geom::Vector3d.new(0, 0, distancia)\r\n          end\r\n        end\r\n\r\n        @alvo.each { |ent| ent.transform!(Geom::Transformation.translation(deslocamento)) }\r\n        limpar_temporarios\r\n        model.commit_operation\r\n      end\r\n\r\n      def detectar_eixo_de_maior_separacao(bounds1, bounds2)\r\n        dx = [bounds1.min.x - bounds2.max.x, bounds2.min.x - bounds1.max.x].max\r\n        dy = [bounds1.min.y - bounds2.max.y, bounds2.min.y - bounds1.max.y].max\r\n        dz = [bounds1.min.z - bounds2.max.z, bounds2.min.z - bounds1.max.z].max\r\n        return :x if dx >= dy && dx >= dz\r\n        return :y if dy >= dz\r\n        :z\r\n      end\r\n\r\n      def bounding_box_global(entidades)\r\n        bb = Geom::BoundingBox.new\r\n        if entidades.respond_to?(:each)\r\n          entidades.each do |e|\r\n            (0..7).each { |i| bb.add(e.definition.bounds.corner(i).transform(e.transformation)) }\r\n          end\r\n        else\r\n          (0..7).each { |i| bb.add(entidades.definition.bounds.corner(i).transform(entidades.transformation)) }\r\n        end\r\n        bb\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      if selection.empty? || !selection.all? { |e| e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance) }\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n\r\n      alvo = selection.to_a\r\n      model.select_tool(CentralizadorTool.new(alvo))\r\n    end\r\n  end\r\nend\r\n\r\nScriptUpComunidade::CentralizadorInterativo.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "puxar-linhas-c4u1m",
    "title": {
      "pt": "Puxar Linhas",
      "en": "Pull Lines",
      "es": "L√≠neas de tracci√≥n"
    },
    "author": "Henrique Barsa",
    "version": "1.0",
    "description": {
      "pt": "Voc√™ consegue dar Push/Pull em linhas. Selecione uma ou mais linhas, rode o Script e puxe ela para onde quiser. Use o Shift para travar no eixo.",
      "en": "You can push/pull lines. Select one or more lines, run the script, and drag it to where you want. Use Shift to lock it to the axis.",
      "es": "Puedes mover o arrastrar l√≠neas. Selecciona una o m√°s l√≠neas, ejecuta el script y arr√°stralo a donde quieras. Usa May√∫s para bloquearlo en el eje."
    },
    "keywords": {
      "pt": [
        "linhas",
        "extrus√£o",
        "puxar"
      ],
      "en": [
        "lines",
        "extrusion",
        "to pull"
      ],
      "es": [
        "pauta",
        "extrusi√≥n",
        "tirar"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module ExtrusaoDeArestas\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao => \"Selecione ao menos uma aresta antes de executar.\",\r\n        :status_p1    => \"Extrude: clique no primeiro ponto\",\r\n        :status_p2    => \"Extrude: clique no segundo ponto ou digite dist√¢ncia\",\r\n        :erro_vcb     => \"N√£o foi poss√≠vel converter ‚Äú%s‚Äù em comprimento.\",\r\n        :op_nome      => \"Extrudar Arestas\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao => \"Select at least one edge before running.\",\r\n        :status_p1    => \"Extrude: click on the first point\",\r\n        :status_p2    => \"Extrude: click on the second point or type distance\",\r\n        :erro_vcb     => \"Could not convert ‚Äú%s‚Äù into length.\",\r\n        :op_nome      => \"Extrude Edges\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao => \"Seleccione al menos una arista antes de ejecutar.\",\r\n        :status_p1    => \"Extruir: haga clic en el primer punto\",\r\n        :status_p2    => \"Extruir: haga clic en el segundo punto o escriba la distancia\",\r\n        :erro_vcb     => \"No se pudo convertir ‚Äú%s‚Äù en longitud.\",\r\n        :op_nome      => \"Extruir Aristas\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    class ExtrudeLineTool\r\n      CURSOR_MOVE ||= 641\r\n\r\n      def initialize\r\n        @ip1 = Sketchup::InputPoint.new\r\n        @ip2 = Sketchup::InputPoint.new\r\n        @state = 0\r\n        @dragging = false\r\n        @xdown = @ydown = 0\r\n      end\r\n\r\n      def activate\r\n        @edges = Sketchup.active_model.selection.grep(Sketchup::Edge)\r\n        if @edges.empty?\r\n          UI.messagebox(ExtrusaoDeArestas.obter_texto(:erro_selecao))\r\n          Skup.send_action(\"selectSelectionTool:\")\r\n          return\r\n        end\r\n        Sketchup.set_status_text(ExtrusaoDeArestas.obter_texto(:status_p1), SB_PROMPT)\r\n      end\r\n\r\n      def deactivate(view)\r\n        view.invalidate if @state != 0\r\n      end\r\n\r\n      def onSetCursor\r\n        UI.set_cursor(CURSOR_MOVE)\r\n        true\r\n      end\r\n\r\n      def onMouseMove(flags, x, y, view)\r\n        if @state.zero?\r\n          @ip1.pick(view, x, y)\r\n          view.invalidate if @ip1.valid?\r\n          view.tooltip = @ip1.tooltip\r\n        else\r\n          @ip2.pick(view, x, y, @ip1)\r\n          view.invalidate\r\n          Sketchup.set_status_text(@ip1.position.distance(@ip2.position).to_s, SB_VCB_VALUE) if @ip2.valid?\r\n          @dragging = true if (x - @xdown).abs > 5 || (y - @ydown).abs > 5\r\n        end\r\n      end\r\n\r\n      def onLButtonDown(flags, x, y, view)\r\n        if @state.zero?\r\n          @ip1.pick(view, x, y)\r\n          if @ip1.valid?\r\n            @state = 1\r\n            Sketchup.set_status_text(ExtrusaoDeArestas.obter_texto(:status_p2), SB_PROMPT)\r\n            @xdown, @ydown = x, y\r\n          end\r\n        else\r\n          finish_extrude if @ip2.valid?\r\n        end\r\n        view.lock_inference\r\n      end\r\n\r\n      def onLButtonUp(flags, x, y, view)\r\n        finish_extrude if @dragging && @ip2.valid?\r\n      end\r\n\r\n      def onUserText(text, view)\r\n        return unless @state == 1 && @ip2.valid?\r\n        length = text.to_l rescue nil\r\n        unless length\r\n          UI.beep\r\n          UI.messagebox(ExtrusaoDeArestas.obter_texto(:erro_vcb) % text)\r\n          return\r\n        end\r\n        vec = @ip2.position - @ip1.position\r\n        vec.length = length\r\n        finish_extrude(@ip1.position, @ip1.position.offset(vec))\r\n      end\r\n\r\n      def draw(view)\r\n        if @ip1.valid?\r\n          @ip1.draw(view)\r\n          view.draw_points(@ip1.position, 8, 1, \"red\")\r\n        end\r\n        if @ip2.valid?\r\n          @ip2.draw(view)\r\n          view.set_color_from_line(@ip1, @ip2) rescue view.drawing_color = \"black\"\r\n          view.draw_line(@ip1.position, @ip2.position)\r\n          view.draw_points(@ip2.position, 8, 1, \"red\")\r\n\r\n          vector = @ip1.position.vector_to(@ip2.position)\r\n          preview = Sketchup::Color.new(200,200,200,128)\r\n          view.drawing_color = preview\r\n          @edges.each do |edge|\r\n            a = edge.start.position\r\n            b = edge.end.position\r\n            a2 = a.offset(vector)\r\n            b2 = b.offset(vector)\r\n            view.draw(GL_QUADS, [a, b, b2, a2])\r\n            view.draw(GL_LINE_LOOP, [a, b, b2, a2])\r\n          end\r\n          view.drawing_color = \"black\"\r\n        end\r\n      end\r\n\r\n      private\r\n\r\n      def finish_extrude(pt1=@ip1.position, pt2=@ip2.position)\r\n        create_geometry(pt1, pt2)\r\n        Sketchup.send_action(\"selectSelectionTool:\")\r\n      end\r\n\r\n      def create_geometry(p1, p2)\r\n        model = Sketchup.active_model\r\n        model.start_operation(ExtrusaoDeArestas.obter_texto(:op_nome), true)\r\n        vector = p1.vector_to(p2)\r\n        group = model.active_entities.add_group\r\n        ents = group.entities\r\n\r\n        @edges.each do |edge|\r\n          a, b = edge.start.position, edge.end.position\r\n          ents.add_line(a, b)\r\n          ents.add_line(a.offset(vector), b.offset(vector))\r\n          ents.add_line(a, a.offset(vector))\r\n          ents.add_line(b, b.offset(vector))\r\n          ents.add_face(a, b, b.offset(vector), a.offset(vector)) rescue nil\r\n        end\r\n\r\n        group.entities.grep(Sketchup::Face).each { |f| f.reverse! if f.normal.z < 0 }\r\n        model.commit_operation\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      Sketchup.active_model.select_tool(ExtrudeLineTool.new)\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::ExtrusaoDeArestas.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "reexibe-arestas-selecionadas-c4vwn",
    "title": {
      "pt": "Reexibe Arestas Selecionadas",
      "en": "Re-display Selected Edges",
      "es": "Volver a mostrar los bordes seleccionados"
    },
    "author": "F√°bio Coutinho",
    "version": "1.1",
    "description": {
      "pt": "Reexibe as arestas selecionadas independente se elas est√£o suavizadas ou ocultas.",
      "en": "Redisplays the selected edges regardless of whether they are smoothed or hidden.",
      "es": "Vuelve a mostrar los bordes seleccionados independientemente de si est√°n suavizados u ocultos."
    },
    "keywords": {
      "pt": [
        "reexibir arestas"
      ],
      "en": [
        "redisplay edges"
      ],
      "es": [
        "volver a mostrar los bordes"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module RemoverSuavizacao\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao => \"Nenhuma entidade selecionada.\",\r\n        :op_nome      => \"Remover Suaviza√ß√£o\",\r\n        :concluido    => \"Processo conclu√≠do: suaviza√ß√£o removida e arestas reexibidas.\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao => \"No entities selected.\",\r\n        :op_nome      => \"Remove Smoothing\",\r\n        :concluido    => \"Process completed: smoothing removed and edges unhidden.\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao => \"Ninguna entidad seleccionada.\",\r\n        :op_nome      => \"Eliminar Suavizado\",\r\n        :concluido    => \"Proceso completado: suavizado eliminado y aristas mostradas.\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      if selection.empty?\r\n        puts obter_texto(:erro_selecao)\r\n      else\r\n        model.start_operation(obter_texto(:op_nome), true)\r\n\r\n        # Trata arestas diretamente na sele√ß√£o\r\n        selection.grep(Sketchup::Edge).each do |edge|\r\n          processar_aresta(edge)\r\n        end\r\n\r\n        # Itera pelas faces para garantir que arestas conectadas sejam tratadas\r\n        model.active_entities.grep(Sketchup::Face).each do |face|\r\n          face.edges.each do |edge|\r\n            if selection.include?(edge)\r\n              processar_aresta(edge)\r\n            end\r\n          end\r\n        end\r\n\r\n        model.commit_operation\r\n        puts obter_texto(:concluido)\r\n      end\r\n    end\r\n\r\n    def self.processar_aresta(edge)\r\n      # Reexibe se estiver oculta\r\n      edge.hidden = false\r\n      \r\n      # Remove soft e smooth\r\n      edge.soft = false\r\n      edge.smooth = false\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::RemoverSuavizacao.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "reexibir-tudo-c4xle",
    "title": {
      "pt": "Reexibir tudo",
      "en": "Show all again",
      "es": "Mostrar todo de nuevo"
    },
    "author": "F√°bio Coutinho",
    "version": "1.0",
    "description": {
      "pt": "Script para reexibir tudo, na sele√ß√£o ou no modelo. Grupos, componentes, faces e arestas. Aninhados ou n√£o.",
      "en": "Script to redisplay everything, in the selection or in the model. Groups, components, faces, and edges. Nested or not.",
      "es": "Script para volver a mostrar todo, en la selecci√≥n o en el modelo. Grupos, componentes, caras y aristas. Anidados o no."
    },
    "keywords": {
      "pt": [
        "reexibir",
        "unhide"
      ],
      "en": [
        "re-air",
        "unhide"
      ],
      "es": [
        "re-emisi√≥n",
        "mostrar"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module DesocultarElementos\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :pergunta_modo   => \"Deseja desocultar apenas os elementos selecionados? (Sim para Sele√ß√£o, N√£o para Todo o Modelo)\",\r\n        :pergunta_groups => \"Deseja desocultar Grupos e Componentes?\",\r\n        :pergunta_faces  => \"Deseja desocultar Linhas e Faces?\",\r\n        :op_nome         => \"Desocultar Elementos\",\r\n        :sucesso         => \"Todos os elementos selecionados foram desocultados!\"\r\n      },\r\n      'en-US' => {\r\n        :pergunta_modo   => \"Do you want to unhide only the selected elements? (Yes for Selection, No for Entire Model)\",\r\n        :pergunta_groups => \"Do you want to unhide Groups and Components?\",\r\n        :pergunta_faces  => \"Do you want to unhide Edges and Faces?\",\r\n        :op_nome         => \"Unhide Elements\",\r\n        :sucesso         => \"All selected elements have been unhidden!\"\r\n      },\r\n      'es' => {\r\n        :pergunta_modo   => \"¬øDesea desocultar solo los elementos seleccionados? (S√≠ para Selecci√≥n, No para todo el Modelo)\",\r\n        :pergunta_groups => \"¬øDesea desocultar Grupos y Componentes?\",\r\n        :pergunta_faces  => \"¬øDesea desocultar L√≠neas y Caras?\",\r\n        :op_nome         => \"Desocultar Elementos\",\r\n        :sucesso         => \"¬°Todos los elementos seleccionados han sido desocultados!\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.ask_user(question)\r\n      result = UI.messagebox(question, MB_YESNO)\r\n      result == IDYES\r\n    end\r\n\r\n    def self.unhide_groups_and_components(entities)\r\n      entities.each do |entity|\r\n        if entity.is_a?(Sketchup::Group) || entity.is_a?(Sketchup::ComponentInstance)\r\n          entity.hidden = false\r\n          unhide_groups_and_components(entity.definition.entities)\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.unhide_faces_and_edges(entities)\r\n      entities.each do |entity|\r\n        if entity.is_a?(Sketchup::Edge) || entity.is_a?(Sketchup::Face)\r\n          entity.hidden = false\r\n        elsif entity.is_a?(Sketchup::Group) || entity.is_a?(Sketchup::ComponentInstance)\r\n          # Percorre dentro de grupos/componentes j√° desocultados\r\n          unhide_faces_and_edges(entity.definition.entities)\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      # Perguntar se deseja agir na sele√ß√£o ou no modelo inteiro\r\n      use_selection = ask_user(obter_texto(:pergunta_modo))\r\n\r\n      entities = use_selection && !selection.empty? ? selection : model.active_entities\r\n\r\n      # Perguntar se quer desocultar grupos e componentes\r\n      unhide_groups = ask_user(obter_texto(:pergunta_groups))\r\n      \r\n      # Perguntar se quer desocultar arestas e faces\r\n      unhide_faces = ask_user(obter_texto(:pergunta_faces))\r\n\r\n      # Processar os elementos\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n\r\n      # Primeiro, desocultar grupos e componentes, se permitido\r\n      unhide_groups_and_components(entities) if unhide_groups\r\n\r\n      # Depois, garantir que arestas e faces sejam desocultadas\r\n      unhide_faces_and_edges(entities) if unhide_faces\r\n\r\n      model.commit_operation\r\n\r\n      UI.messagebox(obter_texto(:sucesso))\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::DesocultarElementos.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "remover-elementos-ocultos-c4zgs",
    "title": {
      "pt": "Remover Elementos Ocultos",
      "en": "Remove Hidden Elements",
      "es": "Eliminar elementos ocultos"
    },
    "author": "F√°bio Coutinho",
    "version": "1.0",
    "description": {
      "pt": "Apaga todos os grupos ou componentes ocultos em qualquer n√≠vel de aninhamento, estejam eles dentro de grupos ou componentes boqueados ou n√£o.",
      "en": "Deletes all hidden groups or components at any nesting level, whether they are inside locked groups or components or not.",
      "es": "Elimina todos los grupos o componentes ocultos en cualquier nivel de anidamiento, ya sea que est√©n dentro de grupos o componentes bloqueados o no."
    },
    "keywords": {
      "pt": [
        "remover ocultos",
        "apagar ocultos",
        "limpar ocultos"
      ],
      "en": [
        "remove hidden",
        "delete hidden",
        "clear hidden"
      ],
      "es": [
        "eliminar oculto",
        "eliminar oculto",
        "claro oculto"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module ApagarOcultosRecursivo\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao => \"Por favor, selecione um componente ou grupo para continuar.\",\r\n        :erro_tipo    => \"A sele√ß√£o cont√©m itens que n√£o s√£o componentes ou grupos.\",\r\n        :op_nome      => \"Apagar Componentes Ocultos\",\r\n        :concluido    => \"Limpeza conclu√≠da: componentes ocultos foram removidos.\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao => \"Please select a component or group to continue.\",\r\n        :erro_tipo    => \"The selection contains items that are not components or groups.\",\r\n        :op_nome      => \"Delete Hidden Components\",\r\n        :concluido    => \"Cleanup complete: hidden components have been removed.\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao => \"Por favor, seleccione un componente o grupo para continuar.\",\r\n        :erro_tipo    => \"La selecci√≥n contiene elementos que no son componentes o grupos.\",\r\n        :op_nome      => \"Eliminar Componentes Ocultos\",\r\n        :concluido    => \"Limpieza completada: los componentes ocultos han sido eliminados.\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.delete_hidden_entities_recursively(parent_entity)\r\n      # Obt√©m as entidades da defini√ß√£o (funciona para Grupo e ComponentInstance)\r\n      entities = parent_entity.is_a?(Sketchup::ComponentInstance) ? parent_entity.definition.entities : parent_entity.entities\r\n      \r\n      entities.to_a.each do |entity|\r\n        next unless entity.valid?\r\n        # Verifica se a entidade √© um componente ou grupo\r\n        if entity.is_a?(Sketchup::ComponentInstance) || entity.is_a?(Sketchup::Group)\r\n          # Remove o componente se ele estiver oculto\r\n          if entity.hidden?\r\n            entity.erase!\r\n          else\r\n            # Se n√£o estiver oculto, verifica recursivamente\r\n            delete_hidden_entities_recursively(entity)\r\n          end\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      if selection.empty?\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n\r\n      selection.each do |entity|\r\n        if entity.is_a?(Sketchup::ComponentInstance) || entity.is_a?(Sketchup::Group)\r\n          delete_hidden_entities_recursively(entity)\r\n        else\r\n          puts obter_texto(:erro_tipo)\r\n        end\r\n      end\r\n\r\n      model.commit_operation\r\n      puts obter_texto(:concluido)\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::ApagarOcultosRecursivo.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "retirar-tarjas-pretas-v-ray-c51zz",
    "title": {
      "pt": "Retirar Tarjas Pretas V-Ray",
      "en": "Remove Black Bars from V-Ray",
      "es": "Eliminar barras negras de V-Ray"
    },
    "author": "Henrique Barsa",
    "version": "1.0",
    "description": {
      "pt": "Retirar as tarjas pretas (safe frame) da visualiza√ß√£o.",
      "en": "Remove the black bars (safe frame) from the display.",
      "es": "Retire las barras negras (marco seguro) de la pantalla."
    },
    "keywords": {
      "pt": [
        "vray"
      ],
      "en": [
        "v-ray"
      ],
      "es": [
        "v-ray"
      ]
    },
    "code": {
      "pt": "# Obter o modelo ativo e a c√¢mera ativa\r\nmodel = Sketchup.active_model\r\ncamera = model.active_view.camera\r\n\r\n# Definir o valor L/A (aspect_ratio) para 0\r\ncamera.aspect_ratio = 0\r\n\r\n# Atualizar a vista para aplicar as altera√ß√µes da c√¢mera\r\nmodel.active_view.camera = camera\r\nmodel.active_view.refresh\r\n\r\n"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "rotacionar-visao-c53px",
    "title": {
      "pt": "Rotacionar Vis√£o",
      "en": "Rotate View",
      "es": "Girar vista"
    },
    "author": "F√°bio Coutinho",
    "version": "1.3",
    "description": {
      "pt": "Permite rotacionar a vis√£o usando as setas do teclado ou digitando um √¢ngulo.",
      "en": "Allows you to rotate the view using the keyboard arrows or by typing an angle.",
      "es": "Le permite rotar la vista usando las flechas del teclado o escribiendo un √°ngulo."
    },
    "keywords": {
      "pt": [
        "rotacionar vis√£o",
        "arfagem",
        "pitch",
        "rolagem"
      ],
      "en": [
        "rotate view",
        "panting",
        "pitch",
        "scrolling"
      ],
      "es": [
        "rotar vista",
        "jadeo",
        "paso",
        "desplazamiento"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module FerramentaGirarVista\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :desativada      => \"Ferramenta de rota√ß√£o desativada.\",\r\n        :instrucoes      => \"‚Üê ‚Üí ‚Üë ‚Üì para girar. Ctrl alterna entre 1¬∞ e 90¬∞. Modo atual: %{modo}. Digite √¢ngulo + Enter. ESC para sair.\",\r\n        :modo_1          => \"1¬∞\",\r\n        :modo_90         => \"90¬∞\"\r\n      },\r\n      'en-US' => {\r\n        :desativada      => \"Rotation tool deactivated.\",\r\n        :instrucoes      => \"‚Üê ‚Üí ‚Üë ‚Üì to rotate. Ctrl toggles 1¬∞/90¬∞. Current mode: %{modo}. Type angle + Enter. ESC to exit.\",\r\n        :modo_1          => \"1¬∞\",\r\n        :modo_90         => \"90¬∞\"\r\n      },\r\n      'es' => {\r\n        :desativada      => \"Herramienta de rotaci√≥n desactivada.\",\r\n        :instrucoes      => \"‚Üê ‚Üí ‚Üë ‚Üì para girar. Ctrl alterna entre 1¬∞ y 90¬∞. Modo actual: %{modo}. Escriba √°ngulo + Enter. ESC para salir.\",\r\n        :modo_1          => \"1¬∞\",\r\n        :modo_90         => \"90¬∞\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave, variaveis = {})\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      texto  = IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n      \r\n      variaveis.each { |k, v| texto = texto.gsub(\"%{#{k}}\", v.to_s) }\r\n      texto\r\n    end\r\n\r\n    class Tool\r\n      VK_LEFT    = 37 unless defined?(VK_LEFT)\r\n      VK_UP      = 38 unless defined?(VK_UP)\r\n      VK_RIGHT   = 39 unless defined?(VK_RIGHT)\r\n      VK_DOWN    = 40 unless defined?(VK_DOWN)\r\n      VK_ESCAPE  = 27 unless defined?(VK_ESCAPE)\r\n      VK_CONTROL = 17 unless defined?(VK_CONTROL)\r\n\r\n      BASE_ROTATE_SPEED  = 1   unless defined?(BASE_ROTATE_SPEED)\r\n      BOOST_ROTATE_SPEED = 90  unless defined?(BOOST_ROTATE_SPEED)\r\n      TIMER_INTERVAL     = 0.016 unless defined?(TIMER_INTERVAL)\r\n      CURSOR_ID          = 643 unless defined?(CURSOR_ID)\r\n\r\n      def initialize\r\n        @rotate_left = false\r\n        @rotate_right = false\r\n        @rotate_up = false\r\n        @rotate_down = false\r\n        @use_boost = false\r\n        @timer_id = nil\r\n        start_rotation_timer\r\n      end\r\n\r\n      def activate\r\n        update_status_text\r\n      end\r\n\r\n      def deactivate(view)\r\n        stop_rotation_timer\r\n        Sketchup.status_text = FerramentaGirarVista.obter_texto(:desativada)\r\n      end\r\n\r\n      def getCursor\r\n        CURSOR_ID\r\n      end\r\n\r\n      def onKeyDown(key, repeat, flags, view)\r\n        case key\r\n        when VK_LEFT\r\n          if @use_boost\r\n            rotate_view(-BOOST_ROTATE_SPEED, :roll)\r\n          else\r\n            @rotate_left = true\r\n          end\r\n        when VK_RIGHT\r\n          if @use_boost\r\n            rotate_view(+BOOST_ROTATE_SPEED, :roll)\r\n          else\r\n            @rotate_right = true\r\n          end\r\n        when VK_UP\r\n          if @use_boost\r\n            rotate_view(+BOOST_ROTATE_SPEED, :tilt)\r\n          else\r\n            @rotate_up = true\r\n          end\r\n        when VK_DOWN\r\n          if @use_boost\r\n            rotate_view(-BOOST_ROTATE_SPEED, :tilt)\r\n          else\r\n            @rotate_down = true\r\n          end\r\n        when VK_CONTROL\r\n          @use_boost = !@use_boost\r\n          update_status_text\r\n        when VK_ESCAPE\r\n          Sketchup.active_model.tools.pop_tool\r\n        end\r\n      end\r\n\r\n      def onKeyUp(key, repeat, flags, view)\r\n        case key\r\n        when VK_LEFT    then @rotate_left = false\r\n        when VK_RIGHT   then @rotate_right = false\r\n        when VK_UP      then @rotate_up = false\r\n        when VK_DOWN    then @rotate_down = false\r\n        end\r\n      end\r\n\r\n      def onUserText(text, view)\r\n        if text.strip == \"0\"\r\n          reset_view_orientation\r\n        else\r\n          angle = text.to_f\r\n          rotate_view(angle, :roll) if angle != 0\r\n        end\r\n      end\r\n\r\n      def onCancel(reason, view)\r\n        Sketchup.active_model.tools.pop_tool\r\n      end\r\n\r\n      private\r\n\r\n      def update_status_text\r\n        modo_str = @use_boost ? FerramentaGirarVista.obter_texto(:modo_90) : FerramentaGirarVista.obter_texto(:modo_1)\r\n        Sketchup.status_text = FerramentaGirarVista.obter_texto(:instrucoes, { modo: modo_str })\r\n      end\r\n\r\n      def start_rotation_timer\r\n        @timer_id = UI.start_timer(TIMER_INTERVAL, true) {\r\n          next if @use_boost  # no modo 90¬∞, n√£o repetir rota√ß√£o autom√°tica\r\n          speed = BASE_ROTATE_SPEED\r\n          rotate_view(-speed, :roll) if @rotate_left\r\n          rotate_view(+speed, :roll) if @rotate_right\r\n          rotate_view(+speed, :tilt) if @rotate_up\r\n          rotate_view(-speed, :tilt) if @rotate_down\r\n        }\r\n      end\r\n\r\n      def stop_rotation_timer\r\n        UI.stop_timer(@timer_id) if @timer_id\r\n        @timer_id = nil\r\n      end\r\n\r\n      def rotate_view(degrees, mode = :roll)\r\n        return if degrees == 0\r\n        cam = Sketchup.active_model.active_view.camera\r\n        eye = cam.eye\r\n        target = cam.target\r\n        up = cam.up\r\n        direction = target - eye\r\n        radians = degrees.degrees\r\n\r\n        case mode\r\n        when :roll\r\n          new_up = up.transform(Geom::Transformation.rotation(eye, direction, radians))\r\n          return if invalid_camera?(direction, new_up)\r\n          cam.set(eye, target, new_up)\r\n        when :tilt\r\n          axis = direction * up  # eixo lateral\r\n          t = Geom::Transformation.rotation(eye, axis, radians)\r\n          new_target = target.transform(t)\r\n          new_up = up.transform(t)\r\n          new_direction = new_target - eye\r\n          return if invalid_camera?(new_direction, new_up)\r\n          cam.set(eye, new_target, new_up)\r\n        end\r\n      end\r\n\r\n      def invalid_camera?(direction, up)\r\n        dot = direction.normalize.dot(up.normalize).abs\r\n        dot > 0.999\r\n      end\r\n\r\n      def reset_view_orientation\r\n        cam = Sketchup.active_model.active_view.camera\r\n        eye = cam.eye\r\n        target = cam.target\r\n        cam.set(eye, target, Z_AXIS)\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      Sketchup.active_model.tools.push_tool(Tool.new)\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::FerramentaGirarVista.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "selecao-de-elemento-profundo-c55s7",
    "title": {
      "pt": "Sele√ß√£o de Elemento Profundo",
      "en": "Deep Element Selection",
      "es": "Selecci√≥n de elementos profundos"
    },
    "author": "F√°bio Coutinho",
    "version": "1.9",
    "description": {
      "pt": "Ferramenta de sele√ß√£o de grupo/componente ou face em n√≠veis mais profundos de aninhamento de forma direta. Caso esteja com segmentos de arestas selecionados, voc√™ pode envi√°-lo diretamente para a face profunda com dois cliques. Isso permite planejar cortes para faces internas.",
      "en": "This tool allows you to select groups/components or faces directly at deeper nesting levels. If you have edge segments selected, you can send them directly to the deep face with two clicks. This allows you to plan cuts for internal faces.",
      "es": "Esta herramienta permite seleccionar grupos/componentes o caras directamente en niveles de anidamiento m√°s profundos. Si tiene segmentos de arista seleccionados, puede enviarlos directamente a la cara profunda con dos clics. Esto le permite planificar cortes para caras internas."
    },
    "keywords": {
      "pt": [
        "sele√ß√£o de n√≠vel",
        "selecionar subgrupo"
      ],
      "en": [
        "level selection",
        "select subgroup"
      ],
      "es": [
        "selecci√≥n de nivel",
        "seleccionar subgrupo"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module SelecaoHierarquia\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :msg_copiar      => \"Deseja usar o segmento selecionado para copiar?\",\r\n        :modo_gp_comp    => \"Modo: Grupo/Componente\",\r\n        :modo_face_edge  => \"Modo: Face/Aresta\",\r\n        :status_gp_comp  => \"Grupo/Componente\",\r\n        :status_face_ed  => \"Face/Aresta\",\r\n        :prompt_status   => \"Modo atual: %{mode} | Ctrl para alternar modo | Duplo clique ou Enter para entrar no contexto | Esc para voltar ao n√≠vel do modelo\",\r\n        :op_colar        => \"Colar no local (desagrupado)\"\r\n      },\r\n      'en-US' => {\r\n        :msg_copiar      => \"Do you want to use the selected segment to copy?\",\r\n        :modo_gp_comp    => \"Mode: Group/Component\",\r\n        :modo_face_edge  => \"Mode: Face/Edge\",\r\n        :status_gp_comp  => \"Group/Component\",\r\n        :status_face_ed  => \"Face/Edge\",\r\n        :prompt_status   => \"Current mode: %{mode} | Ctrl to toggle mode | Double click or Enter to enter context | Esc to return to model level\",\r\n        :op_colar        => \"Paste in place (exploded)\"\r\n      },\r\n      'es' => {\r\n        :msg_copiar      => \"¬øDesea utilizar el segmento seleccionado para copiar?\",\r\n        :modo_gp_comp    => \"Modo: Grupo/Componente\",\r\n        :modo_face_edge  => \"Modo: Cara/Arista\",\r\n        :status_gp_comp  => \"Grupo/Componente\",\r\n        :status_face_ed  => \"Cara/Arista\",\r\n        :prompt_status   => \"Modo actual: %{mode} | Ctrl para cambiar modo | Doble clic o Enter para entrar en el contexto | Esc para volver al nivel del modelo\",\r\n        :op_colar        => \"Pegar en su lugar (desagrupado)\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave, variaveis = {})\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      texto  = IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n      \r\n      variaveis.each { |k, v| texto = texto.gsub(\"%{#{k}}\", v.to_s) }\r\n      texto\r\n    end\r\n\r\n    class HoverSelectionTool\r\n      VK_RETURN  ||= 13\r\n      VK_CONTROL ||= 17\r\n      VK_ESCAPE  ||= 27\r\n\r\n      def initialize(ctrl_locked: false, post_enter_action: nil, clipboard_group: nil)\r\n        @model = Sketchup.active_model\r\n        @view = @model.active_view\r\n        @selection_mode = ctrl_locked ? :face_edge : :group_component\r\n        @ctrl_locked = ctrl_locked\r\n        @post_enter_action = post_enter_action\r\n        @clipboard_group = clipboard_group\r\n        @selected_entity = nil\r\n        @selected_instance_path = nil\r\n        @last_mouse_x = nil\r\n        @last_mouse_y = nil\r\n      end\r\n\r\n      def activate\r\n        update_status_text\r\n      end\r\n\r\n      def resume(view)\r\n        update_status_text\r\n        view.invalidate\r\n      end\r\n\r\n      def onMouseMove(flags, x, y, view)\r\n        @last_mouse_x = x\r\n        @last_mouse_y = y\r\n        update_selection(x, y, view)\r\n        highlight_entity(view)\r\n        view.invalidate\r\n      end\r\n\r\n      def onKeyDown(key, repeat, flags, view)\r\n        case key\r\n        when VK_CONTROL\r\n          toggle_selection_mode(view) unless @ctrl_locked\r\n        when VK_RETURN\r\n          refresh_selection_from_last_position(view)\r\n          enter_parent_context(view)\r\n        when VK_ESCAPE\r\n          exit_to_model_level\r\n        end\r\n      end\r\n\r\n      def onLButtonDoubleClick(flags, x, y, view)\r\n        refresh_selection_from_last_position(view)\r\n        enter_parent_context(view)\r\n      end\r\n\r\n      def refresh_selection_from_last_position(view)\r\n        return unless @last_mouse_x && @last_mouse_y\r\n        update_selection(@last_mouse_x, @last_mouse_y, view)\r\n        highlight_entity(view)\r\n      end\r\n\r\n      def update_selection(x, y, view)\r\n        ph = view.pick_helper\r\n        ph.do_pick(x, y)\r\n\r\n        case @selection_mode\r\n        when :group_component\r\n          @selected_entity, @selected_instance_path = find_deepest_group_or_component(ph)\r\n        when :face_edge\r\n          @selected_entity, @selected_instance_path = find_deepest_face_or_edge(ph)\r\n        end\r\n      end\r\n\r\n      def find_deepest_group_or_component(pick_helper)\r\n        path = pick_helper.path_at(0)\r\n        return nil, nil if path.nil?\r\n        entity = path.reverse.find { |e| e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance) }\r\n        return entity, build_instance_path(path) if entity\r\n        return nil, nil\r\n      end\r\n\r\n      def find_deepest_face_or_edge(pick_helper)\r\n        path = pick_helper.path_at(0)\r\n        return nil, nil if path.nil?\r\n        entity = path.reverse.find { |e| e.is_a?(Sketchup::Face) || e.is_a?(Sketchup::Edge) }\r\n        return entity, build_instance_path(path) if entity\r\n        return nil, nil\r\n      end\r\n\r\n      def toggle_selection_mode(view = nil)\r\n        @selection_mode = @selection_mode == :group_component ? :face_edge : :group_component\r\n        update_status_text\r\n        view&.invalidate\r\n      end\r\n\r\n      def onReturn(view)\r\n        refresh_selection_from_last_position(view)\r\n        enter_parent_context(view)\r\n      end\r\n\r\n      def enter_parent_context(view = nil)\r\n        return unless @selected_instance_path\r\n\r\n        target_path = target_instance_path_for_enter\r\n        return unless target_path\r\n\r\n        @model.active_path = target_path\r\n\r\n        if @post_enter_action == :paste_in_place && @clipboard_group\r\n          model = Sketchup.active_model\r\n          target_entities = model.active_entities\r\n          tr = @clipboard_group.transformation\r\n          group_def = @clipboard_group.definition\r\n\r\n          model.start_operation(SelecaoHierarquia.obter_texto(:op_colar), true)\r\n\r\n          temp_group_instance = target_entities.add_instance(group_def, tr)\r\n          exploded = temp_group_instance.explode\r\n          @clipboard_group.erase!\r\n          valid_classes = [\r\n            Sketchup::Edge,\r\n            Sketchup::Face,\r\n            Sketchup::Group,\r\n            Sketchup::ComponentInstance,\r\n            Sketchup::ConstructionLine,\r\n            Sketchup::ConstructionPoint,\r\n            Sketchup::Image\r\n          ]\r\n\r\n          safe_selection = Array(exploded).flatten.compact.select { |e|\r\n            valid_classes.include?(e.class) \r\n          }\r\n\r\n          model.selection.clear\r\n          model.selection.add(safe_selection) unless safe_selection.empty?\r\n          model.commit_operation\r\n        end\r\n\r\n        Sketchup.active_model.select_tool(nil)\r\n      end\r\n\r\n      def onCancel(reason, view)\r\n        exit_to_model_level\r\n      end\r\n\r\n      def draw(view)\r\n        return unless @last_mouse_x && @last_mouse_y\r\n\r\n        mode_text = @selection_mode == :group_component ? \r\n          SelecaoHierarquia.obter_texto(:modo_gp_comp) : \r\n          SelecaoHierarquia.obter_texto(:modo_face_edge)\r\n        \r\n        offset_x = 14\r\n        offset_y = 18\r\n\r\n        screen_point = Geom::Point3d.new(@last_mouse_x + offset_x, @last_mouse_y + offset_y, 0)\r\n\r\n        view.draw_text(\r\n          Geom::Point3d.new(screen_point.x + 1, screen_point.y + 1, 0),\r\n          mode_text,\r\n          color: Sketchup::Color.new(0, 0, 0),\r\n          size: 12\r\n        )\r\n\r\n        view.draw_text(\r\n          screen_point,\r\n          mode_text,\r\n          color: Sketchup::Color.new(230, 30, 30),\r\n          size: 12\r\n        )\r\n      end\r\n\r\n      private\r\n\r\n      def build_instance_path(path)\r\n        instance_entities = path.select { |e| e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance) }\r\n        return nil if instance_entities.empty?\r\n\r\n        active_prefix = @model.active_path ? @model.active_path.to_a : []\r\n\r\n        if !active_prefix.empty? && instance_entities.first == active_prefix.last\r\n          instance_entities = instance_entities[1..] || []\r\n        end\r\n\r\n        return nil if active_prefix.empty? && instance_entities.empty?\r\n        Sketchup::InstancePath.new(active_prefix + instance_entities)\r\n      end\r\n\r\n      def exit_to_model_level\r\n        @model.active_path = nil if @model.active_path\r\n        @model.selection.clear\r\n        @view.invalidate\r\n        Sketchup.active_model.select_tool(nil)\r\n      end\r\n\r\n      def target_instance_path_for_enter\r\n        case @selection_mode\r\n        when :group_component\r\n          entities = @selected_instance_path.to_a.select do |e|\r\n            e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance)\r\n          end\r\n          return nil if entities.size <= 1\r\n          Sketchup::InstancePath.new(entities[0...-1])\r\n        else\r\n          @selected_instance_path\r\n        end\r\n      end\r\n\r\n      def update_status_text\r\n        mode_label = @selection_mode == :group_component ? \r\n          SelecaoHierarquia.obter_texto(:status_gp_comp) : \r\n          SelecaoHierarquia.obter_texto(:status_face_ed)\r\n        \r\n        status = SelecaoHierarquia.obter_texto(:prompt_status, { mode: mode_label })\r\n        Sketchup::set_status_text(status, SB_PROMPT)\r\n      end\r\n\r\n      def highlight_entity(view)\r\n        return unless @selected_entity\r\n        view.model.selection.clear\r\n        view.model.selection.add(@selected_entity)\r\n        view.invalidate\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      if !selection.empty? && selection.all? { |e| e.is_a?(Sketchup::Edge) }\r\n        result = UI.messagebox(obter_texto(:msg_copiar), MB_YESNO)\r\n        if result == IDYES\r\n          clipboard_group = model.active_entities.add_group(selection.to_a)\r\n          clipboard_group.name = \"TEMP_CLIPBOARD_GROUP\"\r\n          model.active_entities.erase_entities(selection.to_a)\r\n\r\n          tool = HoverSelectionTool.new(ctrl_locked: true, post_enter_action: :paste_in_place, clipboard_group: clipboard_group)\r\n          model.select_tool(tool)\r\n          tool.activate\r\n          return\r\n        end\r\n      end\r\n\r\n      tool = HoverSelectionTool.new\r\n      model.select_tool(tool)\r\n      tool.activate\r\n    end\r\n  end\r\nend\r\n\r\nScriptUpComunidade::SelecaoHierarquia.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "selecao-de-sequencia-de-arestas-c57qp",
    "title": {
      "pt": "Sele√ß√£o de Sequ√™ncia de Arestas",
      "en": "Edge Sequence Selection",
      "es": "Selecci√≥n de secuencia de aristas"
    },
    "author": "F√°bio Coutinho",
    "version": "1.2",
    "description": {
      "pt": "Seleciona uma sequ√™ncia de arestas a partir da sele√ß√£o e de acordo com o √¢ngulo informado.",
      "en": "Selects a sequence of edges from the selection and according to the specified angle.",
      "es": "Selecciona una secuencia de bordes de la selecci√≥n y de acuerdo con el √°ngulo especificado."
    },
    "keywords": {
      "pt": [
        "sele√ß√£o de arestas"
      ],
      "en": [
        "edge selection"
      ],
      "es": [
        "selecci√≥n de bordes"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module SelecaoPorAngulo\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :titulo_janela   => \"Sele√ß√£o de Arestas por √Çngulo\",\r\n        :cabecalho       => \"Selecionar Arestas por √Çngulo\",\r\n        :label_slider    => \"√Çngulo M√°ximo (0¬∫ a 180¬∫)\",\r\n        :botao_atualizar => \"Atualizar Sele√ß√£o Base\",\r\n        :erro_selecao    => \"Selecione ao menos uma aresta.\",\r\n        :sucesso_base    => \"Nova sele√ß√£o base atualizada.\"\r\n      },\r\n      'en-US' => {\r\n        :titulo_janela   => \"Select Edges by Angle\",\r\n        :cabecalho       => \"Select Edges by Angle\",\r\n        :label_slider    => \"Maximum Angle (0¬∫ to 180¬∫)\",\r\n        :botao_atualizar => \"Update Base Selection\",\r\n        :erro_selecao    => \"Please select at least one edge.\",\r\n        :sucesso_base    => \"New base selection updated.\"\r\n      },\r\n      'es' => {\r\n        :titulo_janela   => \"Selecci√≥n de Aristas por √Ångulo\",\r\n        :cabecalho       => \"Seleccionar Aristas por √Ångulo\",\r\n        :label_slider    => \"√Ångulo M√°ximo (0¬∫ a 180¬∫)\",\r\n        :botao_atualizar => \"Actualizar Selecci√≥n Base\",\r\n        :erro_selecao    => \"Seleccione al menos una arista.\",\r\n        :sucesso_base    => \"Nueva selecci√≥n base actualizada.\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n      $stored_edges = selection.grep(Sketchup::Edge)\r\n\r\n      dlg = UI::HtmlDialog.new(\r\n        dialog_title: obter_texto(:titulo_janela),\r\n        scrollable: true,\r\n        resizable: true,\r\n        width: 400,\r\n        height: 300,\r\n        style: UI::HtmlDialog::STYLE_DIALOG\r\n      )\r\n\r\n      html = <<-HTML\r\n      <!DOCTYPE html>\r\n      <html>\r\n      <head>\r\n        <meta charset=\"UTF-8\">\r\n        <style>\r\n          body {\r\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\r\n            margin: 20px;\r\n          }\r\n          h2 {\r\n            font-size: 18px;\r\n            margin-bottom: 10px;\r\n            color: #323232;\r\n          }\r\n          .form-group {\r\n            margin-bottom: 15px;\r\n          }\r\n          .form-label {\r\n            margin-bottom: 5px;\r\n            font-weight: 600;\r\n          }\r\n          input[type=range] {\r\n            width: 100%;\r\n          }\r\n          .value-display {\r\n            text-align: center;\r\n            font-size: 16px;\r\n            margin-top: 10px;\r\n            font-weight: bold;\r\n          }\r\n          button {\r\n            margin-top: 20px;\r\n            width: 100%;\r\n            padding: 10px;\r\n            background-color: #0078d4;\r\n            color: white;\r\n            border: none;\r\n            border-radius: 4px;\r\n            font-weight: bold;\r\n            cursor: pointer;\r\n          }\r\n          button:hover {\r\n            background-color: #005a9e;\r\n          }\r\n        </style>\r\n      </head>\r\n      <body>\r\n        <h2>#{obter_texto(:cabecalho)}</h2>\r\n        <div class=\"form-group\">\r\n          <label class=\"form-label\" for=\"angleRange\">#{obter_texto(:label_slider)}</label>\r\n          <input type=\"range\" min=\"0\" max=\"180\" value=\"25\" id=\"angleRange\" />\r\n          <div class=\"value-display\" id=\"angleValue\">25¬∞</div>\r\n        </div>\r\n        <button onclick=\"updateBase()\">#{obter_texto(:botao_atualizar)}</button>\r\n\r\n        <script>\r\n          const slider = document.getElementById('angleRange');\r\n          const display = document.getElementById('angleValue');\r\n\r\n          slider.oninput = function() {\r\n            const value = parseInt(this.value);\r\n            display.innerText = value + '¬∞';\r\n            sketchup.update_angle(value);\r\n          };\r\n\r\n          function updateBase() {\r\n            sketchup.update_selection();\r\n          }\r\n        </script>\r\n      </body>\r\n      </html>\r\n      HTML\r\n\r\n      dlg.set_html(html)\r\n\r\n      dlg.add_action_callback(\"update_angle\") do |dialog, value|\r\n        angle = value.to_f\r\n        max_angle_rad = angle * Math::PI / 180.0\r\n        final_edges = []\r\n\r\n        if $stored_edges\r\n          $stored_edges.each { |edge|\r\n            [edge.start, edge.end].each { |start_vertex|\r\n              current_edge = edge\r\n              current_vertex = start_vertex\r\n              chain = [current_edge]\r\n\r\n              loop do\r\n                other_vertex = current_edge.other_vertex(current_vertex)\r\n                connected_edges = other_vertex.edges - [current_edge] - chain\r\n\r\n                min_angle = nil\r\n                next_edge = nil\r\n\r\n                connected_edges.each { |e|\r\n                  vec1 = current_vertex.position.vector_to(other_vertex.position)\r\n                  vec2 = e.start == other_vertex ? e.start.position.vector_to(e.end.position) : e.end.position.vector_to(e.start.position)\r\n                  ang = vec1.angle_between(vec2)\r\n\r\n                  if ang <= max_angle_rad && (min_angle.nil? || ang < min_angle)\r\n                    min_angle = ang\r\n                    next_edge = e\r\n                  end\r\n                }\r\n\r\n                break unless next_edge\r\n                chain << next_edge\r\n                current_vertex = other_vertex\r\n                current_edge = next_edge\r\n              end\r\n\r\n              final_edges.concat(chain)\r\n            }\r\n          }\r\n\r\n          model.selection.clear\r\n          model.selection.add(final_edges.uniq)\r\n        end\r\n      end\r\n\r\n      dlg.add_action_callback(\"update_selection\") do |dialog, _|\r\n        new_edges = model.selection.grep(Sketchup::Edge)\r\n        if new_edges.empty?\r\n          UI.messagebox(obter_texto(:erro_selecao))\r\n        else\r\n          $stored_edges = new_edges\r\n          UI.messagebox(obter_texto(:sucesso_base))\r\n        end\r\n      end\r\n\r\n      dlg.show\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::SelecaoPorAngulo.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "suavizar-arestas-por-angulo-c59fb",
    "title": {
      "pt": "Suavizar Arestas por √Çngulo",
      "en": "Smooth Edges by Angle",
      "es": "Bordes suaves por √°ngulo"
    },
    "author": "F√°bio Coutinho",
    "version": "1.0",
    "description": {
      "pt": "Navega por todos os grupos e componentes aninhados dentro da sele√ß√£o, aplicando suaviza√ß√£o autom√°tica nas arestas entre faces adjacentes. A suaviza√ß√£o s√≥ √© aplicada se o √¢ngulo entre as faces for menor ou igual ao valor definido pelo usu√°rio.",
      "en": "Navigates through all nested groups and components within the selection, applying automatic smoothing to the edges between adjacent faces. Smoothing is only applied if the angle between the faces is less than or equal to the value defined by the user.",
      "es": "Navega por todos los grupos y componentes anidados de la selecci√≥n, aplicando suavizado autom√°tico a los bordes entre caras adyacentes. El suavizado solo se aplica si el √°ngulo entre las caras es menor o igual al valor definido por el usuario."
    },
    "keywords": {
      "pt": [
        "suavizar",
        "arestas",
        "suaviza√ß√£o autom√°tica"
      ],
      "en": [
        "soften",
        "edges",
        "automatic smoothing"
      ],
      "es": [
        "ablandar",
        "bordes",
        "suavizado autom√°tico"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module SuavizarArestasInterativo\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao    => \"Selecione um √∫nico grupo ou componente para aplicar o suavizador.\",\r\n        :op_suavizar     => \"Suavizar Arestas\",\r\n        :titulo_janela   => \"Suavizar Arestas Interativo\",\r\n        :label_angulo    => \"√Çngulo M√°ximo para Suaviza√ß√£o\",\r\n        :btn_fechar      => \"Fechar\",\r\n        :btn_aplicar     => \"Aplicar\",\r\n        :status_concluido => \"Conclu√≠do\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao    => \"Select a single group or component to apply the smoother.\",\r\n        :op_suavizar     => \"Soften Edges\",\r\n        :titulo_janela   => \"Interactive Soften Edges\",\r\n        :label_angulo    => \"Maximum Angle for Softening\",\r\n        :btn_fechar      => \"Close\",\r\n        :btn_aplicar     => \"Apply\",\r\n        :status_concluido => \"Done\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao    => \"Seleccione un solo grupo o componente para aplicar el suavizador.\",\r\n        :op_suavizar     => \"Suavizar Aristas\",\r\n        :titulo_janela   => \"Suavizar Aristas Interactivo\",\r\n        :label_angulo    => \"√Ångulo M√°ximo para Suavizaci√≥n\",\r\n        :btn_fechar      => \"Cerrar\",\r\n        :btn_aplicar     => \"Aplicar\",\r\n        :status_concluido => \"Concluido\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.iniciar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      unless selection.length == 1 && (selection.first.is_a?(Sketchup::Group) || selection.first.is_a?(Sketchup::ComponentInstance))\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n\r\n      @entidade_raiz = selection.first\r\n      @transformacao_raiz = @entidade_raiz.transformation\r\n\r\n      mostrar_interface\r\n    end\r\n\r\n    def self.aplicar_suavizacao(angulo_graus)\r\n      model = Sketchup.active_model\r\n      view = model.active_view\r\n      model.start_operation(obter_texto(:op_suavizar), true)\r\n\r\n      @dialog.execute_script(\"atualizar_progresso(0)\")\r\n      angulo_radianos = angulo_graus.to_f.degrees\r\n\r\n      contar_total = contar_arestas(@entidade_raiz)\r\n      @processadas = 0\r\n      @total_arestas = contar_total\r\n\r\n      suavizar_entidade(@entidade_raiz, @transformacao_raiz, angulo_radianos)\r\n\r\n      @dialog.execute_script(\"atualizar_progresso(100)\")\r\n      model.commit_operation\r\n      view.invalidate\r\n    end\r\n\r\n    def self.contar_arestas(entidade)\r\n      total = 0\r\n      if entidade.is_a?(Sketchup::Group) || entidade.is_a?(Sketchup::ComponentInstance)\r\n        definicao = entidade.definition\r\n        definicao.entities.each do |e|\r\n          if e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance)\r\n            total += contar_arestas(e)\r\n          elsif e.is_a?(Sketchup::Edge) && e.faces.length == 2\r\n            total += 1\r\n          end\r\n        end\r\n      end\r\n      total\r\n    end\r\n\r\n    def self.suavizar_entidade(entidade, tr_global, angulo_maximo)\r\n      if entidade.is_a?(Sketchup::Group) || entidade.is_a?(Sketchup::ComponentInstance)\r\n        definicao = entidade.definition\r\n        tr_local = entidade.transformation\r\n        nova_tr = tr_global * tr_local\r\n\r\n        definicao.entities.each do |e|\r\n          if e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance)\r\n            suavizar_entidade(e, nova_tr, angulo_maximo)\r\n          elsif e.is_a?(Sketchup::Edge) && e.faces.length == 2\r\n            suavizar_ou_nao(e, angulo_maximo)\r\n          end\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.suavizar_ou_nao(aresta, angulo_maximo)\r\n      faces = aresta.faces\r\n      return unless faces.length == 2\r\n\r\n      normal1 = faces[0].normal\r\n      normal2 = faces[1].normal\r\n      return unless normal1 && normal2\r\n\r\n      angulo = normal1.angle_between(normal2)\r\n\r\n      if angulo <= angulo_maximo\r\n        aresta.soft = true\r\n        aresta.smooth = true\r\n      else\r\n        aresta.soft = false\r\n        aresta.smooth = false\r\n      end\r\n\r\n      @processadas += 1\r\n      if @processadas % 100 == 0 || @processadas == @total_arestas\r\n        progresso = ((@processadas.to_f / @total_arestas) * 100).round\r\n        @dialog.execute_script(\"atualizar_progresso(#{progresso})\")\r\n      end\r\n    end\r\n\r\n    def self.mostrar_interface\r\n      @dialog = UI::HtmlDialog.new({\r\n        dialog_title: obter_texto(:titulo_janela),\r\n        width: 500,\r\n        height: 260,\r\n        style: UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n\r\n      html = <<-HTML\r\n        <!DOCTYPE html>\r\n        <html>\r\n        <head>\r\n          <meta charset=\"UTF-8\">\r\n          <style>\r\n            body { font-family: \"Segoe UI\", Tahoma, sans-serif; padding: 20px; margin: 0; background-color: #f9f9f9; color: #333; }\r\n            h5 { margin-bottom: 16px; font-size: 16px; font-weight: 600; }\r\n            .slider-container { position: relative; width: 100%; padding-top: 24px; }\r\n            input[type=\"range\"] { width: 100%; margin: 0; }\r\n            .tooltip { position: absolute; top: 0; transform: translateX(-50%); background: #0053a0; color: white; padding: 4px 10px; border-radius: 6px; font-size: 13px; white-space: nowrap; }\r\n            .progresso-indicador { margin-top: 24px; text-align: center; font-size: 14px; font-weight: bold; color: #0053a0; }\r\n            .button-container { text-align: center; margin-top: 24px; }\r\n            button { min-width: 140px; padding: 8px 20px; font-weight: 600; font-size: 14px; border: none; border-radius: 6px; cursor: pointer; color: white; }\r\n            .btn-primary { background-color: #0053a0; }\r\n            .btn-success { background-color: #2e8540; }\r\n            .btn-primary:hover { background-color: #003d7a; }\r\n            .btn-success:hover { background-color: #256e34; }\r\n          </style>\r\n        </head>\r\n        <body>\r\n          <h5>#{obter_texto(:label_angulo)}</h5>\r\n          <div class=\"slider-container\">\r\n            <div id=\"tooltip\" class=\"tooltip\">85¬∞</div>\r\n            <input id=\"slider\" type=\"range\" min=\"0\" max=\"180\" step=\"1\" value=\"85\" oninput=\"onSliderChange(this.value)\">\r\n          </div>\r\n          <div id=\"progresso_texto\" class=\"progresso-indicador\">0%</div>\r\n          <div class=\"button-container\">\r\n            <button id=\"actionButton\" class=\"btn-primary\" onclick=\"botaoAcao()\">#{obter_texto(:btn_fechar)}</button>\r\n          </div>\r\n          <script>\r\n            const slider = document.getElementById(\"slider\");\r\n            const tooltip = document.getElementById(\"tooltip\");\r\n            const button = document.getElementById(\"actionButton\");\r\n            const txt_fechar = \"#{obter_texto(:btn_fechar)}\";\r\n            const txt_aplicar = \"#{obter_texto(:btn_aplicar)}\";\r\n            const txt_concluido = \"#{obter_texto(:status_concluido)}\";\r\n            let valorAplicado = \"85\";\r\n\r\n            function onSliderChange(valor) {\r\n              tooltip.innerText = valor + \"¬∞\";\r\n              atualizarTooltip();\r\n              if (valor !== valorAplicado) {\r\n                button.innerText = txt_aplicar;\r\n                button.className = \"btn-success\";\r\n              } else {\r\n                button.innerText = txt_fechar;\r\n                button.className = \"btn-primary\";\r\n              }\r\n            }\r\n\r\n            function botaoAcao() {\r\n              const valorAtual = slider.value;\r\n              if (button.innerText === txt_aplicar) {\r\n                atualizar_progresso(0);\r\n                sketchup.aplicar_angulo(valorAtual);\r\n                valorAplicado = valorAtual;\r\n                button.innerText = txt_fechar;\r\n                button.className = \"btn-primary\";\r\n              } else {\r\n                sketchup.fechar_janela();\r\n              }\r\n            }\r\n\r\n            function atualizarTooltip() {\r\n              const percent = (slider.value - slider.min) / (slider.max - slider.min);\r\n              const rangeWidth = slider.offsetWidth;\r\n              const pos = percent * (rangeWidth - 16) + 8;\r\n              tooltip.style.left = pos + \"px\";\r\n            }\r\n\r\n            function atualizar_progresso(valor) {\r\n              const texto = document.getElementById(\"progresso_texto\");\r\n              texto.innerText = valor >= 100 ? txt_concluido : valor + \"%\";\r\n            }\r\n\r\n            window.onload = () => {\r\n              atualizarTooltip();\r\n              setTimeout(() => {\r\n                sketchup.aplicar_angulo(slider.value);\r\n              }, 150);\r\n            };\r\n\r\n            slider.addEventListener(\"input\", atualizarTooltip);\r\n          </script>\r\n        </body>\r\n        </html>\r\n      HTML\r\n\r\n      @dialog.set_html(html)\r\n\r\n      @dialog.add_action_callback(\"aplicar_angulo\") do |_, angulo|\r\n        aplicar_suavizacao(angulo.to_f)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"fechar_janela\") do |_|\r\n        @dialog.close\r\n      end\r\n\r\n      @dialog.show\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::SuavizarArestasInterativo.iniciar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "substituir-textura-c5as4",
    "title": {
      "pt": "Substituir Textura",
      "en": "Replace Texture",
      "es": "Reemplazar textura"
    },
    "author": "Henrique Barsa",
    "version": "1.0",
    "description": {
      "pt": "Substitua uma textura de todo o projeto, por outra.",
      "en": "Replace one texture throughout the project with another.",
      "es": "Reemplace una textura por otra en todo el proyecto."
    },
    "keywords": {
      "pt": [
        "textura",
        "material",
        "substituir"
      ],
      "en": [
        "texture",
        "material",
        "to replace"
      ],
      "es": [
        "textura",
        "material",
        "reemplazar"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module SubstituirMateriais\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :status_inicial    => \"Selecione o material a ser substitu√≠do.\",\r\n        :status_proximo    => \"Selecione outro material para substituir %{material}.\",\r\n        :status_aguarde    => \"Substituindo materiais. Aguarde, por favor...\",\r\n        :op_nome           => \"Substituir Materiais\",\r\n        :default_mat       => \"Padr√£o\",\r\n        :msg_substituir    => \"Substituir %{material} ...\",\r\n        :msg_por           => \"Substituir %{antigo}\\npor %{novo}\"\r\n      },\r\n      'en-US' => {\r\n        :status_inicial    => \"Select the material to be replaced.\",\r\n        :status_proximo    => \"Select another material to replace %{material}.\",\r\n        :status_aguarde    => \"Replacing materials. Please wait...\",\r\n        :op_nome           => \"Replace Materials\",\r\n        :default_mat       => \"Default\",\r\n        :msg_substituir    => \"Replace %{material} ...\",\r\n        :msg_por           => \"Replace %{antigo}\\nwith %{novo}\"\r\n      },\r\n      'es' => {\r\n        :status_inicial    => \"Seleccione el material que desea reemplazar.\",\r\n        :status_proximo    => \"Seleccione otro material para reemplazar %{material}.\",\r\n        :status_aguarde    => \"Reemplazando materiales. Por favor espere...\",\r\n        :op_nome           => \"Reemplazar Materiales\",\r\n        :default_mat       => \"Predeterminado\",\r\n        :msg_substituir    => \"Reemplazar %{material} ...\",\r\n        :msg_por           => \"Reemplazar %{antigo}\\npor %{novo}\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave, variaveis = {})\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      texto  = IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n      \r\n      variaveis.each { |k, v| texto = texto.gsub(\"%{#{k}}\", v.to_s) }\r\n      texto\r\n    end\r\n\r\n    class MatReplacer\r\n      def initialize\r\n        @picked = nil\r\n        @m_org = nil\r\n        @state = 0\r\n      end\r\n\r\n      def activate\r\n        @picked = nil\r\n        @m_org = nil\r\n        @state = 0\r\n        @pos = [0, 0, 0]\r\n        @drawn = false\r\n        update_ui\r\n        @debug = nil\r\n      end\r\n\r\n      def update_ui\r\n        Sketchup.set_status_text(SubstituirMateriais.obter_texto(:status_inicial))\r\n      end\r\n\r\n      def resume(view)\r\n        update_ui\r\n      end\r\n\r\n      def deactivate(view)\r\n        view.invalidate if @drawn\r\n      end\r\n\r\n      def onMouseMove(flags, x, y, view)\r\n        ph = view.pick_helper\r\n        ph.do_pick(x, y)\r\n\r\n        picked = if ph.picked_face\r\n                   ph.picked_face\r\n                 elsif ph.picked_edge\r\n                   ph.picked_edge\r\n                 else\r\n                   ph.best_picked\r\n                 end\r\n\r\n        index = 0\r\n        for i in 1..ph.count\r\n          if ph.element_at(i) == picked\r\n            index = i\r\n            break\r\n          end\r\n        end\r\n\r\n        path = ph.path_at(index)\r\n        t = ph.transformation_at(index)\r\n\r\n        if path.nil?\r\n          @picked = nil\r\n        else\r\n          @picked = nil\r\n          n = (picked.is_a?(Sketchup::Face)) ? picked.normal.transform(t).normalize : nil\r\n          path.each do |e|\r\n            next unless e.respond_to?(:material)\r\n            if e.is_a?(Sketchup::Face)\r\n              c = Sketchup.active_model.active_view.camera.direction\r\n              m = (c % n > 0) ? e.back_material : e.material\r\n              next if m.nil?\r\n              @picked = m\r\n            else\r\n              next if e.material.nil?\r\n              @picked = e.material\r\n            end\r\n          end\r\n        end\r\n\r\n        @pos = [x, y, 0]\r\n        view.invalidate\r\n      end\r\n\r\n      def onLButtonUp(flags, x, y, view)\r\n        if @state == 0\r\n          @m_org = @picked\r\n          @state = 1\r\n          o_name = (@m_org.nil?) ? SubstituirMateriais.obter_texto(:default_mat) : @m_org.display_name\r\n          Sketchup.set_status_text(SubstituirMateriais.obter_texto(:status_proximo, { material: o_name }))\r\n        else\r\n          return if @picked == @m_org\r\n\r\n          model = Sketchup.active_model\r\n          model.start_operation(SubstituirMateriais.obter_texto(:op_nome), true)\r\n          Sketchup.set_status_text(SubstituirMateriais.obter_texto(:status_aguarde))\r\n\r\n          model.entities.each do |e|\r\n            if e.respond_to?(:material)\r\n              e.material = @picked if e.material == @m_org\r\n            end\r\n            if e.respond_to?(:back_material)\r\n              e.back_material = @picked if e.back_material == @m_org\r\n            end\r\n          end\r\n\r\n          model.definitions.each do |d|\r\n            next if d.image?\r\n            d.entities.each do |e|\r\n              if e.respond_to?(:material)\r\n                e.material = @picked if e.material == @m_org\r\n              end\r\n              if e.respond_to?(:back_material)\r\n                e.back_material = @picked if e.back_material == @m_org\r\n              end\r\n            end\r\n          end\r\n\r\n          model.commit_operation\r\n          activate\r\n        end\r\n      end\r\n\r\n      def draw(view)\r\n        pos = @pos.dup\r\n        pos[0] += 30\r\n        pos[1] -= 30\r\n\r\n        if @state == 0\r\n          p_name = (@picked.nil?) ? SubstituirMateriais.obter_texto(:default_mat) : @picked.display_name\r\n          str = SubstituirMateriais.obter_texto(:msg_substituir, { material: p_name })\r\n        else\r\n          o_name = (@m_org.nil?) ? SubstituirMateriais.obter_texto(:default_mat) : @m_org.display_name\r\n          p_name = (@picked.nil?) ? SubstituirMateriais.obter_texto(:default_mat) : @picked.display_name\r\n          str = SubstituirMateriais.obter_texto(:msg_por, { antigo: o_name, novo: p_name })\r\n        end\r\n\r\n        text_options = {\r\n          font: \"Arial\",\r\n          size: 14,\r\n          bold: true,\r\n          color: \"black\"\r\n        }\r\n\r\n        view.draw_text(pos, str, text_options)\r\n        @drawn = true\r\n      end\r\n\r\n      def onSetCursor\r\n        if @state == 0\r\n          UI.set_cursor(648)\r\n        else\r\n          UI.set_cursor(651)\r\n        end\r\n        true\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      tool = MatReplacer.new\r\n      Sketchup.active_model.tools.push_tool(tool)\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::SubstituirMateriais.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "teletransportador-de-geometria-c5cnl",
    "title": {
      "pt": "Teletransportador de Geometria",
      "en": "Geometry Teleporter",
      "es": "Teletransportador de geometr√≠a"
    },
    "author": "F√°bio Coutinho",
    "version": "1.2",
    "description": {
      "pt": "Ferramenta interativa que permite transportar grupos ou componentes do n√≠vel do modelo para dentro de outro grupo ou componente em qualquer profundidade. Possui dois modos de opera√ß√£o: transporte simples ou substitui√ß√£o do conte√∫do de destino, com preserva√ß√£o de materiais e suporte visual din√¢mico.",
      "en": "An interactive tool that allows you to transport groups or components from one model level into another group or component at any depth. It has two operating modes: simple transport or replacement of the target content, with material preservation and dynamic visual support.",
      "es": "Una herramienta interactiva que permite transportar grupos o componentes de un nivel de modelo a otro grupo o componente a cualquier profundidad. Ofrece dos modos de funcionamiento: transporte simple o reemplazo del contenido de destino, con preservaci√≥n de material y soporte visual din√°mico."
    },
    "keywords": {
      "pt": [
        "teletransporte",
        "substituir grupo",
        "mover componente"
      ],
      "en": [
        "teleportation",
        "replace group",
        "move component"
      ],
      "es": [
        "teletransportaci√≥n",
        "reemplazar grupo",
        "mover componente"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module TeletransportadorDeGeometria\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :modo_transp    => \"Transportar\",\r\n        :modo_subst     => \"Substituir\",\r\n        :local_interno  => \"Interno\",\r\n        :local_externo  => \"Externo\",\r\n        :status_origem  => \"Modo (Ctrl): %{acao} | Localiza√ß√£o (Shift): %{local} | Clique no item que ser√° transportado.\",\r\n        :status_destino => \"Modo (Ctrl): %{acao} | Localiza√ß√£o (Shift): %{local} | Clique no local de destino.\",\r\n        :op_nome        => \"Teletransporte\",\r\n        :erro_colar     => \"Erro ao colar inst√¢ncia no destino!\"\r\n      },\r\n      'en-US' => {\r\n        :modo_transp    => \"Transport\",\r\n        :modo_subst     => \"Replace\",\r\n        :local_interno  => \"Internal\",\r\n        :local_externo  => \"External\",\r\n        :status_origem  => \"Mode (Ctrl): %{acao} | Location (Shift): %{local} | Click on the item to be transported.\",\r\n        :status_destino => \"Mode (Ctrl): %{acao} | Location (Shift): %{local} | Click on the destination location.\",\r\n        :op_nome        => \"Teleport\",\r\n        :erro_colar     => \"Error pasting instance at destination!\"\r\n      },\r\n      'es' => {\r\n        :modo_transp    => \"Transportar\",\r\n        :modo_subst     => \"Sustituir\",\r\n        :local_interno  => \"Interno\",\r\n        :local_externo  => \"Externo\",\r\n        :status_origem  => \"Modo (Ctrl): %{acao} | Ubicaci√≥n (Shift): %{local} | Haga clic en el elemento a transportar.\",\r\n        :status_destino => \"Modo (Ctrl): %{acao} | Ubicaci√≥n (Shift): %{local} | Haga clic en la ubicaci√≥n de destino.\",\r\n        :op_nome        => \"Teletransporte\",\r\n        :erro_colar     => \"¬°Error al pegar la instancia en el destino!\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave, variaveis = {})\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      texto  = IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n      \r\n      variaveis.each { |k, v| texto = texto.gsub(\"%{#{k}}\", v.to_s) }\r\n      texto\r\n    end\r\n\r\n    class Tool\r\n      VK_CONTROL ||= 17\r\n      VK_SHIFT ||= 16\r\n\r\n      def initialize\r\n        @step = :select_source\r\n        @mode = :transportar\r\n        @localizacao = :externo\r\n        @source = nil\r\n      end\r\n\r\n      def activate\r\n        Sketchup.status_text = status_message\r\n        Sketchup.active_model.selection.clear\r\n      end\r\n\r\n      def status_message\r\n        acao = @mode == :transportar ? \r\n          TeletransportadorDeGeometria.obter_texto(:modo_transp) : \r\n          TeletransportadorDeGeometria.obter_texto(:modo_subst)\r\n        \r\n        local = @localizacao == :interno ? \r\n          TeletransportadorDeGeometria.obter_texto(:local_interno) : \r\n          TeletransportadorDeGeometria.obter_texto(:local_externo)\r\n        \r\n        case @step\r\n        when :select_source\r\n          TeletransportadorDeGeometria.obter_texto(:status_origem, { acao: acao, local: local })\r\n        when :select_target\r\n          TeletransportadorDeGeometria.obter_texto(:status_destino, { acao: acao, local: local })\r\n        end\r\n      end\r\n\r\n      def onKeyDown(key, repeat, flags, view)\r\n        case key\r\n        when VK_CONTROL\r\n          @mode = (@mode == :transportar ? :substituir : :transportar)\r\n        when VK_SHIFT\r\n          @localizacao = (@localizacao == :interno ? :externo : :interno)\r\n        end\r\n        Sketchup.status_text = status_message\r\n      end\r\n\r\n      def onMouseMove(flags, x, y, view)\r\n        model = Sketchup.active_model\r\n        ph = view.pick_helper\r\n        ph.do_pick(x, y)\r\n        path = ph.path_at(0)\r\n        return model.selection.clear unless path\r\n      \r\n        entity = path.to_a.first\r\n      \r\n        if @step == :select_source\r\n          if entity.is_a?(Sketchup::Group) || entity.is_a?(Sketchup::ComponentInstance)\r\n            model.selection.clear\r\n            model.selection.add(entity)\r\n          else\r\n            model.selection.clear\r\n          end\r\n        else\r\n          entity = path.to_a.reverse.find { |e| e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance) }\r\n          if entity\r\n            model.selection.clear\r\n            model.selection.add(entity)\r\n          else\r\n            model.selection.clear\r\n          end\r\n        end\r\n\r\n        Sketchup.status_text = status_message\r\n      end\r\n\r\n      def onLButtonDown(flags, x, y, view)\r\n        model = Sketchup.active_model\r\n        ph = view.pick_helper\r\n        ph.do_pick(x, y)\r\n        path = ph.path_at(0)\r\n        return unless path\r\n\r\n        path_array = path.to_a\r\n\r\n        if @step == :select_source\r\n          entity = path_array.first\r\n          return unless entity.is_a?(Sketchup::Group) || entity.is_a?(Sketchup::ComponentInstance)\r\n        else\r\n          entity = path_array.reverse.find { |e| e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance) }\r\n          return unless entity\r\n        end\r\n\r\n        entity.make_unique if entity.respond_to?(:make_unique)\r\n\r\n        instance_path = Sketchup::InstancePath.new(path_array[0..path_array.index(entity)])\r\n        global_tr = instance_path.transformation\r\n\r\n        if @step == :select_source\r\n          @source = {\r\n            entity: entity,\r\n            definition: entity.definition,\r\n            global_tr: global_tr\r\n          }\r\n          @step = :select_target\r\n          Sketchup.status_text = status_message\r\n        else\r\n          perform_transfer(@source, entity, global_tr, instance_path)\r\n          reset\r\n        end\r\n      end\r\n\r\n      def perform_transfer(source_data, destination, destination_tr, destination_path)\r\n        model = Sketchup.active_model\r\n        model.start_operation(TeletransportadorDeGeometria.obter_texto(:op_nome), true)\r\n      \r\n        source_entity = source_data[:entity]\r\n        source_definition = source_data[:definition]\r\n        source_tr = source_data[:global_tr]\r\n      \r\n        if @localizacao == :interno\r\n          dest_entities = destination.definition.entities\r\n          inverse_dest_tr = destination_tr.inverse\r\n          relative_tr = inverse_dest_tr * source_tr\r\n        else\r\n          dest_entities = destination.parent.entities\r\n      \r\n          if destination_path\r\n            parent_path = Sketchup::InstancePath.new(destination_path.to_a[0...-1])\r\n            inverse_parent_path_tr = parent_path.transformation.inverse\r\n            relative_tr = inverse_parent_path_tr * source_tr\r\n          else\r\n            relative_tr = source_tr\r\n          end\r\n        end\r\n      \r\n        new_instance = dest_entities.add_instance(source_definition, relative_tr)\r\n        new_instance.material = source_entity.material if source_entity.material\r\n      \r\n        unless new_instance && new_instance.valid?\r\n          UI.messagebox(TeletransportadorDeGeometria.obter_texto(:erro_colar))\r\n          model.abort_operation\r\n          return\r\n        end\r\n      \r\n        if @mode == :substituir\r\n          if @localizacao == :interno\r\n            keep_id = new_instance.entityID\r\n            to_erase = dest_entities.select { |e| e.entityID != keep_id }\r\n            dest_entities.erase_entities(to_erase)\r\n          else\r\n            destination.erase!\r\n          end\r\n        end\r\n      \r\n        source_entity.erase!\r\n      \r\n        model.commit_operation\r\n      end      \r\n\r\n      def reset\r\n        @step = :select_source\r\n        @source = nil\r\n        Sketchup.status_text = status_message\r\n        Sketchup.active_model.selection.clear\r\n      end\r\n\r\n      def deactivate(view)\r\n        Sketchup.status_text = \"\"\r\n        Sketchup.active_model.selection.clear\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      Sketchup.active_model.select_tool(Tool.new)\r\n    end\r\n  end\r\nend\r\n\r\nScriptUpComunidade::TeletransportadorDeGeometria.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "tornar-componentes-unicos-recursivamente-c5enw",
    "title": {
      "pt": "Tornar Componentes √önicos - Recursivamente",
      "en": "Make Components Unique - Recursively",
      "es": "Hacer que los componentes sean √∫nicos - Recursivamente"
    },
    "author": "√örsula M√ºller",
    "version": "1.0",
    "description": {
      "pt": "Torna um componente √∫nico, bem como todos os componentes aninhados dentro dele.",
      "en": "It makes a component unique, as well as all the components nested within it.",
      "es": "Hace que un componente sea √∫nico, as√≠ como todos los componentes anidados en √©l."
    },
    "keywords": {
      "pt": [
        "tornar √∫nico"
      ],
      "en": [
        "to make unique"
      ],
      "es": [
        "para hacer √∫nico"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module TornarUnicoRecursivo\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao => \"Selecione um componente.\",\r\n        :op_nome      => \"Tornar Componentes √önicos Recursivamente\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao => \"Please select a component.\",\r\n        :op_nome      => \"Make Components Unique Recursively\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao => \"Seleccione un componente.\",\r\n        :op_nome      => \"Hacer componentes √∫nicos recursivamente\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.tornar_unico_recursivamente(entidade)\r\n      return unless entidade.is_a?(Sketchup::ComponentInstance)\r\n\r\n      # Torna o componente atual √∫nico, se necess√°rio\r\n      entidade.make_unique unless entidade.definition.instances.size <= 1\r\n\r\n      # Acessa a defini√ß√£o atualizada ap√≥s make_unique\r\n      definicao = entidade.definition\r\n\r\n      # Itera sobre as entidades dentro da defini√ß√£o\r\n      definicao.entities.each do |ent|\r\n        # Se for um componente, chama a fun√ß√£o recursivamente\r\n        tornar_unico_recursivamente(ent) if ent.is_a?(Sketchup::ComponentInstance)\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      if selection.empty?\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n      else\r\n        model.start_operation(obter_texto(:op_nome), true)\r\n\r\n        selection.each do |entidade|\r\n          tornar_unico_recursivamente(entidade)\r\n        end\r\n\r\n        model.commit_operation\r\n      end\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::TornarUnicoRecursivo.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "unir-faces-coplanares-xucxs",
    "title": {
      "pt": "Unir Faces Coplanares",
      "en": "Joining Coplanar Faces",
      "es": "Unir caras coplanares"
    },
    "author": "F√°bio Coutinho",
    "version": "1.4",
    "description": {
      "pt": "Promove a uni√£o de faces coplanares dos elementos selecionados, fazendo a limpeza de faces internas e soltas.",
      "en": "It promotes the joining of coplanar faces of the selected elements, cleaning up internal and loose faces.",
      "es": "Favorece la uni√≥n de caras coplanares de los elementos seleccionados, limpiando caras internas y sueltas."
    },
    "keywords": {
      "pt": [
        "limpeza de faces coplanares"
      ],
      "en": [
        "cleaning of coplanar surfaces"
      ],
      "es": [
        "limpieza de superficies coplanares"
      ]
    },
    "code": {
      "pt": "if defined?(MySolidFix)\r\n  MySolidFix.constants.each do |const|\r\n    MySolidFix.send(:remove_const, const) rescue nil\r\n  end\r\n  Object.send(:remove_const, :MySolidFix) rescue nil\r\nend\r\n\r\nmodule ScriptUpComunidade\r\n  module UnirFacesCoplanares\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :selecao_vazia     => \"Selecione um grupo, componente ou geometria.\",\r\n        :nome_operacao     => \"Limpar Faces Internas + Unir Coplanares\",\r\n        :status_faces      => \"Inspecionando faces...\",\r\n        :status_arestas    => \"Inspecionando arestas...\",\r\n        :status_manifold   => \"Resolvendo manifold...\",\r\n        :status_analisando => \"Analisando arestas...\",\r\n        :status_bordas     => \"Ordenando bordas de superficie...\",\r\n        :status_buracos    => \"Ordenando buracos de face...\",\r\n        :faces_removidas   => \"%d faces internas removidas com precisao.\",\r\n        :arestas_removidas => \"%d arestas removidas entre faces coplanares.\"\r\n      },\r\n      'en-US' => {\r\n        :selecao_vazia     => \"Please select a group, component, or geometry.\",\r\n        :nome_operacao     => \"Clean Internal Faces + Merge Coplanar\",\r\n        :status_faces      => \"Inspecting faces...\",\r\n        :status_arestas    => \"Inspecting edges...\",\r\n        :status_manifold   => \"Resolving manifold...\",\r\n        :status_analisando => \"Analyzing edges...\",\r\n        :status_bordas     => \"Sorting surface borders...\",\r\n        :status_buracos    => \"Sorting face holes...\",\r\n        :faces_removidas   => \"%d internal faces removed with precision.\",\r\n        :arestas_removidas => \"%d edges removed between coplanar faces.\"\r\n      },\r\n      'es' => {\r\n        :selecao_vazia     => \"Por favor seleccione un grupo, componente o geometria.\",\r\n        :nome_operacao     => \"Limpiar Caras Internas + Unir Coplanares\",\r\n        :status_faces      => \"Inspeccionando caras...\",\r\n        :status_arestas    => \"Inspeccionando aristas...\",\r\n        :status_manifold   => \"Resolviendo manifold...\",\r\n        :status_analisando => \"Analizando aristas...\",\r\n        :status_bordas     => \"Ordenando bordes de superficie...\",\r\n        :status_buracos    => \"Ordenando agujeros de cara...\",\r\n        :faces_removidas   => \"%d caras internas eliminadas con precision.\",\r\n        :arestas_removidas => \"%d aristas eliminadas entre caras coplanares.\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.executar\r\n      model     = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      if selection.empty?\r\n        UI.messagebox(obter_texto(:selecao_vazia))\r\n        return\r\n      end\r\n\r\n      tolerance       = 1e-6\r\n      angle_tolerance = 1e-3\r\n\r\n      model.start_operation(obter_texto(:nome_operacao), true)\r\n\r\n      total_removed = 0\r\n      total_edges   = 0\r\n\r\n      selection.each do |ent|\r\n        ents = case ent\r\n               when Sketchup::Group             then ent.entities\r\n               when Sketchup::ComponentInstance then ent.definition.entities\r\n               when Sketchup::Face, Sketchup::Edge then ent.parent.entities\r\n               else next\r\n               end\r\n\r\n        errors = MySolidFix::ErrorFinder.find_errors(ents)\r\n\r\n        internal_faces = errors.select { |e| e.is_a?(MySolidFix::SolidErrors::InternalFace) }\r\n        internal_faces.each do |err|\r\n          face = err.entities[0]\r\n          if face.valid?\r\n            face.erase!\r\n            total_removed += 1\r\n          end\r\n        end\r\n\r\n        ents.grep(Sketchup::Edge).each do |edge|\r\n          next unless edge.valid? && edge.faces.size == 2\r\n          f1, f2 = edge.faces\r\n          begin\r\n            angle    = f1.normal.angle_between(f2.normal)\r\n            coplanar = angle < angle_tolerance &&\r\n               f2.vertices.all? { |v|\r\n                 p = v.position\r\n                 a, b, c, d = f1.plane\r\n                 (a * p.x + b * p.y + c * p.z + d).abs < tolerance\r\n               }\r\n            if coplanar\r\n              edge.erase!\r\n              total_edges += 1\r\n            end\r\n          rescue\r\n            next\r\n          end\r\n        end\r\n      end\r\n\r\n      model.commit_operation\r\n      # puts obter_texto(:faces_removidas)   % total_removed\r\n      # puts obter_texto(:arestas_removidas) % total_edges\r\n    end\r\n\r\n  end\r\nend\r\n\r\nmodule MySolidFix\r\n  module Geometry\r\n\r\n    def self.arc(center, xaxis, normal, radius, start_angle, end_angle, num_segments = 12)\r\n      tr = Geom::Transformation.rotation(center, normal, start_angle)\r\n      points = []\r\n      points << center.offset(xaxis, radius).transform(tr)\r\n      angle = (end_angle - start_angle) / num_segments\r\n      tr = Geom::Transformation.rotation(center, normal, angle)\r\n      1.upto(num_segments) { |i|\r\n        points << points.last.transform(tr)\r\n      }\r\n      return points\r\n    end\r\n\r\n    def self.arc2d(center, xaxis, radius, start_angle, end_angle, num_segments = 24)\r\n      full_angle    = end_angle - start_angle\r\n      segment_angle = full_angle / num_segments\r\n      t   = Geom::Transformation.axes(center, xaxis, xaxis * Z_AXIS, Z_AXIS)\r\n      arc = []\r\n      (0..num_segments).each { |i|\r\n        angle = start_angle + (segment_angle * i)\r\n        x = radius * Math.cos(angle)\r\n        y = radius * Math.sin(angle)\r\n        arc << Geom::Point3d.new(x, y, 0).transform!(t)\r\n      }\r\n      arc\r\n    end\r\n\r\n    def self.circle(center, normal, radius, num_segments)\r\n      pi2   = Math::PI * 2\r\n      xaxis = normal.axes.x\r\n      points = self.arc(center, xaxis, normal, radius, 0.0, pi2, num_segments)\r\n      points.pop\r\n      return points\r\n    end\r\n\r\n    def self.circle2d(center, xaxis, radius, num_segments = 24)\r\n      num_segments = num_segments.to_i\r\n      angle = 360.degrees - (360.degrees / num_segments)\r\n      self.arc2d(center, xaxis, radius, 0, angle, num_segments - 1)\r\n    end\r\n\r\n    def self.arc_segments(angle, full_circle_segments, force_even = false)\r\n      segments = (full_circle_segments * (angle.abs / (Math::PI * 2))).to_i\r\n      segments += 1 if force_even && segments % 2 > 0\r\n      segments = 1 if segments < 1\r\n      return segments\r\n    end\r\n\r\n    def self.mid_point(edge)\r\n      pt1, pt2 = edge.vertices.map { |vertex| vertex.position }\r\n      Geom.linear_combination(0.5, pt1, 0.5, pt2)\r\n    end\r\n\r\n  end\r\nend\r\n\r\nmodule MySolidFix\r\n\r\n  class HeisenBug < RuntimeError; end\r\n\r\n  class Shell\r\n\r\n    PI2 = Math::PI * 2\r\n\r\n    attr_reader :internal_faces, :external_faces, :reversed_faces\r\n\r\n    def initialize(entities)\r\n      @entities      = entities\r\n      @shell_faces   = nil\r\n      @internal_faces  = nil\r\n      @external_faces  = nil\r\n      @reversed_faces  = nil\r\n    end\r\n\r\n    def resolve\r\n      @shell_faces    = Set.new\r\n      @internal_faces = Set.new\r\n      @external_faces = Set.new\r\n      @reversed_faces = Set.new\r\n\r\n      shell_front = Set.new\r\n      find_geometry_groups(@entities) { |geometry_group|\r\n        start_face = find_start_face(geometry_group, true)\r\n        next if start_face.nil?\r\n        shell_front.merge(find_shell(start_face))\r\n      }\r\n      faces           = @entities.grep(Sketchup::Face)\r\n      @internal_faces = Set.new(faces).subtract(shell_front)\r\n\r\n      temp_reversed_faces = @reversed_faces.dup\r\n\r\n      shell_back = Set.new\r\n      find_geometry_groups(@entities) { |geometry_group|\r\n        start_face = find_start_face(geometry_group, false)\r\n        next if start_face.nil?\r\n        shell_back.merge(find_shell(start_face))\r\n      }\r\n\r\n      @shell_faces    = shell_front.intersection(shell_back)\r\n      @external_faces = Set.new(faces).subtract(@internal_faces)\r\n                                      .subtract(@shell_faces)\r\n      @reversed_faces = @shell_faces.intersection(temp_reversed_faces)\r\n      nil\r\n    end\r\n\r\n    def valid?\r\n      if @shell_faces.nil?\r\n        raise RuntimeError, \"`resolve` must be called before calling `valid?`\"\r\n      end\r\n      @shell_faces.size > 0 && @shell_faces.all? { |face|\r\n        face.edges.all? { |edge|\r\n          faces = edge.faces.select { |f| @shell_faces.include?(f) }\r\n          faces.size > 1\r\n        }\r\n      }\r\n    end\r\n\r\n    private\r\n\r\n    def find_geometry_groups(entities)\r\n      num_groups = 0\r\n      stack = entities.to_a\r\n      until stack.empty?\r\n        entity = stack.pop\r\n        next unless entity.respond_to?(:all_connected)\r\n        num_groups += 1\r\n        geometry_group = entity.all_connected\r\n        yield(geometry_group)\r\n        stack = stack - geometry_group\r\n      end\r\n      num_groups\r\n    end\r\n\r\n    def get_faces(entity)\r\n      entity.faces.reject { |face| @internal_faces.include?(face) }\r\n    end\r\n\r\n    def face_normal(face)\r\n      normal = face.normal\r\n      if @reversed_faces.include?(face)\r\n        normal.reverse!\r\n      end\r\n      normal\r\n    end\r\n\r\n    def edge_reversed_in?(edge, face)\r\n      reversed = edge.reversed_in?(face)\r\n      if @reversed_faces.include?(face)\r\n        reversed = !reversed\r\n      end\r\n      reversed\r\n    end\r\n\r\n    def reverse_face(face)\r\n      if @reversed_faces.include?(face)\r\n        @reversed_faces.delete(face)\r\n      else\r\n        @reversed_faces << face\r\n      end\r\n      face\r\n    end\r\n\r\n    def find_start_face(entities, outside)\r\n      vertices = Set.new\r\n      entities.grep(Sketchup::Edge) { |edge|\r\n        vertices.merge(edge.vertices)\r\n      }\r\n      vertices.delete_if { |vertex| get_faces(vertex).empty? }\r\n      return nil if vertices.empty?\r\n\r\n      max_z_vertex = vertices.max { |a, b|\r\n        a.position.z <=> b.position.z\r\n      }\r\n\r\n      edges = max_z_vertex.edges.delete_if { |edge| get_faces(edge).empty? }\r\n      edge  = edges.min { |a, b|\r\n        val_a = edge_normal_z_component(a)\r\n        val_b = edge_normal_z_component(b)\r\n        result = val_a <=> val_b\r\n        if result.nil?\r\n          klass_a = val_a.class.name\r\n          klass_b = val_b.class.name\r\n          raise HeisenBug, \"A: #{a.line.inspect} (#{val_a.inspect}) #{klass_a} - B: #{b.line.inspect} (#{val_b.inspect}) #{klass_b}\"\r\n        end\r\n        result\r\n      }\r\n\r\n      face = get_faces(edge).max { |a, b|\r\n        face_normal(a).z.abs <=> face_normal(b).z.abs\r\n      }\r\n\r\n      if outside\r\n        reverse_face(face) if face_normal(face).z < 0\r\n      else\r\n        reverse_face(face) if face_normal(face).z > 0\r\n      end\r\n\r\n      face\r\n    end\r\n\r\n    def edge_normal_z_component(edge)\r\n      edge.line[1].z.abs\r\n    end\r\n\r\n    def edge_vector(edge, face)\r\n      if edge_reversed_in?(edge, face)\r\n        edge.end.position.vector_to(edge.start)\r\n      else\r\n        edge.start.position.vector_to(edge.end)\r\n      end\r\n    end\r\n\r\n    def get_other_face(edge, face)\r\n      other_face = get_faces(edge).find { |edge_face| edge_face != face }\r\n      return nil if other_face.nil?\r\n      if edge_reversed_in?(edge, face) == edge_reversed_in?(edge, other_face)\r\n        reverse_face(other_face)\r\n      end\r\n      other_face\r\n    end\r\n\r\n    def find_other_shell_face(edge, face)\r\n      return nil if get_faces(edge).size == 1\r\n      return get_other_face(edge, face) if get_faces(edge).size == 2\r\n      return nil if get_faces(edge).count(face) > 1\r\n\r\n      edge_direction = edge_vector(edge, face)\r\n      face_direction = face_normal(face)\r\n      product        = face_direction.cross(edge_direction)\r\n      reversed       = edge_reversed_in?(edge, face)\r\n\r\n      minimum_angle = PI2\r\n      shell_face    = nil\r\n\r\n      get_faces(edge).each { |other_face|\r\n        next if other_face == face\r\n\r\n        other_face_direction = face_normal(other_face)\r\n        if edge_reversed_in?(edge, other_face) == reversed\r\n          other_face_direction.reverse!\r\n        end\r\n\r\n        other_product = edge_direction.cross(other_face_direction)\r\n        angle = product.angle_between(other_product)\r\n        if other_product.dot(face_direction) < 0\r\n          angle = PI2 - angle\r\n        end\r\n\r\n        if angle < minimum_angle\r\n          minimum_angle = angle\r\n          shell_face    = other_face\r\n        end\r\n      }\r\n\r\n      return nil if shell_face.nil?\r\n\r\n      if edge_reversed_in?(edge, shell_face) == reversed\r\n        reverse_face(shell_face)\r\n      end\r\n\r\n      shell_face\r\n    end\r\n\r\n    def find_shell(start_face)\r\n      stack     = []\r\n      processed = Set.new\r\n      shell     = Set.new\r\n\r\n      stack << start_face\r\n      processed << start_face\r\n\r\n      until stack.empty? do\r\n        face = stack.pop\r\n        shell << face\r\n\r\n        face.loops.each { |loop|\r\n          loop.edges.each { |edge|\r\n            next if processed.include?(edge) || get_faces(edge).size < 2\r\n\r\n            processed << edge\r\n            other_shell_face = find_other_shell_face(edge, face)\r\n\r\n            next if other_shell_face.nil?\r\n            next if processed.include?(other_shell_face)\r\n\r\n            stack << other_shell_face\r\n            processed << other_shell_face\r\n          }\r\n        }\r\n      end\r\n\r\n      shell.to_a\r\n    end\r\n\r\n  end\r\nend\r\n\r\nmodule MySolidFix\r\n\r\n  module SolidErrors\r\n\r\n    class SolidError\r\n\r\n      ERROR_COLOR_EDGE = Sketchup::Color.new(255, 0, 0, 255).freeze\r\n      ERROR_COLOR_FACE = Sketchup::Color.new(255, 0, 0, 128).freeze\r\n\r\n      def self.type_name\r\n        self.name.split(\"::\").last\r\n      end\r\n\r\n      def self.display_name\r\n        self.name\r\n      end\r\n\r\n      def self.description\r\n        \"\"\r\n      end\r\n\r\n      attr_accessor :entities\r\n\r\n      def initialize(entities)\r\n        raise TypeError if entities.nil?\r\n        if entities.is_a?(Enumerable)\r\n          @entities = entities.clone\r\n        else\r\n          @entities = [entities]\r\n        end\r\n        @fixed = false\r\n      end\r\n\r\n      def fix\r\n        raise NotImplementedError\r\n      end\r\n\r\n      def fixed?\r\n        @fixed ? true : false\r\n      end\r\n\r\n      def fixable?\r\n        is_a?(Fixable)\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        raise NotImplementedError\r\n      end\r\n\r\n      def to_json(*args)\r\n        data = {\r\n          :id         => object_id,\r\n          :is_fixable => fixable?\r\n        }\r\n        data.to_json(*args)\r\n      end\r\n\r\n    end\r\n\r\n    module Fixable\r\n    end\r\n\r\n    module EraseToFix\r\n\r\n      include Fixable\r\n\r\n      def fix\r\n        entity = @entities.find { |entity| entity.valid? }\r\n        return false if entity.nil?\r\n        entities = entity.parent.entities\r\n        entities.erase_entities(@entities)\r\n        @fixed = true\r\n        true\r\n      end\r\n\r\n    end\r\n\r\n    class HiddenFace < SolidError\r\n\r\n      include Fixable\r\n\r\n      def self.display_name\r\n        \"Hidden Faces\"\r\n      end\r\n\r\n      def self.description\r\n        \"Hidden faces will not be exported to STL file, and may cause holes \"\\\r\n        \"in a mesh.\"\r\n      end\r\n\r\n      def fix\r\n        face = @entities[0]\r\n        return false if face.deleted?\r\n        face.visible = true\r\n        @fixed = true\r\n        true\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_FACE\r\n        draw_face(view, @entities[0], transformation, texture_id: texture_id)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        @entities[0].edges.each { |edge|\r\n          draw_edge(view, edge, transformation)\r\n        }\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class BorderEdge < SolidError\r\n\r\n      def self.display_name\r\n        \"Border Edges\"\r\n      end\r\n\r\n      def self.description\r\n        \"Border edges are connected to only one face and therefore doesn't \"\\\r\n        \"form a manifold. These cannot be fixed automatically and must be \"\\\r\n        \"fixed by hand.\"\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        draw_edge(view, @entities[0], transformation)\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class InternalFaceEdge < SolidError\r\n\r\n      def self.display_name\r\n        \"Internal Face Edges\"\r\n      end\r\n\r\n      def self.description\r\n        \"Internal face edges are edges connected to internal faces. However, \"\\\r\n        \"if there are holes in the mesh it is not possible to reliably \"\\\r\n        \"determine which faces are internal. Fix the holes in the mesh and \"\\\r\n        \"then run the tool again.\"\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        draw_edge(view, @entities[0], transformation)\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class InternalFace < SolidError\r\n\r\n      include EraseToFix\r\n\r\n      def self.display_name\r\n        \"Internal Faces\"\r\n      end\r\n\r\n      def self.description\r\n        \"Internal faces are faces located on the inside of a mesh that should \"\\\r\n        \"be a solid. These are automatically fixed by erasing the internal \"\\\r\n        \"faces.\"\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_FACE\r\n        draw_face(view, @entities[0], transformation, texture_id: texture_id)\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class ExternalFace < SolidError\r\n\r\n      include EraseToFix\r\n\r\n      def self.display_name\r\n        \"External Faces\"\r\n      end\r\n\r\n      def self.description\r\n        \"External faces are faces located on the outside of a mesh that should \"\\\r\n        \"be a solid. These are automatically fixed by erasing the internal \"\\\r\n        \"faces.\"\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_FACE\r\n        draw_face(view, @entities[0], transformation, texture_id: texture_id)\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class ReversedFace < SolidError\r\n\r\n      include Fixable\r\n\r\n      def self.display_name\r\n        \"Reversed Faces\"\r\n      end\r\n\r\n      def self.description\r\n        \"Many applications will not be able to treat a mesh as a solid if the \"\\\r\n        \"face normal (direction) isn't all uniform. The front side of a face \"\\\r\n        \"must be facing outwards. These can be fixed automatically by \"\\\r\n        \"reversing the faces.\"\r\n      end\r\n\r\n      def fix\r\n        face = @entities[0]\r\n        return false if face.deleted?\r\n\r\n        front_material = face.material\r\n        back_material  = face.back_material\r\n\r\n        front_mapping = uv_mapping(face, true)\r\n        back_mapping  = uv_mapping(face, false)\r\n\r\n        front_projection = get_projection(face, true)\r\n        back_projection  = get_projection(face, false)\r\n\r\n        face.reverse!\r\n\r\n        apply_material(face, back_material,  back_mapping,  true)\r\n        apply_material(face, front_material, front_mapping, false)\r\n\r\n        apply_projection(face, back_projection,  true)\r\n        apply_projection(face, front_projection, false)\r\n\r\n        @fixed = true\r\n        true\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_FACE\r\n        draw_face(view, @entities[0], transformation, texture_id: texture_id)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        @entities[0].edges.each { |edge|\r\n          draw_edge(view, edge, transformation)\r\n        }\r\n        nil\r\n      end\r\n\r\n      private\r\n\r\n      def uv_mapping(face, front)\r\n        material = (front) ? face.material : face.back_material\r\n        if material && material.texture\r\n          start_point = face.vertices.first.position\r\n\r\n          points = [start_point]\r\n          points << points[0].offset(face.normal.axes.x, 10)\r\n          points << points[0].offset(face.normal.axes.y, 10)\r\n          points << points[1].offset(face.normal.axes.y, 10)\r\n\r\n          tw  = Sketchup.create_texture_writer\r\n          uvh = face.get_UVHelper(true, true, tw)\r\n\r\n          mapping = []\r\n          points.each_with_index { |point, index|\r\n            uvq = (front) ? uvh.get_front_UVQ(point) : uvh.get_back_UVQ(point)\r\n            mapping << point\r\n            mapping << uvq_to_uv(uvq)\r\n          }\r\n\r\n          mapping\r\n        else\r\n          nil\r\n        end\r\n      end\r\n\r\n      def apply_material(face, material, uv_mapping, front)\r\n        if material && uv_mapping\r\n          face.position_material(material, uv_mapping, front)\r\n        else\r\n          if front\r\n            face.material = material\r\n          else\r\n            face.back_material = material\r\n          end\r\n        end\r\n        nil\r\n      end\r\n\r\n      def uvq_to_uv(uvq)\r\n        Geom::Point3d.new(uvq.x / uvq.z, uvq.y / uvq.z, 1.0)\r\n      end\r\n\r\n      def apply_projection(face, projection, front)\r\n        if projection && face.respond_to?(:set_texture_projection)\r\n          face.set_texture_projection(projection, front)\r\n        end\r\n        nil\r\n      end\r\n\r\n      def get_projection(face, front)\r\n        if face.respond_to?(:get_texture_projection)\r\n          face.get_texture_projection(front)\r\n        else\r\n          nil\r\n        end\r\n      end\r\n\r\n    end\r\n\r\n    class StrayEdge < SolidError\r\n\r\n      include EraseToFix\r\n\r\n      def self.display_name\r\n        \"Stray Edges\"\r\n      end\r\n\r\n      def self.description\r\n        \"Stray edges are not connected to any faces and doesn't form any part \"\\\r\n        \"of solids. These are automatically fixed by erasing the stray edges.\"\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        draw_edge(view, @entities[0], transformation)\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class SurfaceBorder < SolidError\r\n\r\n      def self.display_name\r\n        \"Surface Borders\"\r\n      end\r\n\r\n      def self.description\r\n        \"Edges that form the border of a surface or a hole in the mesh. \"\\\r\n        \"These cannot be fixed automatically. Manually close the mesh and \"\\\r\n        \"run the tool again.\"\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        @entities.each { |edge|\r\n          draw_edge(view, edge, transformation)\r\n        }\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class FaceHole < SolidError\r\n\r\n      include EraseToFix\r\n\r\n      def self.display_name\r\n        \"Face Holes\"\r\n      end\r\n\r\n      def self.description\r\n        \"Edges that form the a hole in a face. These are fixed automatically \"\\\r\n        \"by erasing the hole.\"\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        @entities.each { |edge|\r\n          draw_edge(view, edge, transformation)\r\n        }\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class NestedInstance < SolidError\r\n\r\n      def self.display_name\r\n        \"Nested Instances\"\r\n      end\r\n\r\n      def self.description\r\n        \"Nested instances will be exported correctly to STL file format by \"\\\r\n        \"the Trimble SketchUp STL exporter, but SketchUp's Solid Tools and \"\\\r\n        \"#{PLUGIN_NAME} doesn't treat nested instances as a solid.\"\r\n      end\r\n\r\n      def fix\r\n        raise NotImplementedError\r\n\r\n        return false if @entities[0].deleted?\r\n        @entities[0].explode\r\n        @fixed = true\r\n        true\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        draw_instance(view, @entities[0], transformation)\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class ImageEntity < SolidError\r\n\r\n      def self.display_name\r\n        \"Image Entity\"\r\n      end\r\n\r\n      def self.description\r\n        \"Image entities isn't exported by the Trimble SketchUp STL exporter, \"\\\r\n        \"but it prevent SketchUp's Solid Tools from performing it's \"\\\r\n        \"operations on the object.\"\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        draw_instance(view, @entities[0], transformation)\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class ShortEdge < SolidError\r\n\r\n      def self.display_name\r\n        \"Short Edges\"\r\n      end\r\n\r\n      def self.description\r\n        \"Small geometry might cause unpredictable results due to precision \"\\\r\n        \"errors. It's beneficial to try to avoid such small geometry. This \"\\\r\n        \"cannot be automatically fixed. You might want to scale the model up \"\\\r\n        \"by factors of 10 to work around such problems.\"\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        draw_edge(view, @entities[0], transformation)\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n  end\r\n\r\nend\r\n\r\nmodule MySolidFix\r\n\r\n  class ErrorFinder\r\n\r\n    def self.find_errors(entities)\r\n      raise TypeError unless entities.is_a?(Sketchup::Entities)\r\n\r\n      errors = []\r\n\r\n      self.time(\"Total analysis\") {\r\n\r\n        mesh_border_edges          = []\r\n        hole_edges                 = []\r\n        edges_with_internal_faces  = []\r\n\r\n        Sketchup.status_text = ScriptUpComunidade::UnirFacesCoplanares.obter_texto(:status_faces)\r\n\r\n        all_faces = entities.grep(Sketchup::Face)\r\n        all_faces.each { |face|\r\n          if !face.visible?\r\n            errors << SolidErrors::HiddenFace.new(face)\r\n          end\r\n        }\r\n\r\n        Sketchup.status_text = ScriptUpComunidade::UnirFacesCoplanares.obter_texto(:status_arestas)\r\n\r\n        entities.grep(Sketchup::Edge) { |edge|\r\n          num_faces = edge.faces.size\r\n          if num_faces == 0\r\n            errors << SolidErrors::StrayEdge.new(edge)\r\n          elsif num_faces == 1\r\n            face = edge.faces.first\r\n            if face.outer_loop.edges.include?(edge)\r\n              mesh_border_edges << edge\r\n            else\r\n              hole_edges << edge\r\n            end\r\n          elsif num_faces > 2\r\n            edges_with_internal_faces << edge\r\n          end\r\n        }\r\n\r\n        Sketchup.status_text = ScriptUpComunidade::UnirFacesCoplanares.obter_texto(:status_manifold)\r\n\r\n        shell = Shell.new(entities)\r\n\r\n        self.time(\"Resolving manifold\") {\r\n          shell.resolve\r\n        }\r\n\r\n        if shell.valid?\r\n          shell.internal_faces.each { |face|\r\n            errors << SolidErrors::InternalFace.new(face)\r\n          }\r\n          shell.external_faces.each { |face|\r\n            errors << SolidErrors::ExternalFace.new(face)\r\n          }\r\n          shell.reversed_faces.each { |face|\r\n            errors << SolidErrors::ReversedFace.new(face)\r\n          }\r\n        else\r\n          Sketchup.status_text = ScriptUpComunidade::UnirFacesCoplanares.obter_texto(:status_analisando)\r\n\r\n          Sketchup.status_text = ScriptUpComunidade::UnirFacesCoplanares.obter_texto(:status_bordas)\r\n          self.group_connected_edges(mesh_border_edges).each { |edges|\r\n            errors << SolidErrors::SurfaceBorder.new(edges)\r\n          }\r\n\r\n          Sketchup.status_text = ScriptUpComunidade::UnirFacesCoplanares.obter_texto(:status_buracos)\r\n          self.group_connected_edges(hole_edges).each { |edges|\r\n            errors << SolidErrors::FaceHole.new(edges)\r\n          }\r\n\r\n          edges_with_internal_faces.each { |edge|\r\n            errors << SolidErrors::InternalFaceEdge.new(edge)\r\n          }\r\n        end\r\n\r\n        self.time(\"Instance detection\") {\r\n          groups     = entities.grep(Sketchup::Group)\r\n          components = entities.grep(Sketchup::ComponentInstance)\r\n          instances  = groups + components\r\n          instances.each { |instance|\r\n            errors << SolidErrors::NestedInstance.new(instance)\r\n          }\r\n        }\r\n\r\n        self.time(\"Image detection\") {\r\n          entities.grep(Sketchup::Image) { |image|\r\n            errors << SolidErrors::ImageEntity.new(image)\r\n          }\r\n        }\r\n\r\n        if false\r\n          self.time(\"Short edge detection\") {\r\n            self.find_short_edges(entities) { |edge|\r\n              errors << SolidErrors::ShortEdge.new(edge)\r\n            }\r\n          }\r\n        end\r\n\r\n      }\r\n\r\n      Sketchup.status_text = \"\"\r\n\r\n      errors\r\n    end\r\n\r\n    def self.find_short_edges(entities, &block)\r\n      threshold = Settings.short_edge_threshold\r\n      entities.grep(Sketchup::Edge) { |edge|\r\n        if edge.length < threshold\r\n          block.call(edge)\r\n        end\r\n      }\r\n      nil\r\n    end\r\n\r\n    def self.fix_errors(errors, entities)\r\n      all_errors_fixed       = true\r\n      entities_to_be_erased  = Set.new\r\n      remaining_errors       = []\r\n      errors.each { |error|\r\n        if error.is_a?(SolidErrors::EraseToFix)\r\n          entities_to_be_erased.merge(error.entities)\r\n        else\r\n          remaining_errors << error\r\n        end\r\n      }\r\n\r\n      stray_edges = Set.new\r\n      entities_to_be_erased.grep(Sketchup::Face) { |face|\r\n        face.edges.each { |edge|\r\n          if edge.faces.all? { |f| entities_to_be_erased.include?(f) }\r\n            stray_edges << edge\r\n          end\r\n        }\r\n      }\r\n      entities_to_be_erased.merge(stray_edges)\r\n      entities_to_be_erased.reject! { |entity| entity.deleted? }\r\n\r\n      model = entities.model\r\n      begin\r\n        model.start_operation(\"Repair Solid\", true)\r\n        entities.erase_entities(entities_to_be_erased.to_a)\r\n        remaining_errors.each { |error|\r\n          begin\r\n            error.fix\r\n          rescue NotImplementedError => e\r\n            all_errors_fixed = false\r\n          end\r\n        }\r\n        model.commit_operation\r\n      rescue\r\n        model.commit_operation\r\n        raise\r\n      end\r\n      all_errors_fixed\r\n    end\r\n\r\n    def self.group_connected_edges(edges)\r\n      groups = []\r\n      stack  = edges.to_a.clone\r\n      until stack.empty?\r\n        cluster = []\r\n        cluster << stack.shift\r\n\r\n        edge     = cluster.first\r\n        haystack = self.neighbour_edges(edge) & stack\r\n        until haystack.empty?\r\n          next_edge = haystack.shift\r\n\r\n          if stack.include?(next_edge)\r\n            cluster << next_edge\r\n            stack.delete(next_edge)\r\n            haystack += self.neighbour_edges(next_edge) & stack\r\n          end\r\n        end\r\n\r\n        groups << cluster\r\n      end\r\n      groups\r\n    end\r\n\r\n    def self.neighbour_edges(edge)\r\n      (edge.start.edges + edge.end.edges) - [edge]\r\n    end\r\n\r\n    def self.time(message, &block)\r\n      start_time = Time.new\r\n      block.call\r\n      elapsed_time = Time.now - start_time\r\n      if false\r\n        puts \"> #{message} took: #{elapsed_time}s\"\r\n      end\r\n      nil\r\n    end\r\n\r\n  end\r\n\r\nend\r\n\r\nScriptUpComunidade::UnirFacesCoplanares.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "subdivide-face-6tyb6",
    "title": {
      "pt": "Subdivide Face",
      "en": "Subdivide Face",
      "es": "Subdividir cara"
    },
    "author": "F√°bio Coutinho",
    "version": "0.4",
    "description": {
      "pt": "Subdivide face selecionada em dist√¢ncias iguais com resultado de malha suavizada. Ideal para usar com a ferramenta Modelar do Snadbox ou outras ferramentas de modifica√ß√£o de malha.",
      "en": "Subdivides selected face into equal distances resulting in a smoothed mesh. Ideal for use with the Snapbox Model tool or other mesh modification tools.",
      "es": "Subdivide la cara seleccionada en distancias iguales, lo que resulta en una malla suavizada. Ideal para usar con la herramienta Modelo Snapbox u otras herramientas de modificaci√≥n de malla."
    },
    "keywords": {
      "pt": [
        "terreno",
        "malha",
        "sandbox"
      ],
      "en": [
        "land",
        "mesh",
        "sandbox"
      ],
      "es": [
        "tierra",
        "malla",
        "salvadera"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module SubdivideFaceDistancia\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao   => \"Selecione UMA face.\",\r\n        :operacao_nome  => \"Malha Interativa\",\r\n        :titulo_janela  => \"Ajuste de Malha\",\r\n        :label_h3       => \"Espa√ßamento da Malha\",\r\n        :unidade        => \"mm\",\r\n        :btn_cancelar   => \"Cancelar\",\r\n        :btn_aplicar    => \"Aplicar\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao   => \"Select ONE face.\",\r\n        :operacao_nome  => \"Interactive Mesh\",\r\n        :titulo_janela  => \"Mesh Adjustment\",\r\n        :label_h3       => \"Mesh Spacing\",\r\n        :unidade        => \"mm\",\r\n        :btn_cancelar   => \"Cancel\",\r\n        :btn_aplicar    => \"Apply\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao   => \"Seleccione UNA cara.\",\r\n        :operacao_nome  => \"Malla Interactiva\",\r\n        :titulo_janela  => \"Ajuste de Malla\",\r\n        :label_h3       => \"Espaciado de la Malla\",\r\n        :unidade        => \"mm\",\r\n        :btn_cancelar   => \"Cancelar\",\r\n        :btn_aplicar    => \"Aplicar\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    class MalhaPreviewTool\r\n      def initialize(model, face, loops2d, umin, umax, vmin, vmax, plane, t_l2w, modulo)\r\n        @model = model\r\n        @face = face\r\n        @loops2d = loops2d\r\n        @umin, @umax = umin, umax\r\n        @vmin, @vmax = vmin, vmax\r\n        @plane = plane\r\n        @t_l2w = t_l2w\r\n        @modulo = modulo\r\n        @eps = 1.0e-6\r\n        @draw_points = []\r\n        @dialog = nil\r\n        @is_applied = false\r\n      end\r\n\r\n      def activate\r\n        @model.start_operation(@modulo.obter_texto(:operacao_nome), true)\r\n        criar_dialogo\r\n        calcular_linhas(50)\r\n      end\r\n\r\n      def deactivate(view)\r\n        @dialog.close if @dialog && @dialog.visible?\r\n        @model.abort_operation unless @is_applied\r\n        view.invalidate\r\n      end\r\n\r\n      def draw(view)\r\n        return if @draw_points.empty?\r\n        view.drawing_color = \"red\"\r\n        view.line_width = 2\r\n        view.draw(GL_LINES, @draw_points)\r\n      end\r\n      \r\n      def calcular_linhas(step_val)\r\n        step = step_val.to_f.mm\r\n        return if step <= 0.0\r\n\r\n        @draw_points.clear\r\n        \r\n        uc = 0.5 * (@umin + @umax)\r\n        vc = 0.5 * (@vmin + @vmax)\r\n        nx = ((@umax - @umin) * 0.5 / step).floor\r\n        ny = ((@vmax - @vmin) * 0.5 / step).floor\r\n\r\n        vx = [uc]\r\n        (1..nx).each { |k| vx << (uc + k*step) << (uc - k*step) }\r\n        vx.select! { |x| x > @umin + @eps && x < @umax - @eps }\r\n        vx = unique_sorted(vx, @eps)\r\n\r\n        vy = [vc]\r\n        (1..ny).each { |k| vy << (vc + k*step) << (vc - k*step) }\r\n        vy.select! { |y| y > @vmin + @eps && y < @vmax - @eps }\r\n        vy = unique_sorted(vy, @eps)\r\n\r\n        vx.each do |ux|\r\n          ys = crossings_for_x(ux, @loops2d, @eps)\r\n          next if ys.length.odd?\r\n          (0...(ys.length/2)).each do |i|\r\n            y0, y1 = ys[2*i], ys[2*i + 1]\r\n            brk = [y0] + vy.select { |yy| yy > y0 + @eps && yy < y1 - @eps } + [y1]\r\n            brk = unique_sorted(brk, @eps)\r\n            (0...brk.length-1).each do |j|\r\n              adicionar_ponto(ux, brk[j], ux, brk[j+1])\r\n            end\r\n          end\r\n        end\r\n\r\n        vy.each do |vyv|\r\n          xs = crossings_for_y(vyv, @loops2d, @eps)\r\n          next if xs.length.odd?\r\n          (0...(xs.length/2)).each do |i|\r\n            x0, x1 = xs[2*i], xs[2*i + 1]\r\n            brk = [x0] + vx.select { |xx| xx > x0 + @eps && xx < x1 - @eps } + [x1]\r\n            brk = unique_sorted(brk, @eps)\r\n            (0...brk.length-1).each do |j|\r\n              adicionar_ponto(brk[j], vyv, brk[j+1], vyv)\r\n            end\r\n          end\r\n        end\r\n\r\n        @model.active_view.invalidate\r\n      end\r\n\r\n      def adicionar_ponto(x1, y1, x2, y2)\r\n        p1w = (@t_l2w * Geom::Point3d.new(x1, y1, 0)).project_to_plane(@plane)\r\n        p2w = (@t_l2w * Geom::Point3d.new(x2, y2, 0)).project_to_plane(@plane)\r\n        @draw_points << p1w << p2w\r\n      end\r\n\r\n      def criar_dialogo\r\n        html = <<-HTML\r\n        <!DOCTYPE html>\r\n        <html>\r\n        <head>\r\n          <style>\r\n            :root { --primary: #0f62fe; --bg: #f4f4f4; --text: #161616; --border: #c6c6c6; }\r\n            * { box-sizing: border-box; }\r\n            body { \r\n              font-family: \"Segoe UI\", Roboto, Helvetica, sans-serif;\r\n              padding: 20px; \r\n              background: var(--bg); \r\n              color: var(--text); \r\n              margin: 0; \r\n              display: flex; \r\n              flex-direction: column; \r\n              height: 100vh;\r\n            }\r\n            h3 { margin: 0 0 15px 0; font-size: 14px; font-weight: 600;\r\n            color: #525252; text-transform: uppercase; letter-spacing: 0.5px; }\r\n            .control-group { \r\n              background: #fff;\r\n              padding: 15px; \r\n              border-radius: 8px; \r\n              box-shadow: 0 1px 3px rgba(0,0,0,0.08);\r\n              border: 1px solid #e0e0e0;\r\n            }\r\n            .row { display: flex; align-items: center; gap: 12px; }\r\n            input[type=range] { flex-grow: 1; cursor: pointer; accent-color: var(--primary); }\r\n            input[type=number] { \r\n              width: 70px;\r\n              padding: 6px; \r\n              text-align: right; \r\n              border: 1px solid var(--border); \r\n              border-radius: 4px; \r\n              font-size: 14px;\r\n            }\r\n            input[type=number]:focus { outline: 1px solid var(--primary); border-color: var(--primary); }\r\n            .unit { font-size: 13px; color: #666; font-weight: 500; }\r\n            .actions { margin-top: auto; display: flex; gap: 10px; justify-content: flex-end;\r\n            padding-top: 15px;}\r\n            button { \r\n              padding: 8px 16px;\r\n              cursor: pointer; \r\n              border: 1px solid var(--border); \r\n              background: #fff; \r\n              border-radius: 4px; \r\n              font-size: 13px;\r\n              transition: all 0.2s ease;\r\n            }\r\n            button:hover { background: #e5e5e5; }\r\n            #btnApply { background: var(--primary); color: white; border: none; font-weight: 500; }\r\n            #btnApply:hover { background: #0353e9; }\r\n          </style>\r\n        </head>\r\n        <body>\r\n          <h3>#{@modulo.obter_texto(:label_h3)}</h3>\r\n          <div class=\"control-group\">\r\n            <div class=\"row\">\r\n              <input type=\"range\" id=\"slider\" min=\"5\" max=\"2000\" value=\"50\" step=\"1\">\r\n              <input type=\"number\" id=\"inputBox\" min=\"1\" value=\"50\">\r\n              <span class=\"unit\">#{@modulo.obter_texto(:unidade)}</span>\r\n            </div>\r\n          </div>\r\n          <div class=\"actions\">\r\n            <button id=\"btnCancel\">#{@modulo.obter_texto(:btn_cancelar)}</button>\r\n            <button id=\"btnApply\">#{@modulo.obter_texto(:btn_aplicar)}</button>\r\n          </div>\r\n          \r\n          <script>\r\n            const slider = document.getElementById('slider');\r\n            const inputBox = document.getElementById('inputBox');\r\n            let timeout = null;\r\n            \r\n            function update(val) {\r\n              clearTimeout(timeout);\r\n              timeout = setTimeout(() => sketchup.update_preview(Number(val)), 10);\r\n            }\r\n\r\n            slider.addEventListener('input', (e) => { inputBox.value = e.target.value; update(e.target.value); });\r\n            inputBox.addEventListener('change', (e) => { slider.value = e.target.value; update(e.target.value); });\r\n\r\n            document.getElementById('btnApply').addEventListener('click', () => sketchup.apply_mesh());\r\n            document.getElementById('btnCancel').addEventListener('click', () => sketchup.cancel_mesh());\r\n          </script>\r\n        </body>\r\n        </html>\r\n        HTML\r\n\r\n        @dialog = UI::HtmlDialog.new({\r\n          dialog_title: @modulo.obter_texto(:titulo_janela), \r\n          width: 360, \r\n          height: 220,\r\n          style: UI::HtmlDialog::STYLE_DIALOG, \r\n          resizable: false\r\n        })\r\n        @dialog.set_html(html)\r\n\r\n        @dialog.add_action_callback(\"update_preview\") { |_, val| calcular_linhas(val) }\r\n        @dialog.add_action_callback(\"apply_mesh\") { |_| aplicar_malha }\r\n        @dialog.add_action_callback(\"cancel_mesh\") { |_| @model.select_tool(nil) }\r\n        \r\n        @dialog.show\r\n      end\r\n\r\n      def aplicar_malha\r\n        @is_applied = true\r\n        ents = @face.parent.entities\r\n        created = []\r\n        \r\n        @draw_points.each_slice(2) do |p1, p2|\r\n          e = ents.add_line(p1, p2)\r\n          created << e if e\r\n        end\r\n        \r\n        created.compact.each { |e| e.find_faces if e.valid? && e.faces.empty? }\r\n        created.compact.each do |e|\r\n          if e.valid? && e.faces.length == 2\r\n            e.soft = true\r\n            e.smooth = true\r\n          end\r\n        end\r\n        \r\n        @model.commit_operation\r\n        @dialog.close\r\n        @model.select_tool(nil)\r\n      end\r\n\r\n      def unique_sorted(vals, eps)\r\n        vals.sort!\r\n        out = []; last = nil\r\n        vals.each do |v|\r\n          if last.nil? || (v - last).abs > eps\r\n            out << v; last = v\r\n          end\r\n        end\r\n        out\r\n      end\r\n\r\n      def crossings_for_x(ux, loops2d, eps)\r\n        ys = []\r\n        loops2d.each do |poly|\r\n          (0...poly.length).each do |i|\r\n            p1 = poly[i]; p2 = poly[(i + 1) % poly.length]\r\n            x1,y1 = p1.x, p1.y; x2,y2 = p2.x, p2.y\r\n            minx, maxx = [x1,x2].min, [x1,x2].max\r\n            next if ux < minx - eps || ux > maxx + eps\r\n            dx = x2 - x1; next if dx.abs < eps\r\n            t = (ux - x1) / dx; next if t <= 0.0 || t > 1.0 + 1e-12\r\n            ys << (y1 + t*(y2 - y1))\r\n          end\r\n        end\r\n        unique_sorted(ys, eps)\r\n      end\r\n\r\n      def crossings_for_y(vy, loops2d, eps)\r\n        xs = []\r\n        loops2d.each do |poly|\r\n          (0...poly.length).each do |i|\r\n            p1 = poly[i]; p2 = poly[(i + 1) % poly.length]\r\n            x1,y1 = p1.x, p1.y; x2,y2 = p2.x, p2.y\r\n            miny, maxy = [y1,y2].min, [y1,y2].max\r\n            next if vy < miny - eps || vy > maxy + eps\r\n            dy = y2 - y1; next if dy.abs < eps\r\n            t = (vy - y1) / dy; next if t <= 0.0 || t > 1.0 + 1e-12\r\n            xs << (x1 + t*(x2 - x1))\r\n          end\r\n        end\r\n        unique_sorted(xs, eps)\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      sel   = model.selection\r\n      unless sel[0].is_a?(Sketchup::Face)\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n      face = sel[0]\r\n      n = face.normal\r\n\r\n      longest = face.edges.max_by { |e| e.length.to_f }\r\n      u = nil\r\n      if longest\r\n        vraw = (longest.end.position - longest.start.position)\r\n        dot  = vraw.dot(n)\r\n        nsc  = Geom::Vector3d.new(n.x * dot, n.y * dot, n.z * dot)\r\n        vproj = vraw - nsc\r\n        u = vproj.length > 1e-6 ? vproj.normalize : nil\r\n      end\r\n      if u.nil? || u.length < 1e-6\r\n        u = n.cross(X_AXIS);\r\n        u = n.cross(Y_AXIS) if u.length < 1e-6\r\n        u.normalize!\r\n      end\r\n      v = n.cross(u).normalize\r\n\r\n      plane = [face.vertices.first.position, n]\r\n      bb_center = face.bounds.center\r\n      c = bb_center.project_to_plane(plane)\r\n      t_l2w = Geom::Transformation.axes(c, u, v, n)\r\n      t_w2l = t_l2w.inverse\r\n\r\n      loops2d = face.loops.map do |lp|\r\n        pts = lp.vertices.map { |vr| t_w2l * vr.position }\r\n        pts.map! { |p| Geom::Point3d.new(p.x, p.y, 0) }\r\n        pts\r\n      end\r\n\r\n      all_pts = loops2d.flatten\r\n      allx = all_pts.map(&:x)\r\n      ally = all_pts.map(&:y)\r\n      umin, umax = allx.min, allx.max\r\n      vmin, vmax = ally.min, ally.max\r\n\r\n      model.select_tool(MalhaPreviewTool.new(model, face, loops2d, umin, umax, vmin, vmax, plane, t_l2w, self))\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::SubdivideFaceDistancia.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "selecao-de-malha-por-raio-6u03g",
    "title": {
      "pt": "Sele√ß√£o de Malha por Raio",
      "en": "Mesh Selection by Radius",
      "es": "Selecci√≥n de malla por radio"
    },
    "author": "F√°bio Coutinho",
    "version": "0.3",
    "description": {
      "pt": "Permite selecionar faces de uma malha com uma ferramenta circular. Voc√™ pode definir o raio e alterar entre selecionar ou remover sele√ß√£o.",
      "en": "Allows you to select mesh faces with a circular tool. You can set the radius and switch between selecting or removing the selection.",
      "es": "Permite seleccionar caras de malla con una herramienta circular. Se puede ajustar el radio y alternar entre seleccionar o eliminar la selecci√≥n."
    },
    "keywords": {
      "pt": [
        "sele√ß√£o de malha"
      ],
      "en": [
        "mesh selection"
      ],
      "es": [
        "selecci√≥n de malla"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module PolyBrushSelecao\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :status_text    => \"Pinte com bot√£o esquerdo (commit no soltar). CTRL alterna modo. SHIFT+R reindexa. VCB: di√¢metro + ENTER.\",\r\n        :modo_remover   => \"MODO: Desfazer (CTRL alterna)\",\r\n        :modo_selecionar => \"MODO: Selecionar (CTRL alterna)\",\r\n        :hud_diametro   => \"Di√¢metro: %{diam} mm  |  Medidas: digite valor + ENTER\",\r\n        :op_nome        => \"PolyBrush Sele√ß√£o\"\r\n      },\r\n      'en-US' => {\r\n        :status_text    => \"Paint with left button (commit on release). CTRL toggles mode. SHIFT+R reindexes. VCB: diameter + ENTER.\",\r\n        :modo_remover   => \"MODE: Remove (CTRL toggles)\",\r\n        :modo_selecionar => \"MODE: Select (CTRL toggles)\",\r\n        :hud_diametro   => \"Diameter: %{diam} mm  |  Measurements: type value + ENTER\",\r\n        :op_nome        => \"PolyBrush Selection\"\r\n      },\r\n      'es' => {\r\n        :status_text    => \"Pinte con el bot√≥n izquierdo (confirmar al soltar). CTRL alterna modo. SHIFT+R reindexa. VCB: di√°metro + ENTER.\",\r\n        :modo_remover   => \"MODO: Deshacer (CTRL alterna)\",\r\n        :modo_selecionar => \"MODO: Seleccionar (CTRL alterna)\",\r\n        :hud_diametro   => \"Di√°metro: %{diam} mm  |  Medidas: escriba valor + ENTER\",\r\n        :op_nome        => \"Selecci√≥n PolyBrush\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave, variaveis = {})\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      texto  = IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n      variaveis.each { |k, v| texto = texto.gsub(\"%{#{k}}\", v.to_s) }\r\n      texto\r\n    end\r\n\r\n    class Tool\r\n      include Math\r\n\r\n      def initialize\r\n        require 'set'\r\n\r\n        @diameter_mm = 10000.0\r\n        @radius      = @diameter_mm.mm / 2.0\r\n        @mode_remove = false\r\n        @dragging    = false\r\n        @cursor_pt   = nil\r\n        @ctrl_prev   = false\r\n\r\n        model    = Sketchup.active_model\r\n        @edit_tr = model.edit_transform\r\n\r\n        # Eixos do contexto\r\n        @px = Geom::Vector3d.new(1,0,0).transform(@edit_tr)\r\n        @px.length == 0 ? @px.set!(1,0,0) : @px.normalize!\r\n        @py = Geom::Vector3d.new(0,1,0).transform(@edit_tr); @py.length == 0 ? @py.set!(0,1,0) : @py.normalize!\r\n        @pz = Geom::Vector3d.new(0,0,1).transform(@edit_tr)\r\n        @pz.length == 0 ? @pz.set!(0,0,1) : @pz.normalize!\r\n        @porigin = Geom::Point3d.new(0,0,0).transform(@edit_tr)\r\n\r\n        # √çndice espacial inicial\r\n        build_uv_cache(@radius)\r\n\r\n        # Buffers da passada atual (arrasto)\r\n        @stroke_face_pids = nil   \r\n        @stroke_painted   = Set.new \r\n        @applied_ids      = Set.new \r\n        @sel_initial_face_pids = Set.new\r\n        @sel_initial_others    = [] \r\n      end\r\n\r\n      # ---------- Utils ----------\r\n      def scale_vec(v, s) Geom::Vector3d.new(v.x*s, v.y*s, v.z*s) end\r\n\r\n      def project_uv(p3)\r\n        v = p3 - @porigin\r\n        [v.dot(@px), v.dot(@py)]\r\n      end\r\n\r\n      def pick_on_surface(x, y, view)\r\n        ray = view.pickray(x, y)\r\n        hit = Sketchup.active_model.raytest(ray, true)\r\n        pt = hit && hit[0]\r\n        pt ||= Geom.intersect_line_plane(ray, [@porigin, @pz])\r\n        pt ? pt.offset(@pz, 0.5.mm) : nil\r\n      end\r\n\r\n      def circle_points(center3d, radius_len, segments = 64)\r\n        r = radius_len.to_f\r\n        pts = []\r\n        segments.times do |i|\r\n          t  = 2.0 * PI * (i.to_f / segments)\r\n          vx = scale_vec(@px, r * Math.cos(t))\r\n          vy = scale_vec(@py, r * Math.sin(t))\r\n          pts << center3d.offset(vx + vy)\r\n        end\r\n        pts\r\n      end\r\n\r\n      # ---------- √çndice Espacial / Cache ----------\r\n      def build_uv_cache(cell_size = @radius)\r\n        ents  = Sketchup.active_model.active_entities\r\n        @faces = ents.grep(Sketchup::Face).select(&:valid?)\r\n        @pid_to_face = {}\r\n        @uv_by_pid   = {}\r\n        @grid        = {}\r\n        @cell = [cell_size.to_f, 1.mm.to_f].max\r\n\r\n        @faces.each do |f|\r\n          pid = f.persistent_id\r\n          @pid_to_face[pid] = f\r\n          uvs = f.vertices.map { |v| project_uv(v.position) }\r\n          @uv_by_pid[pid] = uvs\r\n          umin, umax = uvs.map(&:first).minmax\r\n          vmin, vmax = uvs.map(&:last ).minmax\r\n          ix0 = (umin/@cell).floor\r\n          ix1 = (umax/@cell).floor\r\n          iy0 = (vmin/@cell).floor\r\n          iy1 = (vmax/@cell).floor\r\n          (ix0..ix1).each do |ix|\r\n            (iy0..iy1).each do |iy|\r\n              key = \"#{ix},#{iy}\"\r\n              (@grid[key] ||= Set.new) << pid\r\n            end\r\n          end\r\n        end\r\n      end\r\n\r\n      def candidate_pids(center3d, radius)\r\n        uc, vc = project_uv(center3d)\r\n        r  = radius.to_f\r\n        cr = (r/@cell).ceil\r\n        cix = (uc/@cell).floor\r\n        ciy = (vc/@cell).floor\r\n        out = Set.new\r\n        (-cr..cr).each do |dx|\r\n          (-cr..cr).each do |dy|\r\n            key = \"#{cix+dx},#{ciy+dy}\"\r\n            s = @grid[key]\r\n            out.merge(s) if s\r\n          end\r\n        end\r\n        out\r\n      end\r\n\r\n      # ---------- Passada (arrasto) em mem√≥ria ----------\r\n      def begin_stroke\r\n        sel = Sketchup.active_model.selection\r\n        faces = sel.grep(Sketchup::Face)\r\n        others = sel.to_a - faces\r\n        @sel_initial_face_pids = Set.new(faces.map(&:persistent_id))\r\n        @sel_initial_others    = others\r\n        @stroke_face_pids = @sel_initial_face_pids.dup\r\n        @stroke_painted.clear\r\n        @applied_ids.clear\r\n      end\r\n\r\n      def apply_brush_at(center3d)\r\n        return unless center3d\r\n        return unless @stroke_face_pids\r\n\r\n        r   = @radius.to_f\r\n        r2  = r*r\r\n        uc, vc = project_uv(center3d)\r\n\r\n        candidate_pids(center3d, r).each do |pid|\r\n          next if @applied_ids.include?(pid)\r\n          uvs = @uv_by_pid[pid]\r\n          next unless uvs && !uvs.empty?\r\n          inside = uvs.any? { |(u,v)| ((u-uc)**2 + (v-vc)**2) <= r2 }\r\n          next unless inside\r\n\r\n          if @mode_remove\r\n            @stroke_face_pids.delete(pid)\r\n          else\r\n            @stroke_face_pids.add(pid)\r\n          end\r\n\r\n          @stroke_painted.add(pid)\r\n          @applied_ids.add(pid)\r\n        end\r\n      end\r\n\r\n      def commit_stroke\r\n        return unless @stroke_face_pids\r\n\r\n        faces_final = @stroke_face_pids.map { |pid|\r\n          f = @pid_to_face[pid]\r\n          (f && f.valid?) ? f : nil\r\n        }.compact\r\n        final_selection = @sel_initial_others + faces_final\r\n\r\n        model = Sketchup.active_model\r\n        sel   = model.selection\r\n        model.start_operation(PolyBrushSelecao.obter_texto(:op_nome), true)\r\n        sel.clear\r\n        sel.add(final_selection)\r\n        model.commit_operation\r\n\r\n        @stroke_face_pids = nil\r\n        @stroke_painted.clear\r\n        @applied_ids.clear\r\n      end\r\n\r\n      def cancel_stroke\r\n        @stroke_face_pids = nil\r\n        @stroke_painted.clear\r\n        @applied_ids.clear\r\n      end\r\n\r\n      # ---------- HUD ----------\r\n      def hud_lines\r\n        mode = @mode_remove ? PolyBrushSelecao.obter_texto(:modo_remover) : PolyBrushSelecao.obter_texto(:modo_selecionar)\r\n        dim  = PolyBrushSelecao.obter_texto(:hud_diametro, {:diam => @diameter_mm.to_i})\r\n        [mode, dim]\r\n      end\r\n\r\n      def is_ctrl_key?(key) key == 17 end \r\n      def ctrl_down?(flags) (flags & COPY_MODIFIER_KEY) == COPY_MODIFIER_KEY end\r\n\r\n      # ---------- Tool API ----------\r\n      def activate\r\n        Sketchup.status_text = PolyBrushSelecao.obter_texto(:status_text)\r\n      end\r\n\r\n      def deactivate(view); view.invalidate; end\r\n\r\n      def onMouseMove(flags, x, y, view)\r\n        @cursor_pt = pick_on_surface(x, y, view)\r\n        if @dragging\r\n          apply_brush_at(@cursor_pt)\r\n        end\r\n        view.invalidate\r\n      end\r\n\r\n      def onLButtonDown(flags, x, y, view)\r\n        @dragging = true\r\n        begin_stroke\r\n        @cursor_pt = pick_on_surface(x, y, view)\r\n        apply_brush_at(@cursor_pt)\r\n        view.invalidate\r\n      end\r\n\r\n      def onLButtonUp(flags, x, y, view)\r\n        @dragging = false\r\n        commit_stroke\r\n        view.invalidate\r\n      end\r\n\r\n      def onKeyDown(key, repeat, flags, view)\r\n        if key == 82 && (flags & SHIFT_MODIFIER_KEY) == SHIFT_MODIFIER_KEY # 'R'\r\n          build_uv_cache(@radius)\r\n          UI.beep\r\n          view.invalidate\r\n          return\r\n        end\r\n\r\n        if (is_ctrl_key?(key) || ctrl_down?(flags)) && !@ctrl_prev\r\n          @mode_remove = !@mode_remove\r\n          @ctrl_prev = true\r\n          view.invalidate\r\n        end\r\n      end\r\n\r\n      def onKeyUp(key, repeat, flags, view)\r\n        @ctrl_prev = false unless ctrl_down?(flags)\r\n      end\r\n\r\n      def onCancel(reason, view)\r\n        @dragging = false\r\n        cancel_stroke\r\n        view.invalidate\r\n      end\r\n\r\n      def onUserText(text, view)\r\n        str = text.to_s.strip\r\n        return if str.empty?\r\n        len = if str =~ /[a-zA-Z]/\r\n                begin\r\n                  str.to_l\r\n                rescue\r\n                  nil\r\n                end\r\n              else\r\n                (str.to_f).mm\r\n              end\r\n\r\n        return unless len && len > 0.0\r\n        @diameter_mm = len.to_mm\r\n        @radius      = len / 2.0\r\n        build_uv_cache(@radius)\r\n        view.invalidate\r\n      end\r\n\r\n      def draw(view)\r\n        if @cursor_pt\r\n          r = @radius.to_f\r\n          pts = circle_points(@cursor_pt, r, 72)\r\n          view.line_stipple  = \"\"\r\n          view.line_width    = 2\r\n          view.drawing_color = @mode_remove ? Sketchup::Color.new(220, 60, 60) : Sketchup::Color.new(60, 180, 60)\r\n          view.draw(GL_LINE_LOOP, pts)\r\n\r\n          cpts = circle_points(@cursor_pt, [r * 0.025, 2.mm.to_f].max, 24)\r\n          view.line_width = 1\r\n          view.drawing_color = Sketchup::Color.new(40, 40, 40)\r\n          view.draw(GL_LINE_LOOP, cpts)\r\n\r\n          scr = view.screen_coords(@cursor_pt)\r\n          y = scr.y + 18\r\n          hud_lines.each do |txt|\r\n            view.draw_text(Geom::Point3d.new(scr.x + 12, y, 0), txt)\r\n            y += 16\r\n          end\r\n        end\r\n\r\n        return unless @dragging && !@stroke_painted.empty?\r\n        view.line_width = 1\r\n        view.drawing_color = Sketchup::Color.new(30, 150, 240)\r\n        @stroke_painted.each do |pid|\r\n          f = @pid_to_face[pid]\r\n          next unless f && f.valid?\r\n          edges = f.outer_loop.edges\r\n          pts = []\r\n          edges.each do |e|\r\n            pts << e.start.position\r\n            pts << e.end.position\r\n          end\r\n          view.draw(GL_LINES, pts) unless pts.empty?\r\n        end\r\n      end\r\n\r\n      def getExtents\r\n        bb = Geom::BoundingBox.new\r\n        if @cursor_pt\r\n          r = @radius.to_f\r\n          xoff = scale_vec(@px, r)\r\n          yoff = scale_vec(@py, r)\r\n          bb.add(@cursor_pt.offset(xoff + yoff))\r\n          bb.add(@cursor_pt.offset(xoff - yoff))\r\n          bb.add(@cursor_pt.offset(scale_vec(@px, -r) + yoff))\r\n          bb.add(@cursor_pt.offset(scale_vec(@px, -r) + scale_vec(@py, -r)))\r\n        end\r\n        bb\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      Sketchup.active_model.tools.push_tool(Tool.new)\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::PolyBrushSelecao.executar"
    },
    "enabled": false,
    "execute": true
  }
]