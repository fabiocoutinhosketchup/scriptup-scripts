[
  {
    "id": "suavizar-segmentos-curvos-tcbdn",
    "title": {
      "pt": "Suavizar Segmentos Curvos",
      "en": "Suavizar Segmentos Curvos",
      "es": "Suavizar Segmentos Curvos"
    },
    "author": "Fábio Coutinho",
    "version": "0.5",
    "description": {
      "pt": "Adiciona segmentos em sequência de arestas (curva) para tornar mais suave.",
      "en": "Adiciona segmentos em sequência de arestas (curva) para tornar mais suave.",
      "es": "Adiciona segmentos em sequência de arestas (curva) para tornar mais suave."
    },
    "keywords": {
      "pt": [
        "suaviza curva"
      ],
      "en": [
        "suaviza curva"
      ],
      "es": [
        "suaviza curva"
      ]
    },
    "code": {
      "pt": "require 'sketchup.rb'\r\n\r\nclass SmoothPolyTool\r\n  \r\n  def initialize\r\n    @model = Sketchup.active_model\r\n    @selection = @model.selection\r\n    @view = @model.active_view\r\n    \r\n    @density_multiplier = 1\r\n    @is_loop = false \r\n    \r\n    # Coleta dados iniciais\r\n    @ordered_vertices = get_ordered_vertices(@selection)\r\n    \r\n    if @ordered_vertices.length < 2\r\n      UI.messagebox(\"Selecione uma sequência de arestas conectadas primeiro.\")\r\n      @model.select_tool(nil)\r\n      return\r\n    end\r\n\r\n    @original_segment_count = @is_loop ? @ordered_vertices.length : @ordered_vertices.length - 1\r\n    calculate_distribution_metrics\r\n\r\n    @spline_points = []\r\n    calculate_spline\r\n    \r\n    create_dialog\r\n  end\r\n\r\n  def activate\r\n    @view.invalidate\r\n    update_status\r\n  end\r\n\r\n  # Chamado quando a ferramenta é desativada (ex: usuário trocou de ferramenta ou fechou a janela)\r\n  def deactivate(view)\r\n    # Fecha a janela se ela ainda estiver aberta\r\n    if @dialog && @dialog.visible?\r\n      @dialog.close \r\n    end\r\n    @view.invalidate\r\n  end\r\n\r\n  def draw(view)\r\n    # 1. Caminho Laranja\r\n    if @spline_points && @spline_points.size > 1\r\n      view.line_width = 3\r\n      view.line_stipple = \"\" \r\n      view.drawing_color = \"orange\"\r\n      mode = @is_loop ? GL_LINE_LOOP : GL_LINE_STRIP\r\n      view.draw(mode, @spline_points)\r\n    end\r\n\r\n    # 2. Nós Vermelhos\r\n    if @spline_points && !@spline_points.empty?\r\n      if view.respond_to?(:draw_points)\r\n        view.draw_points(@spline_points, 8, 2, \"red\") \r\n      else\r\n        view.drawing_color = \"red\"\r\n        view.point_size = 8 if view.respond_to?(:point_size=)\r\n        view.draw(GL_POINTS, @spline_points)\r\n      end\r\n    end\r\n  end\r\n\r\n  # --- UI ---\r\n  def create_dialog\r\n    if defined?(UI::HtmlDialog)\r\n      @dialog = UI::HtmlDialog.new({\r\n        :dialog_title => \"Suavizar (Loop & Adaptativo)\",\r\n        :preferences_key => \"com.example.smooth_poly_final\",\r\n        :scrollable => false,\r\n        :resizable => false,\r\n        :width => 320,\r\n        :height => 260, \r\n        :style => UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n      \r\n      # --- CORREÇÃO AQUI: Detecta o fechamento da janela (botão X) ---\r\n      @dialog.set_on_closed {\r\n        # Força a saída da ferramenta selecionando 'nil' (Select Tool)\r\n        Sketchup.active_model.select_tool(nil)\r\n      }\r\n      # ---------------------------------------------------------------\r\n      \r\n    else\r\n      @dialog = UI::WebDialog.new(\"Suavizar\", false, \"SmoothPolyFinal\", 320, 260, 100, 100, true)\r\n      # WebDialog antigo não tem um set_on_closed confiável igual ao HtmlDialog,\r\n      # mas para versões modernas (2017+) o bloco acima resolve.\r\n    end\r\n\r\n    html_content = %{\r\n      <!DOCTYPE html>\r\n      <html>\r\n      <head>\r\n        <style>\r\n          body { font-family: 'Segoe UI', sans-serif; font-size: 12px; padding: 15px; background-color: #f5f5f5; color: #333; overflow: hidden; }\r\n          .container { display: flex; flex-direction: column; gap: 12px; }\r\n          .header { display: flex; justify-content: space-between; align-items: center; }\r\n          label { font-weight: 600; font-size: 13px; }\r\n          input[type=range] { width: 100%; cursor: pointer; }\r\n          .val-display { \r\n            background: #fff; border: 1px solid #ccc; padding: 2px 8px; \r\n            border-radius: 4px; font-weight: bold; color: #E65100; min-width: 30px; text-align: center;\r\n          }\r\n          button { \r\n            padding: 10px; cursor: pointer; background: #2196F3; color: white; \r\n            border: none; border-radius: 4px; font-weight: bold; font-size: 13px;\r\n            text-transform: uppercase; letter-spacing: 0.5px; transition: background 0.2s; margin-top: 5px;\r\n          }\r\n          button:hover { background: #1976D2; }\r\n          .note { font-size: 11px; color: #666; font-style: italic; line-height: 1.3; }\r\n          .tag { font-size: 10px; background: #4CAF50; color: white; padding: 2px 5px; border-radius: 3px; }\r\n        </style>\r\n      </head>\r\n      <body>\r\n        <div class=\"container\">\r\n          <div class=\"header\">\r\n            <label>Densidade:</label>\r\n            <div class=\"val-display\">x<span id=\"val\">1</span></div>\r\n          </div>\r\n          \r\n          <input type=\"range\" id=\"slider\" min=\"1\" max=\"10\" step=\"1\" value=\"1\" oninput=\"updateVal(this.value)\">\r\n          \r\n          <div class=\"note\">\r\n            <span id=\"loop-msg\" style=\"display:none;\" class=\"tag\">LOOP DETECTADO</span><br>\r\n            Ajuste a densidade. A distribuição é adaptativa (foca em curvas) e contínua.\r\n          </div>\r\n\r\n          <button onclick=\"sendApply()\">Concluir (Aplicar)</button>\r\n        </div>\r\n        <script>\r\n          function updateVal(val) {\r\n            document.getElementById('val').innerText = val;\r\n            if (window.sketchup) { sketchup.on_slide(val); } \r\n            else { window.location = 'skp:on_slide@' + val; }\r\n          }\r\n          \r\n          function sendApply() {\r\n            if (window.sketchup) { sketchup.on_apply(); } \r\n            else { window.location = 'skp:on_apply'; }\r\n          }\r\n\r\n          function setLoopStatus(isLoop) {\r\n             if(isLoop) document.getElementById('loop-msg').style.display = 'inline-block';\r\n          }\r\n        </script>\r\n      </body>\r\n      </html>\r\n    }\r\n\r\n    @dialog.set_html(html_content)\r\n    \r\n    @dialog.add_action_callback(\"on_slide\") { |_, val|\r\n      @density_multiplier = val.to_i\r\n      calculate_spline\r\n      @view.invalidate\r\n    }\r\n\r\n    @dialog.add_action_callback(\"on_apply\") { \r\n      commit_geometry\r\n      # Ao selecionar nil aqui, o método deactivate será chamado, fechando a janela\r\n      @model.select_tool(nil)\r\n    }\r\n\r\n    @dialog.add_action_callback(\"exec_js\") { |_, js| @dialog.execute_script(js) }\r\n    \r\n    if @dialog.respond_to?(:center)\r\n      @dialog.center\r\n      @dialog.show\r\n    else\r\n      @dialog.show\r\n    end\r\n\r\n    UI.start_timer(0.5, false) { \r\n      @dialog.execute_script(\"setLoopStatus(#{@is_loop});\") if @dialog.visible?\r\n    }\r\n  end\r\n\r\n  # --- Lógica Matemática ---\r\n\r\n  def get_neighbors(i, points)\r\n    n = points.length\r\n    if @is_loop\r\n      p0 = points[(i - 1) % n]\r\n      p1 = points[i]\r\n      p2 = points[(i + 1) % n]\r\n      p3 = points[(i + 2) % n]\r\n    else\r\n      p0 = i == 0 ? points[0] : points[i-1]\r\n      p1 = points[i]\r\n      p2 = (i+1 >= n) ? points[n-1] : points[i+1]\r\n      p3 = (i+2 >= n) ? points[n-1] : points[i+2]\r\n    end\r\n    return p0, p1, p2, p3\r\n  end\r\n\r\n  def calculate_distribution_metrics\r\n    points = @ordered_vertices\r\n    @segment_weights = []\r\n    total_w = 0.0\r\n    limit = @is_loop ? points.length : points.length - 1\r\n\r\n    (0...limit).each do |i|\r\n      p0, p1, p2, p3 = get_neighbors(i, points)\r\n      len = p1.distance(p2)\r\n      \r\n      v_prev = p1 - p0\r\n      v_curr = p2 - p1\r\n      v_next = p3 - p2\r\n\r\n      angle_start = (v_prev.length > 0 && v_curr.length > 0) ? v_prev.angle_between(v_curr) : 0\r\n      angle_end   = (v_curr.length > 0 && v_next.length > 0) ? v_curr.angle_between(v_next) : 0\r\n      \r\n      avg_curvature = (angle_start + angle_end) / 2.0\r\n      curvature_factor = 1.0 + (avg_curvature * 3.0)\r\n\r\n      weighted_len = len * curvature_factor\r\n      @segment_weights << weighted_len\r\n      total_w += weighted_len\r\n    end\r\n    @total_weighted_length = total_w\r\n  end\r\n\r\n  def calculate_spline\r\n    return if @ordered_vertices.empty?\r\n    points = @ordered_vertices\r\n    @spline_points = []\r\n    \r\n    target_total_segments = [(@original_segment_count * @density_multiplier).round, 1].max\r\n    points_accumulator = 0.0\r\n    limit = @is_loop ? points.length : points.length - 1\r\n\r\n    (0...limit).each do |i|\r\n      p0, p1, p2, p3 = get_neighbors(i, points)\r\n      @spline_points << p1\r\n      \r\n      weighted_len = @segment_weights[i]\r\n      ratio = (@total_weighted_length > 0) ? (weighted_len / @total_weighted_length) : 0\r\n\r\n      exact_steps = ratio * target_total_segments\r\n      points_accumulator += exact_steps\r\n      \r\n      steps_to_draw = points_accumulator.floor\r\n      points_accumulator -= steps_to_draw\r\n\r\n      steps_final = steps_to_draw + 1\r\n\r\n      (1...steps_final).each do |t_step|\r\n        t = t_step.to_f / steps_final\r\n        @spline_points << catmull_rom(p0, p1, p2, p3, t)\r\n      end\r\n    end\r\n    \r\n    if @is_loop\r\n      @spline_points << @spline_points.first\r\n    else\r\n      @spline_points << points.last\r\n    end\r\n  end\r\n\r\n  def catmull_rom(p0, p1, p2, p3, t)\r\n    t2 = t * t\r\n    t3 = t2 * t\r\n    x = 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * t + (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 + (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3)\r\n    y = 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3)\r\n    z = 0.5 * ((2 * p1.z) + (-p0.z + p2.z) * t + (2 * p0.z - 5 * p1.z + 4 * p2.z - p3.z) * t2 + (-p0.z + 3 * p1.z - 3 * p2.z + p3.z) * t3)\r\n    Geom::Point3d.new(x, y, z)\r\n  end\r\n\r\n  def commit_geometry\r\n    edges_to_delete = @selection.grep(Sketchup::Edge)\r\n    return if edges_to_delete.empty?\r\n    \r\n    @model.start_operation(\"Suavizar (Loop)\", true)\r\n    @model.active_entities.erase_entities(edges_to_delete)\r\n    if @spline_points.size > 1\r\n      @model.active_entities.add_curve(@spline_points)\r\n    end\r\n    @model.commit_operation\r\n    @spline_points = []\r\n  end\r\n\r\n  def get_ordered_vertices(selection)\r\n    edges = selection.grep(Sketchup::Edge)\r\n    return [] if edges.empty?\r\n\r\n    vertices = edges.map(&:vertices).flatten\r\n    counts = vertices.each_with_object(Hash.new(0)) { |v, h| h[v] += 1 }\r\n    \r\n    if counts.values.all? { |c| c == 2 }\r\n      @is_loop = true\r\n      start_vertex = edges.first.start \r\n    else\r\n      @is_loop = false\r\n      start_vertex = counts.key(1) \r\n    end\r\n    \r\n    start_vertex ||= edges.first.start \r\n\r\n    sorted_points = [start_vertex.position]\r\n    current_v = start_vertex\r\n    visited_edges = []\r\n    \r\n    while true\r\n      next_edge = current_v.edges.find { |e| edges.include?(e) && !visited_edges.include?(e) }\r\n      break unless next_edge\r\n      visited_edges << next_edge\r\n      other_v = next_edge.other_vertex(current_v)\r\n      if @is_loop && other_v == start_vertex\r\n        break\r\n      end\r\n      sorted_points << other_v.position\r\n      current_v = other_v\r\n    end\r\n\r\n    sorted_points\r\n  end\r\n  \r\n  def update_status\r\n     Sketchup.set_status_text(\"Suavizar: Loop = #{@is_loop ? 'Sim' : 'Não'}\")\r\n  end\r\nend\r\n\r\nSketchup.active_model.select_tool(SmoothPolyTool.new)",
      "en": "require 'sketchup.rb'\r\n\r\nclass SmoothPolyTool\r\n  \r\n  def initialize\r\n    @model = Sketchup.active_model\r\n    @selection = @model.selection\r\n    @view = @model.active_view\r\n    \r\n    @density_multiplier = 1\r\n    @is_loop = false \r\n    \r\n    # Coleta dados iniciais\r\n    @ordered_vertices = get_ordered_vertices(@selection)\r\n    \r\n    if @ordered_vertices.length < 2\r\n      UI.messagebox(\"Selecione uma sequência de arestas conectadas primeiro.\")\r\n      @model.select_tool(nil)\r\n      return\r\n    end\r\n\r\n    @original_segment_count = @is_loop ? @ordered_vertices.length : @ordered_vertices.length - 1\r\n    calculate_distribution_metrics\r\n\r\n    @spline_points = []\r\n    calculate_spline\r\n    \r\n    create_dialog\r\n  end\r\n\r\n  def activate\r\n    @view.invalidate\r\n    update_status\r\n  end\r\n\r\n  # Chamado quando a ferramenta é desativada (ex: usuário trocou de ferramenta ou fechou a janela)\r\n  def deactivate(view)\r\n    # Fecha a janela se ela ainda estiver aberta\r\n    if @dialog && @dialog.visible?\r\n      @dialog.close \r\n    end\r\n    @view.invalidate\r\n  end\r\n\r\n  def draw(view)\r\n    # 1. Caminho Laranja\r\n    if @spline_points && @spline_points.size > 1\r\n      view.line_width = 3\r\n      view.line_stipple = \"\" \r\n      view.drawing_color = \"orange\"\r\n      mode = @is_loop ? GL_LINE_LOOP : GL_LINE_STRIP\r\n      view.draw(mode, @spline_points)\r\n    end\r\n\r\n    # 2. Nós Vermelhos\r\n    if @spline_points && !@spline_points.empty?\r\n      if view.respond_to?(:draw_points)\r\n        view.draw_points(@spline_points, 8, 2, \"red\") \r\n      else\r\n        view.drawing_color = \"red\"\r\n        view.point_size = 8 if view.respond_to?(:point_size=)\r\n        view.draw(GL_POINTS, @spline_points)\r\n      end\r\n    end\r\n  end\r\n\r\n  # --- UI ---\r\n  def create_dialog\r\n    if defined?(UI::HtmlDialog)\r\n      @dialog = UI::HtmlDialog.new({\r\n        :dialog_title => \"Suavizar (Loop & Adaptativo)\",\r\n        :preferences_key => \"com.example.smooth_poly_final\",\r\n        :scrollable => false,\r\n        :resizable => false,\r\n        :width => 320,\r\n        :height => 260, \r\n        :style => UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n      \r\n      # --- CORREÇÃO AQUI: Detecta o fechamento da janela (botão X) ---\r\n      @dialog.set_on_closed {\r\n        # Força a saída da ferramenta selecionando 'nil' (Select Tool)\r\n        Sketchup.active_model.select_tool(nil)\r\n      }\r\n      # ---------------------------------------------------------------\r\n      \r\n    else\r\n      @dialog = UI::WebDialog.new(\"Suavizar\", false, \"SmoothPolyFinal\", 320, 260, 100, 100, true)\r\n      # WebDialog antigo não tem um set_on_closed confiável igual ao HtmlDialog,\r\n      # mas para versões modernas (2017+) o bloco acima resolve.\r\n    end\r\n\r\n    html_content = %{\r\n      <!DOCTYPE html>\r\n      <html>\r\n      <head>\r\n        <style>\r\n          body { font-family: 'Segoe UI', sans-serif; font-size: 12px; padding: 15px; background-color: #f5f5f5; color: #333; overflow: hidden; }\r\n          .container { display: flex; flex-direction: column; gap: 12px; }\r\n          .header { display: flex; justify-content: space-between; align-items: center; }\r\n          label { font-weight: 600; font-size: 13px; }\r\n          input[type=range] { width: 100%; cursor: pointer; }\r\n          .val-display { \r\n            background: #fff; border: 1px solid #ccc; padding: 2px 8px; \r\n            border-radius: 4px; font-weight: bold; color: #E65100; min-width: 30px; text-align: center;\r\n          }\r\n          button { \r\n            padding: 10px; cursor: pointer; background: #2196F3; color: white; \r\n            border: none; border-radius: 4px; font-weight: bold; font-size: 13px;\r\n            text-transform: uppercase; letter-spacing: 0.5px; transition: background 0.2s; margin-top: 5px;\r\n          }\r\n          button:hover { background: #1976D2; }\r\n          .note { font-size: 11px; color: #666; font-style: italic; line-height: 1.3; }\r\n          .tag { font-size: 10px; background: #4CAF50; color: white; padding: 2px 5px; border-radius: 3px; }\r\n        </style>\r\n      </head>\r\n      <body>\r\n        <div class=\"container\">\r\n          <div class=\"header\">\r\n            <label>Densidade:</label>\r\n            <div class=\"val-display\">x<span id=\"val\">1</span></div>\r\n          </div>\r\n          \r\n          <input type=\"range\" id=\"slider\" min=\"1\" max=\"10\" step=\"1\" value=\"1\" oninput=\"updateVal(this.value)\">\r\n          \r\n          <div class=\"note\">\r\n            <span id=\"loop-msg\" style=\"display:none;\" class=\"tag\">LOOP DETECTADO</span><br>\r\n            Ajuste a densidade. A distribuição é adaptativa (foca em curvas) e contínua.\r\n          </div>\r\n\r\n          <button onclick=\"sendApply()\">Concluir (Aplicar)</button>\r\n        </div>\r\n        <script>\r\n          function updateVal(val) {\r\n            document.getElementById('val').innerText = val;\r\n            if (window.sketchup) { sketchup.on_slide(val); } \r\n            else { window.location = 'skp:on_slide@' + val; }\r\n          }\r\n          \r\n          function sendApply() {\r\n            if (window.sketchup) { sketchup.on_apply(); } \r\n            else { window.location = 'skp:on_apply'; }\r\n          }\r\n\r\n          function setLoopStatus(isLoop) {\r\n             if(isLoop) document.getElementById('loop-msg').style.display = 'inline-block';\r\n          }\r\n        </script>\r\n      </body>\r\n      </html>\r\n    }\r\n\r\n    @dialog.set_html(html_content)\r\n    \r\n    @dialog.add_action_callback(\"on_slide\") { |_, val|\r\n      @density_multiplier = val.to_i\r\n      calculate_spline\r\n      @view.invalidate\r\n    }\r\n\r\n    @dialog.add_action_callback(\"on_apply\") { \r\n      commit_geometry\r\n      # Ao selecionar nil aqui, o método deactivate será chamado, fechando a janela\r\n      @model.select_tool(nil)\r\n    }\r\n\r\n    @dialog.add_action_callback(\"exec_js\") { |_, js| @dialog.execute_script(js) }\r\n    \r\n    if @dialog.respond_to?(:center)\r\n      @dialog.center\r\n      @dialog.show\r\n    else\r\n      @dialog.show\r\n    end\r\n\r\n    UI.start_timer(0.5, false) { \r\n      @dialog.execute_script(\"setLoopStatus(#{@is_loop});\") if @dialog.visible?\r\n    }\r\n  end\r\n\r\n  # --- Lógica Matemática ---\r\n\r\n  def get_neighbors(i, points)\r\n    n = points.length\r\n    if @is_loop\r\n      p0 = points[(i - 1) % n]\r\n      p1 = points[i]\r\n      p2 = points[(i + 1) % n]\r\n      p3 = points[(i + 2) % n]\r\n    else\r\n      p0 = i == 0 ? points[0] : points[i-1]\r\n      p1 = points[i]\r\n      p2 = (i+1 >= n) ? points[n-1] : points[i+1]\r\n      p3 = (i+2 >= n) ? points[n-1] : points[i+2]\r\n    end\r\n    return p0, p1, p2, p3\r\n  end\r\n\r\n  def calculate_distribution_metrics\r\n    points = @ordered_vertices\r\n    @segment_weights = []\r\n    total_w = 0.0\r\n    limit = @is_loop ? points.length : points.length - 1\r\n\r\n    (0...limit).each do |i|\r\n      p0, p1, p2, p3 = get_neighbors(i, points)\r\n      len = p1.distance(p2)\r\n      \r\n      v_prev = p1 - p0\r\n      v_curr = p2 - p1\r\n      v_next = p3 - p2\r\n\r\n      angle_start = (v_prev.length > 0 && v_curr.length > 0) ? v_prev.angle_between(v_curr) : 0\r\n      angle_end   = (v_curr.length > 0 && v_next.length > 0) ? v_curr.angle_between(v_next) : 0\r\n      \r\n      avg_curvature = (angle_start + angle_end) / 2.0\r\n      curvature_factor = 1.0 + (avg_curvature * 3.0)\r\n\r\n      weighted_len = len * curvature_factor\r\n      @segment_weights << weighted_len\r\n      total_w += weighted_len\r\n    end\r\n    @total_weighted_length = total_w\r\n  end\r\n\r\n  def calculate_spline\r\n    return if @ordered_vertices.empty?\r\n    points = @ordered_vertices\r\n    @spline_points = []\r\n    \r\n    target_total_segments = [(@original_segment_count * @density_multiplier).round, 1].max\r\n    points_accumulator = 0.0\r\n    limit = @is_loop ? points.length : points.length - 1\r\n\r\n    (0...limit).each do |i|\r\n      p0, p1, p2, p3 = get_neighbors(i, points)\r\n      @spline_points << p1\r\n      \r\n      weighted_len = @segment_weights[i]\r\n      ratio = (@total_weighted_length > 0) ? (weighted_len / @total_weighted_length) : 0\r\n\r\n      exact_steps = ratio * target_total_segments\r\n      points_accumulator += exact_steps\r\n      \r\n      steps_to_draw = points_accumulator.floor\r\n      points_accumulator -= steps_to_draw\r\n\r\n      steps_final = steps_to_draw + 1\r\n\r\n      (1...steps_final).each do |t_step|\r\n        t = t_step.to_f / steps_final\r\n        @spline_points << catmull_rom(p0, p1, p2, p3, t)\r\n      end\r\n    end\r\n    \r\n    if @is_loop\r\n      @spline_points << @spline_points.first\r\n    else\r\n      @spline_points << points.last\r\n    end\r\n  end\r\n\r\n  def catmull_rom(p0, p1, p2, p3, t)\r\n    t2 = t * t\r\n    t3 = t2 * t\r\n    x = 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * t + (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 + (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3)\r\n    y = 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3)\r\n    z = 0.5 * ((2 * p1.z) + (-p0.z + p2.z) * t + (2 * p0.z - 5 * p1.z + 4 * p2.z - p3.z) * t2 + (-p0.z + 3 * p1.z - 3 * p2.z + p3.z) * t3)\r\n    Geom::Point3d.new(x, y, z)\r\n  end\r\n\r\n  def commit_geometry\r\n    edges_to_delete = @selection.grep(Sketchup::Edge)\r\n    return if edges_to_delete.empty?\r\n    \r\n    @model.start_operation(\"Suavizar (Loop)\", true)\r\n    @model.active_entities.erase_entities(edges_to_delete)\r\n    if @spline_points.size > 1\r\n      @model.active_entities.add_curve(@spline_points)\r\n    end\r\n    @model.commit_operation\r\n    @spline_points = []\r\n  end\r\n\r\n  def get_ordered_vertices(selection)\r\n    edges = selection.grep(Sketchup::Edge)\r\n    return [] if edges.empty?\r\n\r\n    vertices = edges.map(&:vertices).flatten\r\n    counts = vertices.each_with_object(Hash.new(0)) { |v, h| h[v] += 1 }\r\n    \r\n    if counts.values.all? { |c| c == 2 }\r\n      @is_loop = true\r\n      start_vertex = edges.first.start \r\n    else\r\n      @is_loop = false\r\n      start_vertex = counts.key(1) \r\n    end\r\n    \r\n    start_vertex ||= edges.first.start \r\n\r\n    sorted_points = [start_vertex.position]\r\n    current_v = start_vertex\r\n    visited_edges = []\r\n    \r\n    while true\r\n      next_edge = current_v.edges.find { |e| edges.include?(e) && !visited_edges.include?(e) }\r\n      break unless next_edge\r\n      visited_edges << next_edge\r\n      other_v = next_edge.other_vertex(current_v)\r\n      if @is_loop && other_v == start_vertex\r\n        break\r\n      end\r\n      sorted_points << other_v.position\r\n      current_v = other_v\r\n    end\r\n\r\n    sorted_points\r\n  end\r\n  \r\n  def update_status\r\n     Sketchup.set_status_text(\"Suavizar: Loop = #{@is_loop ? 'Sim' : 'Não'}\")\r\n  end\r\nend\r\n\r\nSketchup.active_model.select_tool(SmoothPolyTool.new)",
      "es": "require 'sketchup.rb'\r\n\r\nclass SmoothPolyTool\r\n  \r\n  def initialize\r\n    @model = Sketchup.active_model\r\n    @selection = @model.selection\r\n    @view = @model.active_view\r\n    \r\n    @density_multiplier = 1\r\n    @is_loop = false \r\n    \r\n    # Coleta dados iniciais\r\n    @ordered_vertices = get_ordered_vertices(@selection)\r\n    \r\n    if @ordered_vertices.length < 2\r\n      UI.messagebox(\"Selecione uma sequência de arestas conectadas primeiro.\")\r\n      @model.select_tool(nil)\r\n      return\r\n    end\r\n\r\n    @original_segment_count = @is_loop ? @ordered_vertices.length : @ordered_vertices.length - 1\r\n    calculate_distribution_metrics\r\n\r\n    @spline_points = []\r\n    calculate_spline\r\n    \r\n    create_dialog\r\n  end\r\n\r\n  def activate\r\n    @view.invalidate\r\n    update_status\r\n  end\r\n\r\n  # Chamado quando a ferramenta é desativada (ex: usuário trocou de ferramenta ou fechou a janela)\r\n  def deactivate(view)\r\n    # Fecha a janela se ela ainda estiver aberta\r\n    if @dialog && @dialog.visible?\r\n      @dialog.close \r\n    end\r\n    @view.invalidate\r\n  end\r\n\r\n  def draw(view)\r\n    # 1. Caminho Laranja\r\n    if @spline_points && @spline_points.size > 1\r\n      view.line_width = 3\r\n      view.line_stipple = \"\" \r\n      view.drawing_color = \"orange\"\r\n      mode = @is_loop ? GL_LINE_LOOP : GL_LINE_STRIP\r\n      view.draw(mode, @spline_points)\r\n    end\r\n\r\n    # 2. Nós Vermelhos\r\n    if @spline_points && !@spline_points.empty?\r\n      if view.respond_to?(:draw_points)\r\n        view.draw_points(@spline_points, 8, 2, \"red\") \r\n      else\r\n        view.drawing_color = \"red\"\r\n        view.point_size = 8 if view.respond_to?(:point_size=)\r\n        view.draw(GL_POINTS, @spline_points)\r\n      end\r\n    end\r\n  end\r\n\r\n  # --- UI ---\r\n  def create_dialog\r\n    if defined?(UI::HtmlDialog)\r\n      @dialog = UI::HtmlDialog.new({\r\n        :dialog_title => \"Suavizar (Loop & Adaptativo)\",\r\n        :preferences_key => \"com.example.smooth_poly_final\",\r\n        :scrollable => false,\r\n        :resizable => false,\r\n        :width => 320,\r\n        :height => 260, \r\n        :style => UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n      \r\n      # --- CORREÇÃO AQUI: Detecta o fechamento da janela (botão X) ---\r\n      @dialog.set_on_closed {\r\n        # Força a saída da ferramenta selecionando 'nil' (Select Tool)\r\n        Sketchup.active_model.select_tool(nil)\r\n      }\r\n      # ---------------------------------------------------------------\r\n      \r\n    else\r\n      @dialog = UI::WebDialog.new(\"Suavizar\", false, \"SmoothPolyFinal\", 320, 260, 100, 100, true)\r\n      # WebDialog antigo não tem um set_on_closed confiável igual ao HtmlDialog,\r\n      # mas para versões modernas (2017+) o bloco acima resolve.\r\n    end\r\n\r\n    html_content = %{\r\n      <!DOCTYPE html>\r\n      <html>\r\n      <head>\r\n        <style>\r\n          body { font-family: 'Segoe UI', sans-serif; font-size: 12px; padding: 15px; background-color: #f5f5f5; color: #333; overflow: hidden; }\r\n          .container { display: flex; flex-direction: column; gap: 12px; }\r\n          .header { display: flex; justify-content: space-between; align-items: center; }\r\n          label { font-weight: 600; font-size: 13px; }\r\n          input[type=range] { width: 100%; cursor: pointer; }\r\n          .val-display { \r\n            background: #fff; border: 1px solid #ccc; padding: 2px 8px; \r\n            border-radius: 4px; font-weight: bold; color: #E65100; min-width: 30px; text-align: center;\r\n          }\r\n          button { \r\n            padding: 10px; cursor: pointer; background: #2196F3; color: white; \r\n            border: none; border-radius: 4px; font-weight: bold; font-size: 13px;\r\n            text-transform: uppercase; letter-spacing: 0.5px; transition: background 0.2s; margin-top: 5px;\r\n          }\r\n          button:hover { background: #1976D2; }\r\n          .note { font-size: 11px; color: #666; font-style: italic; line-height: 1.3; }\r\n          .tag { font-size: 10px; background: #4CAF50; color: white; padding: 2px 5px; border-radius: 3px; }\r\n        </style>\r\n      </head>\r\n      <body>\r\n        <div class=\"container\">\r\n          <div class=\"header\">\r\n            <label>Densidade:</label>\r\n            <div class=\"val-display\">x<span id=\"val\">1</span></div>\r\n          </div>\r\n          \r\n          <input type=\"range\" id=\"slider\" min=\"1\" max=\"10\" step=\"1\" value=\"1\" oninput=\"updateVal(this.value)\">\r\n          \r\n          <div class=\"note\">\r\n            <span id=\"loop-msg\" style=\"display:none;\" class=\"tag\">LOOP DETECTADO</span><br>\r\n            Ajuste a densidade. A distribuição é adaptativa (foca em curvas) e contínua.\r\n          </div>\r\n\r\n          <button onclick=\"sendApply()\">Concluir (Aplicar)</button>\r\n        </div>\r\n        <script>\r\n          function updateVal(val) {\r\n            document.getElementById('val').innerText = val;\r\n            if (window.sketchup) { sketchup.on_slide(val); } \r\n            else { window.location = 'skp:on_slide@' + val; }\r\n          }\r\n          \r\n          function sendApply() {\r\n            if (window.sketchup) { sketchup.on_apply(); } \r\n            else { window.location = 'skp:on_apply'; }\r\n          }\r\n\r\n          function setLoopStatus(isLoop) {\r\n             if(isLoop) document.getElementById('loop-msg').style.display = 'inline-block';\r\n          }\r\n        </script>\r\n      </body>\r\n      </html>\r\n    }\r\n\r\n    @dialog.set_html(html_content)\r\n    \r\n    @dialog.add_action_callback(\"on_slide\") { |_, val|\r\n      @density_multiplier = val.to_i\r\n      calculate_spline\r\n      @view.invalidate\r\n    }\r\n\r\n    @dialog.add_action_callback(\"on_apply\") { \r\n      commit_geometry\r\n      # Ao selecionar nil aqui, o método deactivate será chamado, fechando a janela\r\n      @model.select_tool(nil)\r\n    }\r\n\r\n    @dialog.add_action_callback(\"exec_js\") { |_, js| @dialog.execute_script(js) }\r\n    \r\n    if @dialog.respond_to?(:center)\r\n      @dialog.center\r\n      @dialog.show\r\n    else\r\n      @dialog.show\r\n    end\r\n\r\n    UI.start_timer(0.5, false) { \r\n      @dialog.execute_script(\"setLoopStatus(#{@is_loop});\") if @dialog.visible?\r\n    }\r\n  end\r\n\r\n  # --- Lógica Matemática ---\r\n\r\n  def get_neighbors(i, points)\r\n    n = points.length\r\n    if @is_loop\r\n      p0 = points[(i - 1) % n]\r\n      p1 = points[i]\r\n      p2 = points[(i + 1) % n]\r\n      p3 = points[(i + 2) % n]\r\n    else\r\n      p0 = i == 0 ? points[0] : points[i-1]\r\n      p1 = points[i]\r\n      p2 = (i+1 >= n) ? points[n-1] : points[i+1]\r\n      p3 = (i+2 >= n) ? points[n-1] : points[i+2]\r\n    end\r\n    return p0, p1, p2, p3\r\n  end\r\n\r\n  def calculate_distribution_metrics\r\n    points = @ordered_vertices\r\n    @segment_weights = []\r\n    total_w = 0.0\r\n    limit = @is_loop ? points.length : points.length - 1\r\n\r\n    (0...limit).each do |i|\r\n      p0, p1, p2, p3 = get_neighbors(i, points)\r\n      len = p1.distance(p2)\r\n      \r\n      v_prev = p1 - p0\r\n      v_curr = p2 - p1\r\n      v_next = p3 - p2\r\n\r\n      angle_start = (v_prev.length > 0 && v_curr.length > 0) ? v_prev.angle_between(v_curr) : 0\r\n      angle_end   = (v_curr.length > 0 && v_next.length > 0) ? v_curr.angle_between(v_next) : 0\r\n      \r\n      avg_curvature = (angle_start + angle_end) / 2.0\r\n      curvature_factor = 1.0 + (avg_curvature * 3.0)\r\n\r\n      weighted_len = len * curvature_factor\r\n      @segment_weights << weighted_len\r\n      total_w += weighted_len\r\n    end\r\n    @total_weighted_length = total_w\r\n  end\r\n\r\n  def calculate_spline\r\n    return if @ordered_vertices.empty?\r\n    points = @ordered_vertices\r\n    @spline_points = []\r\n    \r\n    target_total_segments = [(@original_segment_count * @density_multiplier).round, 1].max\r\n    points_accumulator = 0.0\r\n    limit = @is_loop ? points.length : points.length - 1\r\n\r\n    (0...limit).each do |i|\r\n      p0, p1, p2, p3 = get_neighbors(i, points)\r\n      @spline_points << p1\r\n      \r\n      weighted_len = @segment_weights[i]\r\n      ratio = (@total_weighted_length > 0) ? (weighted_len / @total_weighted_length) : 0\r\n\r\n      exact_steps = ratio * target_total_segments\r\n      points_accumulator += exact_steps\r\n      \r\n      steps_to_draw = points_accumulator.floor\r\n      points_accumulator -= steps_to_draw\r\n\r\n      steps_final = steps_to_draw + 1\r\n\r\n      (1...steps_final).each do |t_step|\r\n        t = t_step.to_f / steps_final\r\n        @spline_points << catmull_rom(p0, p1, p2, p3, t)\r\n      end\r\n    end\r\n    \r\n    if @is_loop\r\n      @spline_points << @spline_points.first\r\n    else\r\n      @spline_points << points.last\r\n    end\r\n  end\r\n\r\n  def catmull_rom(p0, p1, p2, p3, t)\r\n    t2 = t * t\r\n    t3 = t2 * t\r\n    x = 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * t + (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 + (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3)\r\n    y = 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3)\r\n    z = 0.5 * ((2 * p1.z) + (-p0.z + p2.z) * t + (2 * p0.z - 5 * p1.z + 4 * p2.z - p3.z) * t2 + (-p0.z + 3 * p1.z - 3 * p2.z + p3.z) * t3)\r\n    Geom::Point3d.new(x, y, z)\r\n  end\r\n\r\n  def commit_geometry\r\n    edges_to_delete = @selection.grep(Sketchup::Edge)\r\n    return if edges_to_delete.empty?\r\n    \r\n    @model.start_operation(\"Suavizar (Loop)\", true)\r\n    @model.active_entities.erase_entities(edges_to_delete)\r\n    if @spline_points.size > 1\r\n      @model.active_entities.add_curve(@spline_points)\r\n    end\r\n    @model.commit_operation\r\n    @spline_points = []\r\n  end\r\n\r\n  def get_ordered_vertices(selection)\r\n    edges = selection.grep(Sketchup::Edge)\r\n    return [] if edges.empty?\r\n\r\n    vertices = edges.map(&:vertices).flatten\r\n    counts = vertices.each_with_object(Hash.new(0)) { |v, h| h[v] += 1 }\r\n    \r\n    if counts.values.all? { |c| c == 2 }\r\n      @is_loop = true\r\n      start_vertex = edges.first.start \r\n    else\r\n      @is_loop = false\r\n      start_vertex = counts.key(1) \r\n    end\r\n    \r\n    start_vertex ||= edges.first.start \r\n\r\n    sorted_points = [start_vertex.position]\r\n    current_v = start_vertex\r\n    visited_edges = []\r\n    \r\n    while true\r\n      next_edge = current_v.edges.find { |e| edges.include?(e) && !visited_edges.include?(e) }\r\n      break unless next_edge\r\n      visited_edges << next_edge\r\n      other_v = next_edge.other_vertex(current_v)\r\n      if @is_loop && other_v == start_vertex\r\n        break\r\n      end\r\n      sorted_points << other_v.position\r\n      current_v = other_v\r\n    end\r\n\r\n    sorted_points\r\n  end\r\n  \r\n  def update_status\r\n     Sketchup.set_status_text(\"Suavizar: Loop = #{@is_loop ? 'Sim' : 'Não'}\")\r\n  end\r\nend\r\n\r\nSketchup.active_model.select_tool(SmoothPolyTool.new)"
    },
    "enabled": false,
    "execute": true,
    "video": "https://youtu.be/nd8rkwn6BlU?si=a7OmdvWuj5juB07S"
  },
  {
    "id": "cria-textura-a-partir-da-malha-tm3dj",
    "title": {
      "pt": "Cria Textura a Partir da Malha",
      "en": "Cria Textura a Partir da Malha",
      "es": "Cria Textura a Partir da Malha"
    },
    "author": "Fábio Coutinho",
    "version": "0.1",
    "description": {
      "pt": "Cria um material com textura a partir de uma malha plana desenhada com suas arestas e cores ou texturas aplicadas, para ser usada em outra face.",
      "en": "Cria um material com textura a partir de uma malha plana desenhada com suas arestas e cores ou texturas aplicadas, para ser usada em outra face.",
      "es": "Cria um material com textura a partir de uma malha plana desenhada com suas arestas e cores ou texturas aplicadas, para ser usada em outra face."
    },
    "keywords": {
      "pt": [
        "textura"
      ],
      "en": [
        "textura"
      ],
      "es": [
        "textura"
      ]
    },
    "code": {
      "pt": "# ============================================================\r\n# BAKE TEXTURE (MALHA -> NOVO MATERIAL) | SketchUp Ruby Console\r\n# Saída em BMP 32-bit (sem ImageRep vazio)\r\n# ============================================================\r\n\r\nrequire 'sketchup.rb'\r\nrequire 'tmpdir'\r\n\r\nObject.send(:remove_const, :PBD_BakeMeshTexture) if defined?(PBD_BakeMeshTexture)\r\n\r\nmodule PBD_BakeMeshTexture\r\n  extend self\r\n\r\n  DEFAULT_TEX_SIZE = 2048\r\n\r\n  def run(tex_size: DEFAULT_TEX_SIZE)\r\n    m = Sketchup.active_model\r\n    sel = m.selection\r\n    raise \"Selecione faces ou um grupo/componente contendo a malha.\" if sel.empty?\r\n\r\n    faces = collect_faces(sel)\r\n    raise \"Nenhuma face encontrada na seleção.\" if faces.empty?\r\n\r\n    # normal média (plano de projeção)\r\n    n = Geom::Vector3d.new(0,0,0)\r\n    faces.each { |f| n += f.normal }\r\n    n.length < 1e-9 ? (n = Geom::Vector3d.new(0,0,1)) : n.normalize!\r\n\r\n    ref = (n.parallel?(Geom::Vector3d.new(0,0,1)) ? Geom::Vector3d.new(1,0,0) : Geom::Vector3d.new(0,0,1))\r\n    xaxis = n * ref\r\n    xaxis.length < 1e-9 ? (xaxis = Geom::Vector3d.new(1,0,0)) : xaxis.normalize!\r\n    yaxis = n * xaxis\r\n    yaxis.normalize!\r\n\r\n    origin = faces[0].bounds.center\r\n    world_to_plane = Geom::Transformation.axes(origin, xaxis, yaxis, n).inverse\r\n\r\n    # bbox 2D projetado\r\n    bb2 = Geom::BoundingBox.new\r\n    faces.each do |f|\r\n      f.vertices.each do |v|\r\n        p = v.position.transform(world_to_plane)\r\n        bb2.add([p.x, p.y, 0])\r\n      end\r\n    end\r\n\r\n    minx = bb2.min.x\r\n    miny = bb2.min.y\r\n    maxx = bb2.max.x\r\n    maxy = bb2.max.y\r\n    w_real = (maxx - minx)\r\n    h_real = (maxy - miny)\r\n    raise \"BBOX inválido (malha degenerada).\" if w_real.abs < 1e-6 || h_real.abs < 1e-6\r\n\r\n    out_w = tex_size.to_i\r\n    out_h = [(tex_size * (h_real / w_real)).round, 1].max\r\n    out_h = [out_h, tex_size].min\r\n\r\n    # OUTPUT = buffer BGRA (BMP 32-bit)\r\n    out_buf = \"\\x00\" * (out_w * out_h * 4)\r\n\r\n    tex_cache = {}\r\n\r\n    faces.each do |face|\r\n      mat  = face.material\r\n      back = face.back_material\r\n      use_back = (mat.nil? && !back.nil?)\r\n      mat = back if use_back\r\n\r\n      tw = Sketchup.create_texture_writer\r\n      uvh = face.get_UVHelper(true, true, tw)\r\n\r\n      src_rep = nil\r\n      src_w = src_h = nil\r\n      is_textured = false\r\n\r\n      if mat && mat.texture && mat.texture.filename && !mat.texture.filename.empty?\r\n        path = mat.texture.filename\r\n        src_rep = (tex_cache[path] ||= begin\r\n          rep = Sketchup::ImageRep.new\r\n          rep.load_file(path)\r\n          rep\r\n        rescue\r\n          nil\r\n        end)\r\n        if src_rep\r\n          src_w = src_rep.width\r\n          src_h = src_rep.height\r\n          is_textured = true\r\n        end\r\n      end\r\n\r\n      face_color = (mat && mat.color) ? mat.color : Sketchup::Color.new(200,200,200)\r\n\r\n      mesh = face.mesh(0)\r\n      mesh.polygons.each do |poly|\r\n        idx = poly.map(&:abs)\r\n        next if idx.length < 3\r\n\r\n        v0 = idx[0]\r\n        (1..(idx.length-2)).each do |k|\r\n          v1 = idx[k]\r\n          v2 = idx[k+1]\r\n\r\n          p0 = mesh.point_at(v0).transform(world_to_plane)\r\n          p1 = mesh.point_at(v1).transform(world_to_plane)\r\n          p2 = mesh.point_at(v2).transform(world_to_plane)\r\n\r\n          a = plane_to_px(p0, minx, miny, w_real, h_real, out_w, out_h)\r\n          b = plane_to_px(p1, minx, miny, w_real, h_real, out_w, out_h)\r\n          c = plane_to_px(p2, minx, miny, w_real, h_real, out_w, out_h)\r\n\r\n          if is_textured\r\n            uv0 = use_back ? uvh.get_back_UVQ(mesh.point_at(v0)) : uvh.get_front_UVQ(mesh.point_at(v0))\r\n            uv1 = use_back ? uvh.get_back_UVQ(mesh.point_at(v1)) : uvh.get_front_UVQ(mesh.point_at(v1))\r\n            uv2 = use_back ? uvh.get_back_UVQ(mesh.point_at(v2)) : uvh.get_front_UVQ(mesh.point_at(v2))\r\n\r\n            t0 = uvq_to_uv_px(uv0, src_w, src_h)\r\n            t1 = uvq_to_uv_px(uv1, src_w, src_h)\r\n            t2 = uvq_to_uv_px(uv2, src_w, src_h)\r\n\r\n            raster_triangle_uv_buf!(out_buf, out_w, out_h, a,b,c, src_rep, src_w, src_h, t0,t1,t2)\r\n          else\r\n            raster_triangle_color_buf!(out_buf, out_w, out_h, a,b,c, face_color)\r\n          end\r\n        end\r\n      end\r\n    end\r\n\r\n    dir = Dir.tmpdir\r\n    ts = Time.now.strftime(\"%Y%m%d_%H%M%S\")\r\n    bmp_path = File.join(dir, \"baked_mesh_#{ts}.bmp\")\r\n    write_bmp_32(bmp_path, out_w, out_h, out_buf)\r\n\r\n    mats = m.materials\r\n    name = unique_mat_name(mats, \"Baked_Mesh_#{ts}\")\r\n    new_mat = mats.add(name)\r\n    new_mat.texture = bmp_path\r\n    new_mat.texture.size = [w_real, h_real]\r\n\r\n    UI.messagebox(\"Material criado:\\n#{name}\\nTextura:\\n#{bmp_path}\")\r\n    new_mat\r\n  rescue => e\r\n    UI.messagebox(\"Erro:\\n#{e.message}\")\r\n    nil\r\n  end\r\n\r\n  # ---------- util ----------\r\n\r\n  def collect_faces(selection)\r\n    faces = []\r\n    selection.each do |ent|\r\n      case ent\r\n      when Sketchup::Face\r\n        faces << ent\r\n      when Sketchup::Group, Sketchup::ComponentInstance\r\n        faces.concat(rec_faces_in_entities(ent.definition.entities))\r\n      end\r\n    end\r\n    faces.uniq\r\n  end\r\n\r\n  def rec_faces_in_entities(ents, out = [])\r\n    ents.each do |e|\r\n      if e.is_a?(Sketchup::Face)\r\n        out << e\r\n      elsif e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance)\r\n        rec_faces_in_entities(e.definition.entities, out)\r\n      end\r\n    end\r\n    out\r\n  end\r\n\r\n  def plane_to_px(p, minx, miny, w, h, out_w, out_h)\r\n    u = (p.x - minx) / w\r\n    v = (p.y - miny) / h\r\n    x = (u * (out_w - 1)).round\r\n    y = ((1.0 - v) * (out_h - 1)).round\r\n    [x, y]\r\n  end\r\n\r\n  def uvq_to_uv_px(uvq, sw, sh)\r\n    z = uvq.z.to_f\r\n    z = 1.0 if z.abs < 1e-9\r\n    u = uvq.x.to_f / z\r\n    v = uvq.y.to_f / z\r\n    x = (u % 1.0) * (sw - 1)\r\n    y = (1.0 - (v % 1.0)) * (sh - 1)\r\n    [x, y]\r\n  end\r\n\r\n  def unique_mat_name(mats, base)\r\n    n = base\r\n    i = 1\r\n    while mats[n]\r\n      i += 1\r\n      n = \"#{base}_#{i}\"\r\n    end\r\n    n\r\n  end\r\n\r\n  def clamp(v, lo, hi)\r\n    v < lo ? lo : (v > hi ? hi : v)\r\n  end\r\n\r\n  def barycentric(p, a, b, c)\r\n    px, py = p\r\n    ax, ay = a\r\n    bx, by = b\r\n    cx, cy = c\r\n    v0x = bx - ax; v0y = by - ay\r\n    v1x = cx - ax; v1y = cy - ay\r\n    v2x = px - ax; v2y = py - ay\r\n    d00 = v0x*v0x + v0y*v0y\r\n    d01 = v0x*v1x + v0y*v1y\r\n    d11 = v1x*v1x + v1y*v1y\r\n    d20 = v2x*v0x + v2y*v0y\r\n    d21 = v2x*v1x + v2y*v1y\r\n    denom = (d00 * d11 - d01 * d01)\r\n    return nil if denom.abs < 1e-9\r\n    v = (d11 * d20 - d01 * d21) / denom\r\n    w = (d00 * d21 - d01 * d20) / denom\r\n    u = 1.0 - v - w\r\n    [u, v, w]\r\n  end\r\n\r\n  def tri_bbox(a,b,c, w, h)\r\n    xs = [a[0], b[0], c[0]]\r\n    ys = [a[1], b[1], c[1]]\r\n    [clamp(xs.min, 0, w-1), clamp(ys.min, 0, h-1),\r\n     clamp(xs.max, 0, w-1), clamp(ys.max, 0, h-1)]\r\n  end\r\n\r\n  # OUTPUT buffer é BGRA (BMP)\r\n  def set_px_bgra!(buf, w, x, y, r, g, b, a=255)\r\n    i = (y*w + x) * 4\r\n    buf.setbyte(i,     b)\r\n    buf.setbyte(i + 1, g)\r\n    buf.setbyte(i + 2, r)\r\n    buf.setbyte(i + 3, a)\r\n  end\r\n\r\n  def raster_triangle_color_buf!(buf, w, h, a,b,c, color)\r\n    minx, miny, maxx, maxy = tri_bbox(a,b,c, w, h)\r\n    (miny..maxy).each do |y|\r\n      (minx..maxx).each do |x|\r\n        bc = barycentric([x+0.5, y+0.5], a, b, c)\r\n        next unless bc\r\n        u,v,wg = bc\r\n        next if u < -0.001 || v < -0.001 || wg < -0.001\r\n        set_px_bgra!(buf, w, x, y, color.red, color.green, color.blue, 255)\r\n      end\r\n    end\r\n  end\r\n\r\n  def raster_triangle_uv_buf!(buf, ow, oh, a,b,c, src, sw, sh, t0,t1,t2)\r\n    minx, miny, maxx, maxy = tri_bbox(a,b,c, ow, oh)\r\n    src_rows = {}\r\n\r\n    (miny..maxy).each do |y|\r\n      (minx..maxx).each do |x|\r\n        bc = barycentric([x+0.5, y+0.5], a, b, c)\r\n        next unless bc\r\n        u,v,wg = bc\r\n        next if u < -0.001 || v < -0.001 || wg < -0.001\r\n\r\n        tx = t0[0]*u + t1[0]*v + t2[0]*wg\r\n        ty = t0[1]*u + t1[1]*v + t2[1]*wg\r\n\r\n        sx = clamp(tx.round, 0, sw-1)\r\n        sy = clamp(ty.round, 0, sh-1)\r\n\r\n        row = (src_rows[sy] ||= src.get_row(0, sy))\r\n        si = sx * 4\r\n        r = row[si]\r\n        g = row[si+1]\r\n        b = row[si+2]\r\n        a_ = row[si+3]\r\n\r\n        set_px_bgra!(buf, ow, x, y, r, g, b, a_)\r\n      end\r\n    end\r\n  end\r\n\r\n  # BMP 32-bit top-down (altura negativa)\r\n  def write_bmp_32(path, w, h, bgra_buf)\r\n    bgra_buf = bgra_buf.b\r\n\r\n    file_header_size = 14\r\n    dib_header_size  = 40\r\n    pixel_bytes = w * h * 4\r\n    file_size = file_header_size + dib_header_size + pixel_bytes\r\n    offset = file_header_size + dib_header_size\r\n\r\n    fh = \"BM\".b\r\n    fh << [file_size].pack(\"V\")\r\n    fh << [0].pack(\"V\")\r\n    fh << [offset].pack(\"V\")\r\n\r\n    dib = \"\".b\r\n    dib << [dib_header_size].pack(\"V\")\r\n    dib << [w].pack(\"V\")\r\n    dib << [(-h)].pack(\"V\")  # top-down\r\n    dib << [1].pack(\"v\")     # planes\r\n    dib << [32].pack(\"v\")    # bpp\r\n    dib << [0].pack(\"V\")     # BI_RGB\r\n    dib << [pixel_bytes].pack(\"V\")\r\n    dib << [2835].pack(\"V\")\r\n    dib << [2835].pack(\"V\")\r\n    dib << [0].pack(\"V\")\r\n    dib << [0].pack(\"V\")\r\n\r\n    File.binwrite(path, fh + dib + bgra_buf)\r\n  end\r\nend\r\n\r\n# EXEC\r\nPBD_BakeMeshTexture.run(tex_size: 2048)",
      "en": "# ============================================================\r\n# BAKE TEXTURE (MALHA -> NOVO MATERIAL) | SketchUp Ruby Console\r\n# Saída em BMP 32-bit (sem ImageRep vazio)\r\n# ============================================================\r\n\r\nrequire 'sketchup.rb'\r\nrequire 'tmpdir'\r\n\r\nObject.send(:remove_const, :PBD_BakeMeshTexture) if defined?(PBD_BakeMeshTexture)\r\n\r\nmodule PBD_BakeMeshTexture\r\n  extend self\r\n\r\n  DEFAULT_TEX_SIZE = 2048\r\n\r\n  def run(tex_size: DEFAULT_TEX_SIZE)\r\n    m = Sketchup.active_model\r\n    sel = m.selection\r\n    raise \"Selecione faces ou um grupo/componente contendo a malha.\" if sel.empty?\r\n\r\n    faces = collect_faces(sel)\r\n    raise \"Nenhuma face encontrada na seleção.\" if faces.empty?\r\n\r\n    # normal média (plano de projeção)\r\n    n = Geom::Vector3d.new(0,0,0)\r\n    faces.each { |f| n += f.normal }\r\n    n.length < 1e-9 ? (n = Geom::Vector3d.new(0,0,1)) : n.normalize!\r\n\r\n    ref = (n.parallel?(Geom::Vector3d.new(0,0,1)) ? Geom::Vector3d.new(1,0,0) : Geom::Vector3d.new(0,0,1))\r\n    xaxis = n * ref\r\n    xaxis.length < 1e-9 ? (xaxis = Geom::Vector3d.new(1,0,0)) : xaxis.normalize!\r\n    yaxis = n * xaxis\r\n    yaxis.normalize!\r\n\r\n    origin = faces[0].bounds.center\r\n    world_to_plane = Geom::Transformation.axes(origin, xaxis, yaxis, n).inverse\r\n\r\n    # bbox 2D projetado\r\n    bb2 = Geom::BoundingBox.new\r\n    faces.each do |f|\r\n      f.vertices.each do |v|\r\n        p = v.position.transform(world_to_plane)\r\n        bb2.add([p.x, p.y, 0])\r\n      end\r\n    end\r\n\r\n    minx = bb2.min.x\r\n    miny = bb2.min.y\r\n    maxx = bb2.max.x\r\n    maxy = bb2.max.y\r\n    w_real = (maxx - minx)\r\n    h_real = (maxy - miny)\r\n    raise \"BBOX inválido (malha degenerada).\" if w_real.abs < 1e-6 || h_real.abs < 1e-6\r\n\r\n    out_w = tex_size.to_i\r\n    out_h = [(tex_size * (h_real / w_real)).round, 1].max\r\n    out_h = [out_h, tex_size].min\r\n\r\n    # OUTPUT = buffer BGRA (BMP 32-bit)\r\n    out_buf = \"\\x00\" * (out_w * out_h * 4)\r\n\r\n    tex_cache = {}\r\n\r\n    faces.each do |face|\r\n      mat  = face.material\r\n      back = face.back_material\r\n      use_back = (mat.nil? && !back.nil?)\r\n      mat = back if use_back\r\n\r\n      tw = Sketchup.create_texture_writer\r\n      uvh = face.get_UVHelper(true, true, tw)\r\n\r\n      src_rep = nil\r\n      src_w = src_h = nil\r\n      is_textured = false\r\n\r\n      if mat && mat.texture && mat.texture.filename && !mat.texture.filename.empty?\r\n        path = mat.texture.filename\r\n        src_rep = (tex_cache[path] ||= begin\r\n          rep = Sketchup::ImageRep.new\r\n          rep.load_file(path)\r\n          rep\r\n        rescue\r\n          nil\r\n        end)\r\n        if src_rep\r\n          src_w = src_rep.width\r\n          src_h = src_rep.height\r\n          is_textured = true\r\n        end\r\n      end\r\n\r\n      face_color = (mat && mat.color) ? mat.color : Sketchup::Color.new(200,200,200)\r\n\r\n      mesh = face.mesh(0)\r\n      mesh.polygons.each do |poly|\r\n        idx = poly.map(&:abs)\r\n        next if idx.length < 3\r\n\r\n        v0 = idx[0]\r\n        (1..(idx.length-2)).each do |k|\r\n          v1 = idx[k]\r\n          v2 = idx[k+1]\r\n\r\n          p0 = mesh.point_at(v0).transform(world_to_plane)\r\n          p1 = mesh.point_at(v1).transform(world_to_plane)\r\n          p2 = mesh.point_at(v2).transform(world_to_plane)\r\n\r\n          a = plane_to_px(p0, minx, miny, w_real, h_real, out_w, out_h)\r\n          b = plane_to_px(p1, minx, miny, w_real, h_real, out_w, out_h)\r\n          c = plane_to_px(p2, minx, miny, w_real, h_real, out_w, out_h)\r\n\r\n          if is_textured\r\n            uv0 = use_back ? uvh.get_back_UVQ(mesh.point_at(v0)) : uvh.get_front_UVQ(mesh.point_at(v0))\r\n            uv1 = use_back ? uvh.get_back_UVQ(mesh.point_at(v1)) : uvh.get_front_UVQ(mesh.point_at(v1))\r\n            uv2 = use_back ? uvh.get_back_UVQ(mesh.point_at(v2)) : uvh.get_front_UVQ(mesh.point_at(v2))\r\n\r\n            t0 = uvq_to_uv_px(uv0, src_w, src_h)\r\n            t1 = uvq_to_uv_px(uv1, src_w, src_h)\r\n            t2 = uvq_to_uv_px(uv2, src_w, src_h)\r\n\r\n            raster_triangle_uv_buf!(out_buf, out_w, out_h, a,b,c, src_rep, src_w, src_h, t0,t1,t2)\r\n          else\r\n            raster_triangle_color_buf!(out_buf, out_w, out_h, a,b,c, face_color)\r\n          end\r\n        end\r\n      end\r\n    end\r\n\r\n    dir = Dir.tmpdir\r\n    ts = Time.now.strftime(\"%Y%m%d_%H%M%S\")\r\n    bmp_path = File.join(dir, \"baked_mesh_#{ts}.bmp\")\r\n    write_bmp_32(bmp_path, out_w, out_h, out_buf)\r\n\r\n    mats = m.materials\r\n    name = unique_mat_name(mats, \"Baked_Mesh_#{ts}\")\r\n    new_mat = mats.add(name)\r\n    new_mat.texture = bmp_path\r\n    new_mat.texture.size = [w_real, h_real]\r\n\r\n    UI.messagebox(\"Material criado:\\n#{name}\\nTextura:\\n#{bmp_path}\")\r\n    new_mat\r\n  rescue => e\r\n    UI.messagebox(\"Erro:\\n#{e.message}\")\r\n    nil\r\n  end\r\n\r\n  # ---------- util ----------\r\n\r\n  def collect_faces(selection)\r\n    faces = []\r\n    selection.each do |ent|\r\n      case ent\r\n      when Sketchup::Face\r\n        faces << ent\r\n      when Sketchup::Group, Sketchup::ComponentInstance\r\n        faces.concat(rec_faces_in_entities(ent.definition.entities))\r\n      end\r\n    end\r\n    faces.uniq\r\n  end\r\n\r\n  def rec_faces_in_entities(ents, out = [])\r\n    ents.each do |e|\r\n      if e.is_a?(Sketchup::Face)\r\n        out << e\r\n      elsif e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance)\r\n        rec_faces_in_entities(e.definition.entities, out)\r\n      end\r\n    end\r\n    out\r\n  end\r\n\r\n  def plane_to_px(p, minx, miny, w, h, out_w, out_h)\r\n    u = (p.x - minx) / w\r\n    v = (p.y - miny) / h\r\n    x = (u * (out_w - 1)).round\r\n    y = ((1.0 - v) * (out_h - 1)).round\r\n    [x, y]\r\n  end\r\n\r\n  def uvq_to_uv_px(uvq, sw, sh)\r\n    z = uvq.z.to_f\r\n    z = 1.0 if z.abs < 1e-9\r\n    u = uvq.x.to_f / z\r\n    v = uvq.y.to_f / z\r\n    x = (u % 1.0) * (sw - 1)\r\n    y = (1.0 - (v % 1.0)) * (sh - 1)\r\n    [x, y]\r\n  end\r\n\r\n  def unique_mat_name(mats, base)\r\n    n = base\r\n    i = 1\r\n    while mats[n]\r\n      i += 1\r\n      n = \"#{base}_#{i}\"\r\n    end\r\n    n\r\n  end\r\n\r\n  def clamp(v, lo, hi)\r\n    v < lo ? lo : (v > hi ? hi : v)\r\n  end\r\n\r\n  def barycentric(p, a, b, c)\r\n    px, py = p\r\n    ax, ay = a\r\n    bx, by = b\r\n    cx, cy = c\r\n    v0x = bx - ax; v0y = by - ay\r\n    v1x = cx - ax; v1y = cy - ay\r\n    v2x = px - ax; v2y = py - ay\r\n    d00 = v0x*v0x + v0y*v0y\r\n    d01 = v0x*v1x + v0y*v1y\r\n    d11 = v1x*v1x + v1y*v1y\r\n    d20 = v2x*v0x + v2y*v0y\r\n    d21 = v2x*v1x + v2y*v1y\r\n    denom = (d00 * d11 - d01 * d01)\r\n    return nil if denom.abs < 1e-9\r\n    v = (d11 * d20 - d01 * d21) / denom\r\n    w = (d00 * d21 - d01 * d20) / denom\r\n    u = 1.0 - v - w\r\n    [u, v, w]\r\n  end\r\n\r\n  def tri_bbox(a,b,c, w, h)\r\n    xs = [a[0], b[0], c[0]]\r\n    ys = [a[1], b[1], c[1]]\r\n    [clamp(xs.min, 0, w-1), clamp(ys.min, 0, h-1),\r\n     clamp(xs.max, 0, w-1), clamp(ys.max, 0, h-1)]\r\n  end\r\n\r\n  # OUTPUT buffer é BGRA (BMP)\r\n  def set_px_bgra!(buf, w, x, y, r, g, b, a=255)\r\n    i = (y*w + x) * 4\r\n    buf.setbyte(i,     b)\r\n    buf.setbyte(i + 1, g)\r\n    buf.setbyte(i + 2, r)\r\n    buf.setbyte(i + 3, a)\r\n  end\r\n\r\n  def raster_triangle_color_buf!(buf, w, h, a,b,c, color)\r\n    minx, miny, maxx, maxy = tri_bbox(a,b,c, w, h)\r\n    (miny..maxy).each do |y|\r\n      (minx..maxx).each do |x|\r\n        bc = barycentric([x+0.5, y+0.5], a, b, c)\r\n        next unless bc\r\n        u,v,wg = bc\r\n        next if u < -0.001 || v < -0.001 || wg < -0.001\r\n        set_px_bgra!(buf, w, x, y, color.red, color.green, color.blue, 255)\r\n      end\r\n    end\r\n  end\r\n\r\n  def raster_triangle_uv_buf!(buf, ow, oh, a,b,c, src, sw, sh, t0,t1,t2)\r\n    minx, miny, maxx, maxy = tri_bbox(a,b,c, ow, oh)\r\n    src_rows = {}\r\n\r\n    (miny..maxy).each do |y|\r\n      (minx..maxx).each do |x|\r\n        bc = barycentric([x+0.5, y+0.5], a, b, c)\r\n        next unless bc\r\n        u,v,wg = bc\r\n        next if u < -0.001 || v < -0.001 || wg < -0.001\r\n\r\n        tx = t0[0]*u + t1[0]*v + t2[0]*wg\r\n        ty = t0[1]*u + t1[1]*v + t2[1]*wg\r\n\r\n        sx = clamp(tx.round, 0, sw-1)\r\n        sy = clamp(ty.round, 0, sh-1)\r\n\r\n        row = (src_rows[sy] ||= src.get_row(0, sy))\r\n        si = sx * 4\r\n        r = row[si]\r\n        g = row[si+1]\r\n        b = row[si+2]\r\n        a_ = row[si+3]\r\n\r\n        set_px_bgra!(buf, ow, x, y, r, g, b, a_)\r\n      end\r\n    end\r\n  end\r\n\r\n  # BMP 32-bit top-down (altura negativa)\r\n  def write_bmp_32(path, w, h, bgra_buf)\r\n    bgra_buf = bgra_buf.b\r\n\r\n    file_header_size = 14\r\n    dib_header_size  = 40\r\n    pixel_bytes = w * h * 4\r\n    file_size = file_header_size + dib_header_size + pixel_bytes\r\n    offset = file_header_size + dib_header_size\r\n\r\n    fh = \"BM\".b\r\n    fh << [file_size].pack(\"V\")\r\n    fh << [0].pack(\"V\")\r\n    fh << [offset].pack(\"V\")\r\n\r\n    dib = \"\".b\r\n    dib << [dib_header_size].pack(\"V\")\r\n    dib << [w].pack(\"V\")\r\n    dib << [(-h)].pack(\"V\")  # top-down\r\n    dib << [1].pack(\"v\")     # planes\r\n    dib << [32].pack(\"v\")    # bpp\r\n    dib << [0].pack(\"V\")     # BI_RGB\r\n    dib << [pixel_bytes].pack(\"V\")\r\n    dib << [2835].pack(\"V\")\r\n    dib << [2835].pack(\"V\")\r\n    dib << [0].pack(\"V\")\r\n    dib << [0].pack(\"V\")\r\n\r\n    File.binwrite(path, fh + dib + bgra_buf)\r\n  end\r\nend\r\n\r\n# EXEC\r\nPBD_BakeMeshTexture.run(tex_size: 2048)",
      "es": "# ============================================================\r\n# BAKE TEXTURE (MALHA -> NOVO MATERIAL) | SketchUp Ruby Console\r\n# Saída em BMP 32-bit (sem ImageRep vazio)\r\n# ============================================================\r\n\r\nrequire 'sketchup.rb'\r\nrequire 'tmpdir'\r\n\r\nObject.send(:remove_const, :PBD_BakeMeshTexture) if defined?(PBD_BakeMeshTexture)\r\n\r\nmodule PBD_BakeMeshTexture\r\n  extend self\r\n\r\n  DEFAULT_TEX_SIZE = 2048\r\n\r\n  def run(tex_size: DEFAULT_TEX_SIZE)\r\n    m = Sketchup.active_model\r\n    sel = m.selection\r\n    raise \"Selecione faces ou um grupo/componente contendo a malha.\" if sel.empty?\r\n\r\n    faces = collect_faces(sel)\r\n    raise \"Nenhuma face encontrada na seleção.\" if faces.empty?\r\n\r\n    # normal média (plano de projeção)\r\n    n = Geom::Vector3d.new(0,0,0)\r\n    faces.each { |f| n += f.normal }\r\n    n.length < 1e-9 ? (n = Geom::Vector3d.new(0,0,1)) : n.normalize!\r\n\r\n    ref = (n.parallel?(Geom::Vector3d.new(0,0,1)) ? Geom::Vector3d.new(1,0,0) : Geom::Vector3d.new(0,0,1))\r\n    xaxis = n * ref\r\n    xaxis.length < 1e-9 ? (xaxis = Geom::Vector3d.new(1,0,0)) : xaxis.normalize!\r\n    yaxis = n * xaxis\r\n    yaxis.normalize!\r\n\r\n    origin = faces[0].bounds.center\r\n    world_to_plane = Geom::Transformation.axes(origin, xaxis, yaxis, n).inverse\r\n\r\n    # bbox 2D projetado\r\n    bb2 = Geom::BoundingBox.new\r\n    faces.each do |f|\r\n      f.vertices.each do |v|\r\n        p = v.position.transform(world_to_plane)\r\n        bb2.add([p.x, p.y, 0])\r\n      end\r\n    end\r\n\r\n    minx = bb2.min.x\r\n    miny = bb2.min.y\r\n    maxx = bb2.max.x\r\n    maxy = bb2.max.y\r\n    w_real = (maxx - minx)\r\n    h_real = (maxy - miny)\r\n    raise \"BBOX inválido (malha degenerada).\" if w_real.abs < 1e-6 || h_real.abs < 1e-6\r\n\r\n    out_w = tex_size.to_i\r\n    out_h = [(tex_size * (h_real / w_real)).round, 1].max\r\n    out_h = [out_h, tex_size].min\r\n\r\n    # OUTPUT = buffer BGRA (BMP 32-bit)\r\n    out_buf = \"\\x00\" * (out_w * out_h * 4)\r\n\r\n    tex_cache = {}\r\n\r\n    faces.each do |face|\r\n      mat  = face.material\r\n      back = face.back_material\r\n      use_back = (mat.nil? && !back.nil?)\r\n      mat = back if use_back\r\n\r\n      tw = Sketchup.create_texture_writer\r\n      uvh = face.get_UVHelper(true, true, tw)\r\n\r\n      src_rep = nil\r\n      src_w = src_h = nil\r\n      is_textured = false\r\n\r\n      if mat && mat.texture && mat.texture.filename && !mat.texture.filename.empty?\r\n        path = mat.texture.filename\r\n        src_rep = (tex_cache[path] ||= begin\r\n          rep = Sketchup::ImageRep.new\r\n          rep.load_file(path)\r\n          rep\r\n        rescue\r\n          nil\r\n        end)\r\n        if src_rep\r\n          src_w = src_rep.width\r\n          src_h = src_rep.height\r\n          is_textured = true\r\n        end\r\n      end\r\n\r\n      face_color = (mat && mat.color) ? mat.color : Sketchup::Color.new(200,200,200)\r\n\r\n      mesh = face.mesh(0)\r\n      mesh.polygons.each do |poly|\r\n        idx = poly.map(&:abs)\r\n        next if idx.length < 3\r\n\r\n        v0 = idx[0]\r\n        (1..(idx.length-2)).each do |k|\r\n          v1 = idx[k]\r\n          v2 = idx[k+1]\r\n\r\n          p0 = mesh.point_at(v0).transform(world_to_plane)\r\n          p1 = mesh.point_at(v1).transform(world_to_plane)\r\n          p2 = mesh.point_at(v2).transform(world_to_plane)\r\n\r\n          a = plane_to_px(p0, minx, miny, w_real, h_real, out_w, out_h)\r\n          b = plane_to_px(p1, minx, miny, w_real, h_real, out_w, out_h)\r\n          c = plane_to_px(p2, minx, miny, w_real, h_real, out_w, out_h)\r\n\r\n          if is_textured\r\n            uv0 = use_back ? uvh.get_back_UVQ(mesh.point_at(v0)) : uvh.get_front_UVQ(mesh.point_at(v0))\r\n            uv1 = use_back ? uvh.get_back_UVQ(mesh.point_at(v1)) : uvh.get_front_UVQ(mesh.point_at(v1))\r\n            uv2 = use_back ? uvh.get_back_UVQ(mesh.point_at(v2)) : uvh.get_front_UVQ(mesh.point_at(v2))\r\n\r\n            t0 = uvq_to_uv_px(uv0, src_w, src_h)\r\n            t1 = uvq_to_uv_px(uv1, src_w, src_h)\r\n            t2 = uvq_to_uv_px(uv2, src_w, src_h)\r\n\r\n            raster_triangle_uv_buf!(out_buf, out_w, out_h, a,b,c, src_rep, src_w, src_h, t0,t1,t2)\r\n          else\r\n            raster_triangle_color_buf!(out_buf, out_w, out_h, a,b,c, face_color)\r\n          end\r\n        end\r\n      end\r\n    end\r\n\r\n    dir = Dir.tmpdir\r\n    ts = Time.now.strftime(\"%Y%m%d_%H%M%S\")\r\n    bmp_path = File.join(dir, \"baked_mesh_#{ts}.bmp\")\r\n    write_bmp_32(bmp_path, out_w, out_h, out_buf)\r\n\r\n    mats = m.materials\r\n    name = unique_mat_name(mats, \"Baked_Mesh_#{ts}\")\r\n    new_mat = mats.add(name)\r\n    new_mat.texture = bmp_path\r\n    new_mat.texture.size = [w_real, h_real]\r\n\r\n    UI.messagebox(\"Material criado:\\n#{name}\\nTextura:\\n#{bmp_path}\")\r\n    new_mat\r\n  rescue => e\r\n    UI.messagebox(\"Erro:\\n#{e.message}\")\r\n    nil\r\n  end\r\n\r\n  # ---------- util ----------\r\n\r\n  def collect_faces(selection)\r\n    faces = []\r\n    selection.each do |ent|\r\n      case ent\r\n      when Sketchup::Face\r\n        faces << ent\r\n      when Sketchup::Group, Sketchup::ComponentInstance\r\n        faces.concat(rec_faces_in_entities(ent.definition.entities))\r\n      end\r\n    end\r\n    faces.uniq\r\n  end\r\n\r\n  def rec_faces_in_entities(ents, out = [])\r\n    ents.each do |e|\r\n      if e.is_a?(Sketchup::Face)\r\n        out << e\r\n      elsif e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance)\r\n        rec_faces_in_entities(e.definition.entities, out)\r\n      end\r\n    end\r\n    out\r\n  end\r\n\r\n  def plane_to_px(p, minx, miny, w, h, out_w, out_h)\r\n    u = (p.x - minx) / w\r\n    v = (p.y - miny) / h\r\n    x = (u * (out_w - 1)).round\r\n    y = ((1.0 - v) * (out_h - 1)).round\r\n    [x, y]\r\n  end\r\n\r\n  def uvq_to_uv_px(uvq, sw, sh)\r\n    z = uvq.z.to_f\r\n    z = 1.0 if z.abs < 1e-9\r\n    u = uvq.x.to_f / z\r\n    v = uvq.y.to_f / z\r\n    x = (u % 1.0) * (sw - 1)\r\n    y = (1.0 - (v % 1.0)) * (sh - 1)\r\n    [x, y]\r\n  end\r\n\r\n  def unique_mat_name(mats, base)\r\n    n = base\r\n    i = 1\r\n    while mats[n]\r\n      i += 1\r\n      n = \"#{base}_#{i}\"\r\n    end\r\n    n\r\n  end\r\n\r\n  def clamp(v, lo, hi)\r\n    v < lo ? lo : (v > hi ? hi : v)\r\n  end\r\n\r\n  def barycentric(p, a, b, c)\r\n    px, py = p\r\n    ax, ay = a\r\n    bx, by = b\r\n    cx, cy = c\r\n    v0x = bx - ax; v0y = by - ay\r\n    v1x = cx - ax; v1y = cy - ay\r\n    v2x = px - ax; v2y = py - ay\r\n    d00 = v0x*v0x + v0y*v0y\r\n    d01 = v0x*v1x + v0y*v1y\r\n    d11 = v1x*v1x + v1y*v1y\r\n    d20 = v2x*v0x + v2y*v0y\r\n    d21 = v2x*v1x + v2y*v1y\r\n    denom = (d00 * d11 - d01 * d01)\r\n    return nil if denom.abs < 1e-9\r\n    v = (d11 * d20 - d01 * d21) / denom\r\n    w = (d00 * d21 - d01 * d20) / denom\r\n    u = 1.0 - v - w\r\n    [u, v, w]\r\n  end\r\n\r\n  def tri_bbox(a,b,c, w, h)\r\n    xs = [a[0], b[0], c[0]]\r\n    ys = [a[1], b[1], c[1]]\r\n    [clamp(xs.min, 0, w-1), clamp(ys.min, 0, h-1),\r\n     clamp(xs.max, 0, w-1), clamp(ys.max, 0, h-1)]\r\n  end\r\n\r\n  # OUTPUT buffer é BGRA (BMP)\r\n  def set_px_bgra!(buf, w, x, y, r, g, b, a=255)\r\n    i = (y*w + x) * 4\r\n    buf.setbyte(i,     b)\r\n    buf.setbyte(i + 1, g)\r\n    buf.setbyte(i + 2, r)\r\n    buf.setbyte(i + 3, a)\r\n  end\r\n\r\n  def raster_triangle_color_buf!(buf, w, h, a,b,c, color)\r\n    minx, miny, maxx, maxy = tri_bbox(a,b,c, w, h)\r\n    (miny..maxy).each do |y|\r\n      (minx..maxx).each do |x|\r\n        bc = barycentric([x+0.5, y+0.5], a, b, c)\r\n        next unless bc\r\n        u,v,wg = bc\r\n        next if u < -0.001 || v < -0.001 || wg < -0.001\r\n        set_px_bgra!(buf, w, x, y, color.red, color.green, color.blue, 255)\r\n      end\r\n    end\r\n  end\r\n\r\n  def raster_triangle_uv_buf!(buf, ow, oh, a,b,c, src, sw, sh, t0,t1,t2)\r\n    minx, miny, maxx, maxy = tri_bbox(a,b,c, ow, oh)\r\n    src_rows = {}\r\n\r\n    (miny..maxy).each do |y|\r\n      (minx..maxx).each do |x|\r\n        bc = barycentric([x+0.5, y+0.5], a, b, c)\r\n        next unless bc\r\n        u,v,wg = bc\r\n        next if u < -0.001 || v < -0.001 || wg < -0.001\r\n\r\n        tx = t0[0]*u + t1[0]*v + t2[0]*wg\r\n        ty = t0[1]*u + t1[1]*v + t2[1]*wg\r\n\r\n        sx = clamp(tx.round, 0, sw-1)\r\n        sy = clamp(ty.round, 0, sh-1)\r\n\r\n        row = (src_rows[sy] ||= src.get_row(0, sy))\r\n        si = sx * 4\r\n        r = row[si]\r\n        g = row[si+1]\r\n        b = row[si+2]\r\n        a_ = row[si+3]\r\n\r\n        set_px_bgra!(buf, ow, x, y, r, g, b, a_)\r\n      end\r\n    end\r\n  end\r\n\r\n  # BMP 32-bit top-down (altura negativa)\r\n  def write_bmp_32(path, w, h, bgra_buf)\r\n    bgra_buf = bgra_buf.b\r\n\r\n    file_header_size = 14\r\n    dib_header_size  = 40\r\n    pixel_bytes = w * h * 4\r\n    file_size = file_header_size + dib_header_size + pixel_bytes\r\n    offset = file_header_size + dib_header_size\r\n\r\n    fh = \"BM\".b\r\n    fh << [file_size].pack(\"V\")\r\n    fh << [0].pack(\"V\")\r\n    fh << [offset].pack(\"V\")\r\n\r\n    dib = \"\".b\r\n    dib << [dib_header_size].pack(\"V\")\r\n    dib << [w].pack(\"V\")\r\n    dib << [(-h)].pack(\"V\")  # top-down\r\n    dib << [1].pack(\"v\")     # planes\r\n    dib << [32].pack(\"v\")    # bpp\r\n    dib << [0].pack(\"V\")     # BI_RGB\r\n    dib << [pixel_bytes].pack(\"V\")\r\n    dib << [2835].pack(\"V\")\r\n    dib << [2835].pack(\"V\")\r\n    dib << [0].pack(\"V\")\r\n    dib << [0].pack(\"V\")\r\n\r\n    File.binwrite(path, fh + dib + bgra_buf)\r\n  end\r\nend\r\n\r\n# EXEC\r\nPBD_BakeMeshTexture.run(tex_size: 2048)"
    },
    "enabled": false,
    "execute": true,
    "video": "https://youtu.be/tRwWJqDDiHI?si=tlH2vhRPcEViTkec"
  },
  {
    "id": "explosao-radial-yx7fp",
    "title": {
      "pt": "Explosão Radial",
      "en": "Radial Explosion",
      "es": "Explosión radial"
    },
    "author": "Fábio Coutinho",
    "version": "1.2",
    "description": {
      "pt": "Permite simular uma explosão radial do elemento selecionado usando um slider.",
      "en": "Allows you to simulate a radial explosion of the selected element using a slider.",
      "es": "Le permite simular una explosión radial del elemento seleccionado mediante un control deslizante."
    },
    "keywords": {
      "pt": [
        "explosão"
      ],
      "en": [
        "explosion"
      ],
      "es": [
        "explosión"
      ]
    },
    "code": {
      "pt": "require 'sketchup.rb'\r\nrequire 'json'\r\n\r\nmodule ScriptUpComunidade\r\n  module ExplosaoRadialFinal\r\n    extend self\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao => \"Selecione apenas um grupo ou componente.\",\r\n        :op_explosao  => \"Explosão Visual\",\r\n        :op_restaurar => \"Restaurar Explosão\",\r\n        :titulo       => \"Explosão Visual Radial\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao => \"Select only one group or component.\",\r\n        :op_explosao  => \"Visual Explosion\",\r\n        :op_restaurar => \"Restore Explosion\",\r\n        :titulo       => \"Radial Visual Explosion\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao => \"Seleccione solo un grupo o componente.\",\r\n        :op_explosao  => \"Explosión Visual\",\r\n        :op_restaurar => \"Restaurar Explosión\",\r\n        :titulo       => \"Explosión Visual Radial\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n      unless selection.length == 1 && (selection.first.is_a?(Sketchup::Group) || selection.first.is_a?(Sketchup::ComponentInstance))\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n\r\n      @root = selection.first\r\n      @root_tr = @root.transformation\r\n      @root_center = @root.bounds.center.transform(@root_tr)\r\n\r\n      @entities_data = []\r\n      collect_descendants(@root, @root_tr)\r\n\r\n      # Calcula centro médio original dos componentes internos\r\n      centros = @entities_data.map { |data| data[:original_center] }\r\n\r\n      avg_x = centros.map(&:x).sum / centros.size\r\n      avg_y = centros.map(&:y).sum / centros.size\r\n      avg_z = centros.map(&:z).sum / centros.size\r\n\r\n      @original_avg_center = Geom::Point3d.new(avg_x, avg_y, avg_z)\r\n\r\n      show_dialog\r\n    end\r\n\r\n    def collect_descendants(parent, parent_tr)\r\n      entities = parent.is_a?(Sketchup::Group) ? parent.entities : parent.definition.entities\r\n\r\n      entities.each do |ent|\r\n        next unless ent.is_a?(Sketchup::Group) || ent.is_a?(Sketchup::ComponentInstance)\r\n\r\n        full_tr = parent_tr * ent.transformation\r\n\r\n        origin_point = ORIGIN.transform(full_tr)\r\n        vector = Geom::Vector3d.new(origin_point - @root_center)\r\n        next if vector.length == 0.0\r\n\r\n        original_center = ent.bounds.center.transform(full_tr)\r\n\r\n        @entities_data << {\r\n          entity: ent,\r\n          original_transform: ent.transformation,\r\n          direction: vector,\r\n          original_center: original_center\r\n        }\r\n\r\n        collect_descendants(ent, full_tr)\r\n      end\r\n    end\r\n\r\n    def apply_explosion(factor)\r\n      model = Sketchup.active_model\r\n      model.start_operation(obter_texto(:op_explosao), true)\r\n      \r\n      exploded_centers = []\r\n      \r\n      @entities_data.each do |data|\r\n        original_direction = data[:direction]\r\n        next unless original_direction.respond_to?(:normalize)\r\n      \r\n        normalized = original_direction.normalize rescue nil\r\n        next unless normalized.is_a?(Geom::Vector3d)\r\n      \r\n        distance = original_direction.length * factor\r\n        move_vector = normalized.clone\r\n        move_vector.length = distance\r\n      \r\n        new_center = data[:original_center].offset(move_vector)\r\n        exploded_centers << new_center\r\n      \r\n        data[:_calculated_move] = move_vector\r\n      end\r\n      \r\n      if exploded_centers.empty?\r\n        model.abort_operation\r\n        return\r\n      end\r\n      \r\n      avg_x = exploded_centers.map(&:x).sum / exploded_centers.size\r\n      avg_y = exploded_centers.map(&:y).sum / exploded_centers.size\r\n      avg_z = exploded_centers.map(&:z).sum / exploded_centers.size\r\n      exploded_center = Geom::Point3d.new(avg_x, avg_y, avg_z)\r\n      \r\n      # Compensação agora é entre o centro visual salvo e o novo centro calculado\r\n      compensation_vector = exploded_center.vector_to(@original_avg_center)\r\n      \r\n      @entities_data.each do |data|\r\n        ent = data[:entity]\r\n        next unless ent.valid?\r\n      \r\n        move_vector = data[:_calculated_move]\r\n        compensated_vector = move_vector + compensation_vector\r\n      \r\n        ent.transformation = data[:original_transform] * Geom::Transformation.translation(compensated_vector)\r\n      end\r\n      \r\n      model.commit_operation\r\n    end\r\n\r\n    def restore_positions\r\n      model = Sketchup.active_model\r\n      model.start_operation(obter_texto(:op_restaurar), true)\r\n\r\n      @entities_data.each do |data|\r\n        ent = data[:entity]\r\n        ent.transformation = data[:original_transform] if ent.valid?\r\n      end\r\n\r\n      model.commit_operation\r\n    end\r\n\r\n    def show_dialog\r\n      html = <<-HTML\r\n        <!DOCTYPE html>\r\n        <html>\r\n        <head>\r\n          <meta charset=\"utf-8\">\r\n          <style>\r\n            body { font-family: sans-serif; padding: 10px; }\r\n            input[type=range] { width: 100%; }\r\n          </style>\r\n        </head>\r\n        <body>\r\n          <h3>#{obter_texto(:titulo)}</h3>\r\n          <input id=\"slider\" type=\"range\" min=\"0\" max=\"100\" value=\"0\">\r\n          <script>\r\n            const slider = document.getElementById('slider');\r\n            slider.addEventListener('input', () => {\r\n              window.sketchup.set_explosion(slider.value);\r\n            });\r\n            window.onbeforeunload = () => {\r\n              window.sketchup.restore_positions();\r\n            };\r\n          </script>\r\n        </body>\r\n        </html>\r\n      HTML\r\n\r\n      @dialog = UI::HtmlDialog.new({\r\n        dialog_title: obter_texto(:titulo),\r\n        width: 300,\r\n        height: 120,\r\n        style: UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n\r\n      @dialog.set_html(html)\r\n      @dialog.add_action_callback(\"set_explosion\") { |_ctx, val| apply_explosion(val.to_f / 100.0) }\r\n      @dialog.add_action_callback(\"restore_positions\") { |_ctx, _| restore_positions }\r\n      @dialog.show\r\n    end\r\n  end\r\nend\r\n\r\nScriptUpComunidade::ExplosaoRadialFinal.executar",
      "en": "require 'sketchup.rb'\r\nrequire 'json'\r\n\r\nmodule ScriptUpComunidade\r\n  module ExplosaoRadialFinal\r\n    extend self\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao => \"Selecione apenas um grupo ou componente.\",\r\n        :op_explosao  => \"Explosão Visual\",\r\n        :op_restaurar => \"Restaurar Explosão\",\r\n        :titulo       => \"Explosão Visual Radial\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao => \"Select only one group or component.\",\r\n        :op_explosao  => \"Visual Explosion\",\r\n        :op_restaurar => \"Restore Explosion\",\r\n        :titulo       => \"Radial Visual Explosion\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao => \"Seleccione solo un grupo o componente.\",\r\n        :op_explosao  => \"Explosión Visual\",\r\n        :op_restaurar => \"Restaurar Explosión\",\r\n        :titulo       => \"Explosión Visual Radial\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n      unless selection.length == 1 && (selection.first.is_a?(Sketchup::Group) || selection.first.is_a?(Sketchup::ComponentInstance))\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n\r\n      @root = selection.first\r\n      @root_tr = @root.transformation\r\n      @root_center = @root.bounds.center.transform(@root_tr)\r\n\r\n      @entities_data = []\r\n      collect_descendants(@root, @root_tr)\r\n\r\n      # Calcula centro médio original dos componentes internos\r\n      centros = @entities_data.map { |data| data[:original_center] }\r\n\r\n      avg_x = centros.map(&:x).sum / centros.size\r\n      avg_y = centros.map(&:y).sum / centros.size\r\n      avg_z = centros.map(&:z).sum / centros.size\r\n\r\n      @original_avg_center = Geom::Point3d.new(avg_x, avg_y, avg_z)\r\n\r\n      show_dialog\r\n    end\r\n\r\n    def collect_descendants(parent, parent_tr)\r\n      entities = parent.is_a?(Sketchup::Group) ? parent.entities : parent.definition.entities\r\n\r\n      entities.each do |ent|\r\n        next unless ent.is_a?(Sketchup::Group) || ent.is_a?(Sketchup::ComponentInstance)\r\n\r\n        full_tr = parent_tr * ent.transformation\r\n\r\n        origin_point = ORIGIN.transform(full_tr)\r\n        vector = Geom::Vector3d.new(origin_point - @root_center)\r\n        next if vector.length == 0.0\r\n\r\n        original_center = ent.bounds.center.transform(full_tr)\r\n\r\n        @entities_data << {\r\n          entity: ent,\r\n          original_transform: ent.transformation,\r\n          direction: vector,\r\n          original_center: original_center\r\n        }\r\n\r\n        collect_descendants(ent, full_tr)\r\n      end\r\n    end\r\n\r\n    def apply_explosion(factor)\r\n      model = Sketchup.active_model\r\n      model.start_operation(obter_texto(:op_explosao), true)\r\n      \r\n      exploded_centers = []\r\n      \r\n      @entities_data.each do |data|\r\n        original_direction = data[:direction]\r\n        next unless original_direction.respond_to?(:normalize)\r\n      \r\n        normalized = original_direction.normalize rescue nil\r\n        next unless normalized.is_a?(Geom::Vector3d)\r\n      \r\n        distance = original_direction.length * factor\r\n        move_vector = normalized.clone\r\n        move_vector.length = distance\r\n      \r\n        new_center = data[:original_center].offset(move_vector)\r\n        exploded_centers << new_center\r\n      \r\n        data[:_calculated_move] = move_vector\r\n      end\r\n      \r\n      if exploded_centers.empty?\r\n        model.abort_operation\r\n        return\r\n      end\r\n      \r\n      avg_x = exploded_centers.map(&:x).sum / exploded_centers.size\r\n      avg_y = exploded_centers.map(&:y).sum / exploded_centers.size\r\n      avg_z = exploded_centers.map(&:z).sum / exploded_centers.size\r\n      exploded_center = Geom::Point3d.new(avg_x, avg_y, avg_z)\r\n      \r\n      # Compensação agora é entre o centro visual salvo e o novo centro calculado\r\n      compensation_vector = exploded_center.vector_to(@original_avg_center)\r\n      \r\n      @entities_data.each do |data|\r\n        ent = data[:entity]\r\n        next unless ent.valid?\r\n      \r\n        move_vector = data[:_calculated_move]\r\n        compensated_vector = move_vector + compensation_vector\r\n      \r\n        ent.transformation = data[:original_transform] * Geom::Transformation.translation(compensated_vector)\r\n      end\r\n      \r\n      model.commit_operation\r\n    end\r\n\r\n    def restore_positions\r\n      model = Sketchup.active_model\r\n      model.start_operation(obter_texto(:op_restaurar), true)\r\n\r\n      @entities_data.each do |data|\r\n        ent = data[:entity]\r\n        ent.transformation = data[:original_transform] if ent.valid?\r\n      end\r\n\r\n      model.commit_operation\r\n    end\r\n\r\n    def show_dialog\r\n      html = <<-HTML\r\n        <!DOCTYPE html>\r\n        <html>\r\n        <head>\r\n          <meta charset=\"utf-8\">\r\n          <style>\r\n            body { font-family: sans-serif; padding: 10px; }\r\n            input[type=range] { width: 100%; }\r\n          </style>\r\n        </head>\r\n        <body>\r\n          <h3>#{obter_texto(:titulo)}</h3>\r\n          <input id=\"slider\" type=\"range\" min=\"0\" max=\"100\" value=\"0\">\r\n          <script>\r\n            const slider = document.getElementById('slider');\r\n            slider.addEventListener('input', () => {\r\n              window.sketchup.set_explosion(slider.value);\r\n            });\r\n            window.onbeforeunload = () => {\r\n              window.sketchup.restore_positions();\r\n            };\r\n          </script>\r\n        </body>\r\n        </html>\r\n      HTML\r\n\r\n      @dialog = UI::HtmlDialog.new({\r\n        dialog_title: obter_texto(:titulo),\r\n        width: 300,\r\n        height: 120,\r\n        style: UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n\r\n      @dialog.set_html(html)\r\n      @dialog.add_action_callback(\"set_explosion\") { |_ctx, val| apply_explosion(val.to_f / 100.0) }\r\n      @dialog.add_action_callback(\"restore_positions\") { |_ctx, _| restore_positions }\r\n      @dialog.show\r\n    end\r\n  end\r\nend\r\n\r\nScriptUpComunidade::ExplosaoRadialFinal.executar",
      "es": "require 'sketchup.rb'\r\nrequire 'json'\r\n\r\nmodule ScriptUpComunidade\r\n  module ExplosaoRadialFinal\r\n    extend self\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao => \"Selecione apenas um grupo ou componente.\",\r\n        :op_explosao  => \"Explosão Visual\",\r\n        :op_restaurar => \"Restaurar Explosão\",\r\n        :titulo       => \"Explosão Visual Radial\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao => \"Select only one group or component.\",\r\n        :op_explosao  => \"Visual Explosion\",\r\n        :op_restaurar => \"Restore Explosion\",\r\n        :titulo       => \"Radial Visual Explosion\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao => \"Seleccione solo un grupo o componente.\",\r\n        :op_explosao  => \"Explosión Visual\",\r\n        :op_restaurar => \"Restaurar Explosión\",\r\n        :titulo       => \"Explosión Visual Radial\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n      unless selection.length == 1 && (selection.first.is_a?(Sketchup::Group) || selection.first.is_a?(Sketchup::ComponentInstance))\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n\r\n      @root = selection.first\r\n      @root_tr = @root.transformation\r\n      @root_center = @root.bounds.center.transform(@root_tr)\r\n\r\n      @entities_data = []\r\n      collect_descendants(@root, @root_tr)\r\n\r\n      # Calcula centro médio original dos componentes internos\r\n      centros = @entities_data.map { |data| data[:original_center] }\r\n\r\n      avg_x = centros.map(&:x).sum / centros.size\r\n      avg_y = centros.map(&:y).sum / centros.size\r\n      avg_z = centros.map(&:z).sum / centros.size\r\n\r\n      @original_avg_center = Geom::Point3d.new(avg_x, avg_y, avg_z)\r\n\r\n      show_dialog\r\n    end\r\n\r\n    def collect_descendants(parent, parent_tr)\r\n      entities = parent.is_a?(Sketchup::Group) ? parent.entities : parent.definition.entities\r\n\r\n      entities.each do |ent|\r\n        next unless ent.is_a?(Sketchup::Group) || ent.is_a?(Sketchup::ComponentInstance)\r\n\r\n        full_tr = parent_tr * ent.transformation\r\n\r\n        origin_point = ORIGIN.transform(full_tr)\r\n        vector = Geom::Vector3d.new(origin_point - @root_center)\r\n        next if vector.length == 0.0\r\n\r\n        original_center = ent.bounds.center.transform(full_tr)\r\n\r\n        @entities_data << {\r\n          entity: ent,\r\n          original_transform: ent.transformation,\r\n          direction: vector,\r\n          original_center: original_center\r\n        }\r\n\r\n        collect_descendants(ent, full_tr)\r\n      end\r\n    end\r\n\r\n    def apply_explosion(factor)\r\n      model = Sketchup.active_model\r\n      model.start_operation(obter_texto(:op_explosao), true)\r\n      \r\n      exploded_centers = []\r\n      \r\n      @entities_data.each do |data|\r\n        original_direction = data[:direction]\r\n        next unless original_direction.respond_to?(:normalize)\r\n      \r\n        normalized = original_direction.normalize rescue nil\r\n        next unless normalized.is_a?(Geom::Vector3d)\r\n      \r\n        distance = original_direction.length * factor\r\n        move_vector = normalized.clone\r\n        move_vector.length = distance\r\n      \r\n        new_center = data[:original_center].offset(move_vector)\r\n        exploded_centers << new_center\r\n      \r\n        data[:_calculated_move] = move_vector\r\n      end\r\n      \r\n      if exploded_centers.empty?\r\n        model.abort_operation\r\n        return\r\n      end\r\n      \r\n      avg_x = exploded_centers.map(&:x).sum / exploded_centers.size\r\n      avg_y = exploded_centers.map(&:y).sum / exploded_centers.size\r\n      avg_z = exploded_centers.map(&:z).sum / exploded_centers.size\r\n      exploded_center = Geom::Point3d.new(avg_x, avg_y, avg_z)\r\n      \r\n      # Compensação agora é entre o centro visual salvo e o novo centro calculado\r\n      compensation_vector = exploded_center.vector_to(@original_avg_center)\r\n      \r\n      @entities_data.each do |data|\r\n        ent = data[:entity]\r\n        next unless ent.valid?\r\n      \r\n        move_vector = data[:_calculated_move]\r\n        compensated_vector = move_vector + compensation_vector\r\n      \r\n        ent.transformation = data[:original_transform] * Geom::Transformation.translation(compensated_vector)\r\n      end\r\n      \r\n      model.commit_operation\r\n    end\r\n\r\n    def restore_positions\r\n      model = Sketchup.active_model\r\n      model.start_operation(obter_texto(:op_restaurar), true)\r\n\r\n      @entities_data.each do |data|\r\n        ent = data[:entity]\r\n        ent.transformation = data[:original_transform] if ent.valid?\r\n      end\r\n\r\n      model.commit_operation\r\n    end\r\n\r\n    def show_dialog\r\n      html = <<-HTML\r\n        <!DOCTYPE html>\r\n        <html>\r\n        <head>\r\n          <meta charset=\"utf-8\">\r\n          <style>\r\n            body { font-family: sans-serif; padding: 10px; }\r\n            input[type=range] { width: 100%; }\r\n          </style>\r\n        </head>\r\n        <body>\r\n          <h3>#{obter_texto(:titulo)}</h3>\r\n          <input id=\"slider\" type=\"range\" min=\"0\" max=\"100\" value=\"0\">\r\n          <script>\r\n            const slider = document.getElementById('slider');\r\n            slider.addEventListener('input', () => {\r\n              window.sketchup.set_explosion(slider.value);\r\n            });\r\n            window.onbeforeunload = () => {\r\n              window.sketchup.restore_positions();\r\n            };\r\n          </script>\r\n        </body>\r\n        </html>\r\n      HTML\r\n\r\n      @dialog = UI::HtmlDialog.new({\r\n        dialog_title: obter_texto(:titulo),\r\n        width: 300,\r\n        height: 120,\r\n        style: UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n\r\n      @dialog.set_html(html)\r\n      @dialog.add_action_callback(\"set_explosion\") { |_ctx, val| apply_explosion(val.to_f / 100.0) }\r\n      @dialog.add_action_callback(\"restore_positions\") { |_ctx, _| restore_positions }\r\n      @dialog.show\r\n    end\r\n  end\r\nend\r\n\r\nScriptUpComunidade::ExplosaoRadialFinal.executar"
    },
    "enabled": false,
    "execute": true
  }
]