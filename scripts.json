[
  {
    "id": "achatar-c445d",
    "title": {
      "pt": "Achatar",
      "en": "Flatten",
      "es": "Aplanar"
    },
    "author": "Henrique Barsa",
    "version": "1.0",
    "description": {
      "pt": "Nivela todos os elementos no eixo Z = 0",
      "en": "Level all elements on the Z = 0 axis.",
      "es": "Nivele todos los elementos en el eje Z = 0."
    },
    "keywords": {
      "pt": [
        "flatten",
        "achatar",
        "aplanar"
      ],
      "en": [
        "flatten",
        "flatten",
        "flatten"
      ],
      "es": [
        "aplanar",
        "aplanar",
        "aplanar"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module AchatarModelo\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :pergunta_modelo  => \"Nenhum objeto selecionado. Deseja achatar o modelo inteiro?\",\r\n        :msg_sucesso_full => \"Foram achatados %d objetos no modelo inteiro.\",\r\n        :cancelado        => \"Opera√ß√£o cancelada.\",\r\n        :msg_sucesso_sel  => \"Foram achatados %d objetos na sele√ß√£o.\",\r\n        :op_nome          => \"Achatar\"\r\n      },\r\n      'en-US' => {\r\n        :pergunta_modelo  => \"No objects selected. Do you want to flatten the entire model?\",\r\n        :msg_sucesso_full => \"%d objects were flattened in the entire model.\",\r\n        :cancelado        => \"Operation canceled.\",\r\n        :msg_sucesso_sel  => \"%d objects were flattened in the selection.\",\r\n        :op_nome          => \"Flatten\"\r\n      },\r\n      'es' => {\r\n        :pergunta_modelo  => \"¬øNing√∫n objeto seleccionado. Desea aplanar el modelo completo?\",\r\n        :msg_sucesso_full => \"Se aplanaron %d objetos en el modelo completo.\",\r\n        :cancelado        => \"Operaci√≥n cancelada.\",\r\n        :msg_sucesso_sel  => \"Se aplanaron %d objetos en la selecci√≥n.\",\r\n        :op_nome          => \"Aplanar\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    # M√©todo principal que decide se vai achatar a sele√ß√£o ou o modelo inteiro\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n      \r\n      if selection.empty?\r\n        # Pergunta se deseja processar o modelo inteiro\r\n        resposta = UI.messagebox(obter_texto(:pergunta_modelo), MB_YESNO)\r\n        if resposta == IDYES\r\n          stats = flatten_entities(model.entities)\r\n          UI.messagebox(obter_texto(:msg_sucesso_full) % stats)\r\n        else\r\n          UI.messagebox(obter_texto(:cancelado))\r\n          model.abort_operation\r\n          return\r\n        end\r\n      else\r\n        stats = flatten_entities(selection)\r\n        UI.messagebox(obter_texto(:msg_sucesso_sel) % stats)\r\n      end\r\n\r\n      model.commit_operation\r\n    end\r\n\r\n    # M√©todo recursivo para achatar as entidades\r\n    def self.flatten_entities(ents)\r\n      stats = 0\r\n      vertices = []\r\n\r\n      ents.each do |e|\r\n        if e.is_a?(Sketchup::ComponentInstance) || e.is_a?(Sketchup::Group)\r\n          # Processa recursivamente as entidades da defini√ß√£o do componente ou grupo\r\n          stats += flatten_entities(Instance.definition(e).entities)\r\n          # Move a inst√¢ncia para z=0\r\n          p = e.transformation.origin.clone\r\n          p.z = 0\r\n          v = e.transformation.origin.vector_to(p)\r\n          e.transform!(Geom::Transformation.new(v))\r\n        end\r\n\r\n        vertices << e if e.is_a?(Sketchup::ConstructionPoint)\r\n        vertices << e.vertices if e.respond_to?(:vertices)\r\n        e.explode_curve if e.is_a?(Sketchup::Edge)\r\n      end\r\n\r\n      vertices.flatten!\r\n      vertices.uniq!\r\n\r\n      entities = []\r\n      vectors = []\r\n\r\n      # Ajusta todos os v√©rtices para o n√≠vel z=0\r\n      vertices.each do |v|\r\n        point = v.position\r\n        next if point.z == 0\r\n        entities << v\r\n        point.z = 0\r\n        vectors << v.position.vector_to(point)\r\n      end\r\n\r\n      if ents.is_a?(Sketchup::Selection)\r\n        ents.model.active_entities.transform_by_vectors(entities, vectors)\r\n      else\r\n        ents.transform_by_vectors(entities, vectors)\r\n      end\r\n\r\n      return entities.length + stats\r\n    end\r\n\r\n    # M√≥dulo auxiliar para tratar defini√ß√µes de grupos e componentes\r\n    module Instance\r\n      def self.definition(instance)\r\n        if instance.respond_to?(:definition)\r\n          begin\r\n            return instance.definition\r\n          rescue\r\n            # Em caso de erro, prossegue para a busca manual\r\n          end\r\n        end\r\n\r\n        if instance.is_a?(Sketchup::Group)\r\n          if instance.entities.parent.instances.include?(instance)\r\n            return instance.entities.parent\r\n          else\r\n            Sketchup.active_model.definitions.each do |definition|\r\n              return definition if definition.instances.include?(instance)\r\n            end\r\n          end\r\n        elsif instance.is_a?(Sketchup::Image)\r\n          Sketchup.active_model.definitions.each do |definition|\r\n            if definition.image? && definition.instances.include?(instance)\r\n              return definition\r\n            end\r\n          end\r\n        end\r\n\r\n        return nil\r\n      end\r\n\r\n      def self.is?(entity)\r\n        entity.is_a?(Sketchup::Group) || entity.is_a?(Sketchup::ComponentInstance)\r\n      end\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::AchatarModelo.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "ajustar-escala-da-definicao-c45nc",
    "title": {
      "pt": "Ajustar Escala da Defini√ß√£o",
      "en": "Adjust Definition Scale",
      "es": "Ajustar escala de definici√≥n"
    },
    "author": "F√°bio Coutinho",
    "version": "1.2",
    "description": {
      "pt": "Ajusta a escala da defini√ß√£o fazendo com que as texturas aplicadas nos grupos e componentes assumam suas propor√ß√µes corretas para n√£o ficarem distorcidas. Essa vers√£o consegue promover o ajuste em grupos e componentes em qualquer n√≠vel de aninhamento.",
      "en": "Adjusts the scaling of the definition so that the textures applied to groups and components assume their correct proportions and do not become distorted. This version can adjust groups and components at any nesting level.",
      "es": "Ajusta la escala de la definici√≥n para que las texturas aplicadas a grupos y componentes adquieran las proporciones correctas y no se distorsionen. Esta versi√≥n permite ajustar grupos y componentes en cualquier nivel de anidamiento."
    },
    "keywords": {
      "pt": [
        "escala da defini√ß√£o",
        "ajustar texturas"
      ],
      "en": [
        "scale of definition",
        "adjust textures"
      ],
      "es": [
        "escala de definici√≥n",
        "ajustar texturas"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module NormalizarEscala\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :selecao_vazia    => \"Nenhum elemento selecionado.\",\r\n        :ja_processado    => \"Defini√ß√£o j√° processada, ignorando: \",\r\n        :escala_ajustada  => \"A escala foi normalizada para 1 no elemento: \",\r\n        :escala_correta   => \"O elemento j√° est√° com escala normalizada: \",\r\n        :elemento_ignorado => \"Elemento ignorado, n√£o √© um componente ou grupo v√°lido: \",\r\n        :op_nome          => \"Normalizar Escala\",\r\n        :concluido        => \"Processo conclu√≠do.\"\r\n      },\r\n      'en-US' => {\r\n        :selecao_vazia    => \"No elements selected.\",\r\n        :ja_processado    => \"Definition already processed, skipping: \",\r\n        :escala_ajustada  => \"Scale was normalized to 1 for element: \",\r\n        :escala_correta   => \"Element already has normalized scale: \",\r\n        :elemento_ignorado => \"Element ignored, not a valid component or group: \",\r\n        :op_nome          => \"Normalize Scale\",\r\n        :concluido        => \"Process completed.\"\r\n      },\r\n      'es' => {\r\n        :selecao_vazia    => \"Ning√∫n elemento seleccionado.\",\r\n        :ja_processado    => \"Definici√≥n ya procesada, ignorando: \",\r\n        :escala_ajustada  => \"La escala fue normalizada a 1 en el elemento: \",\r\n        :escala_correta   => \"El elemento ya tiene la escala normalizada: \",\r\n        :elemento_ignorado => \"Elemento ignorado, no es un componente o grupo v√°lido: \",\r\n        :op_nome          => \"Normalizar Escala\",\r\n        :concluido        => \"Proceso completado.\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      if selection.empty?\r\n        puts obter_texto(:selecao_vazia)\r\n      else\r\n        processed_definitions = []\r\n\r\n        model.start_operation(obter_texto(:op_nome), true)\r\n\r\n        selection.each do |entity|\r\n          normalize_scale_recursively(entity, processed_definitions)\r\n        end\r\n\r\n        model.commit_operation\r\n        puts obter_texto(:concluido)\r\n      end\r\n    end\r\n\r\n    def self.normalize_scale_recursively(entity, processed_definitions)\r\n      if entity.is_a?(Sketchup::ComponentInstance) || entity.is_a?(Sketchup::Group)\r\n        entity.make_unique if entity.is_a?(Sketchup::ComponentInstance)\r\n\r\n        definition = entity.is_a?(Sketchup::ComponentInstance) ? entity.definition : nil\r\n        entities = definition ? definition.entities : entity.entities\r\n\r\n        if definition && processed_definitions.include?(definition)\r\n          puts \"#{obter_texto(:ja_processado)}#{entity}\"\r\n          return\r\n        end\r\n\r\n        processed_definitions << definition if definition\r\n\r\n        transform = entity.transformation\r\n        scale_x = transform.xscale\r\n        scale_y = transform.yscale\r\n        scale_z = transform.zscale\r\n\r\n        if scale_x != 1 || scale_y != 1 || scale_z != 1\r\n          scaling_transform = Geom::Transformation.scaling(scale_x, scale_y, scale_z)\r\n          entities.transform_entities(scaling_transform, entities.to_a)\r\n\r\n          origin = transform.origin\r\n          xaxis = transform.xaxis\r\n          yaxis = transform.yaxis\r\n          zaxis = transform.zaxis\r\n\r\n          normalized_transform = Geom::Transformation.axes(origin, xaxis, yaxis, zaxis)\r\n          entity.transformation = normalized_transform\r\n\r\n          puts \"#{obter_texto(:escala_ajustada)}#{entity}\"\r\n\r\n          temp_group = entities.add_group\r\n          temp_face = temp_group.entities.add_face([0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0])\r\n          temp_group.erase! if temp_face\r\n        else\r\n          puts \"#{obter_texto(:escala_correta)}#{entity}\"\r\n        end\r\n\r\n        entities.grep(Sketchup::ComponentInstance).each do |child_entity|\r\n          normalize_scale_recursively(child_entity, processed_definitions)\r\n        end\r\n        entities.grep(Sketchup::Group).each do |child_group|\r\n          normalize_scale_recursively(child_group, processed_definitions)\r\n        end\r\n      else\r\n        puts \"#{obter_texto(:elemento_ignorado)}#{entity}\"\r\n      end\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::NormalizarEscala.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "cortar-com-secao-c471p",
    "title": {
      "pt": "Cortar com Se√ß√£o",
      "en": "Cut with Section",
      "es": "Corte con secci√≥n"
    },
    "author": "Henrique Barsa",
    "version": "1.0",
    "description": {
      "pt": "Use o Plano de Se√ß√£o para cortar o que voc√™ quiser.",
      "en": "Use the Section Plan to cut out whatever you want.",
      "es": "Utilice el plano de secci√≥n para cortar lo que desee."
    },
    "keywords": {
      "pt": [
        "cortar",
        "se√ß√£o"
      ],
      "en": [
        "cut",
        "section"
      ],
      "es": [
        "cortar",
        "secci√≥n"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module CortarPlanoSecao\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :status_cortando   => \"Cortando %s...\",\r\n        :status_excluindo  => \"Excluindo entidades atr√°s do plano para %s...\",\r\n        :status_preparando => \"Tornando componentes √∫nicos, excluindo grupos e componentes atr√°s do plano de se√ß√£o...\",\r\n        :op_nome           => \"Corte via SectionPlane\",\r\n        :sucesso           => \"Corte via SectionPlane conclu√≠do.\",\r\n        :erro_selecao      => \"Selecione uma SectionPlane para cortar o modelo.\"\r\n      },\r\n      'en-US' => {\r\n        :status_cortando   => \"Slicing %s...\",\r\n        :status_excluindo  => \"Deleting entities behind plane for %s...\",\r\n        :status_preparando => \"Making components unique, deleting groups and components behind section plane...\",\r\n        :op_nome           => \"Slice at Section Plane\",\r\n        :sucesso           => \"Slice at Section Plane completed.\",\r\n        :erro_selecao      => \"Select a SectionPlane to slice the model.\"\r\n      },\r\n      'es' => {\r\n        :status_cortando   => \"Cortando %s...\",\r\n        :status_excluindo  => \"Eliminando entidades detr√°s del plano para %s...\",\r\n        :status_preparando => \"Haciendo componentes √∫nicos, eliminando grupos y componentes detr√°s del plano de secci√≥n...\",\r\n        :op_nome           => \"Corte por Plano de Secci√≥n\",\r\n        :sucesso           => \"Corte por Plano de Secci√≥n completado.\",\r\n        :erro_selecao      => \"Seleccione un SectionPlane para cortar el modelo.\"\r\n      }\r\n    }\r\n\r\n    $helper_group = nil\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.get_entities(object)\r\n      if object.is_a?(Sketchup::Model)\r\n        object.entities\r\n      elsif object.is_a?(Sketchup::Group)\r\n        object.entities\r\n      elsif object.is_a?(Sketchup::ComponentInstance)\r\n        object.definition.entities\r\n      elsif object.is_a?(Sketchup::ComponentDefinition)\r\n        object.entities\r\n      else\r\n        nil\r\n      end\r\n    end\r\n\r\n    def self.bounds_intersects_plane?(inst1, t1, plane)\r\n      bounds = inst1.bounds\r\n      bmin = bounds.min\r\n      bmax = bounds.max\r\n      pts = [\r\n        Geom::Point3d.new(bmin.x, bmin.y, bmin.z),\r\n        Geom::Point3d.new(bmax.x, bmin.y, bmin.z),\r\n        Geom::Point3d.new(bmin.x, bmin.y, bmax.z),\r\n        Geom::Point3d.new(bmax.x, bmin.y, bmax.z),\r\n        Geom::Point3d.new(bmin.x, bmax.y, bmax.z),\r\n        Geom::Point3d.new(bmax.x, bmax.y, bmax.z),\r\n        Geom::Point3d.new(bmin.x, bmax.y, bmin.z),\r\n        Geom::Point3d.new(bmax.x, bmax.y, bmin.z)\r\n      ]\r\n      pts = pts.map { |p| p.transform(t1) }\r\n\r\n      behind = pts.find { |p| (plane[0]*p.x + plane[1]*p.y + plane[2]*p.z + plane[3]) < -0.001 }\r\n      in_front = pts.find { |p| (plane[0]*p.x + plane[1]*p.y + plane[2]*p.z + plane[3]) > 0.001 }\r\n\r\n      if behind && in_front\r\n        0\r\n      elsif behind && !in_front\r\n        -1\r\n      elsif !behind && in_front\r\n        1\r\n      end\r\n    end\r\n\r\n    def self.make_unique_section_cut(ents, t1, plane)\r\n      delete = []\r\n      ents.each do |e|\r\n        next unless e.valid? && e.visible?\r\n        if e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance)\r\n          res = bounds_intersects_plane?(e, t1, plane)\r\n          if res == 0\r\n            e.make_unique\r\n            make_unique_section_cut(get_entities(e), t1 * e.transformation, plane)\r\n          elsif res == -1\r\n            delete << e\r\n          end\r\n        end\r\n      end\r\n      ents.erase_entities(delete) unless delete.empty?\r\n    end\r\n\r\n    def self.create_face_from_section(section)\r\n      plane = section.get_plane\r\n      bounds = Sketchup.active_model.bounds\r\n      entities = Sketchup.active_model.active_entities\r\n      bmin = bounds.min\r\n      bmax = bounds.max\r\n\r\n      newgroup = entities.add_group\r\n      newgroupentities = newgroup.entities\r\n\r\n      c1 = [bmin.x, bmin.y, bmin.z]\r\n      c2 = [bmax.x, bmin.y, bmin.z]\r\n      c3 = [bmin.x, bmin.y, bmax.z]\r\n      c4 = [bmax.x, bmin.y, bmax.z]\r\n      c5 = [bmin.x, bmax.y, bmax.z]\r\n      c6 = [bmax.x, bmax.y, bmax.z]\r\n      c7 = [bmin.x, bmax.y, bmin.z]\r\n      c8 = [bmax.x, bmax.y, bmin.z]\r\n\r\n      e1 = newgroupentities.add_edges(c1, c2)\r\n      e2 = newgroupentities.add_edges(c3, c4)\r\n      e3 = newgroupentities.add_edges(c5, c6)\r\n      e4 = newgroupentities.add_edges(c7, c8)\r\n      e5 = newgroupentities.add_edges(c1, c3)\r\n      e6 = newgroupentities.add_edges(c2, c4)\r\n      e7 = newgroupentities.add_edges(c7, c5)\r\n      e8 = newgroupentities.add_edges(c8, c6)\r\n      e9 = newgroupentities.add_edges(c1, c7)\r\n      e10 = newgroupentities.add_edges(c3, c5)\r\n      e11 = newgroupentities.add_edges(c4, c6)\r\n      e12 = newgroupentities.add_edges(c2, c8)\r\n\r\n      lines = [e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12].map{|arr| arr[0]}\r\n      line_objs = lines.map(&:line)\r\n      lines.each(&:erase!)\r\n\r\n      pts_intersect = line_objs.map { |l| Geom.intersect_line_plane(l, plane) }.compact\r\n      \r\n      # L√≥gica simplificada para gerar a face de corte baseada nos pontos de interse√ß√£o do bounding box\r\n      if pts_intersect.length >= 3\r\n        newgroupentities.add_face(pts_intersect) rescue nil\r\n      end\r\n\r\n      return newgroup\r\n    end\r\n\r\n    def self.nested_slash(first, t1, second, t2)\r\n      ents = get_entities(first)\r\n      ents.each do |e|\r\n        if e.valid? && e.visible? && (e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance))\r\n          Sketchup.set_status_text(obter_texto(:status_cortando) % get_entities(e).parent.name)\r\n          nested_slash(e, t1 * e.transformation, second, t2)\r\n        end\r\n      end\r\n      slash(first, t1, second, t2)\r\n    end\r\n\r\n    def self.slash(inst1, t1, inst2, t2)\r\n      if intersects_plane?(inst1, t1, inst2, t2)\r\n        ents1 = get_entities(inst1)\r\n        ents1.intersect_with(false, t1, ents1, t1, false, [inst2])\r\n      end\r\n    end\r\n\r\n    def self.intersects_plane?(inst1, t1, plane_group, t2)\r\n      if $helper_group.nil? || !$helper_group.valid?\r\n        $helper_group = Sketchup.active_model.active_entities.add_group\r\n        $helper_group.entities.add_cpoint([0,0,0])\r\n      end\r\n      ents1 = get_entities(inst1)\r\n      ents2 = $helper_group.entities\r\n      new_edges = ents1.intersect_with(false, t1, ents2, $helper_group.transformation, false, [plane_group])\r\n      new_edges.length > 0\r\n    end\r\n\r\n    def self.delete_model_behind_plane(first, t1, plane)\r\n      ents = get_entities(first)\r\n      ents.each do |e|\r\n        if e.valid? && e.visible? && (e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance))\r\n          Sketchup.set_status_text(obter_texto(:status_excluindo) % get_entities(e).parent.name)\r\n          delete_model_behind_plane(e, t1 * e.transformation, plane)\r\n        end\r\n      end\r\n      delete_ents_behind_plane(first, t1, plane)\r\n    end\r\n\r\n    def self.delete_ents_behind_plane(first, t1, plane)\r\n      ents = get_entities(first)\r\n      deletar = []\r\n      ents.each do |e|\r\n        next unless e.valid?\r\n        if e.is_a?(Sketchup::Face)\r\n          cent = e.bounds.center.transform(t1)\r\n          result = plane[0]*cent.x + plane[1]*cent.y + plane[2]*cent.z + plane[3]\r\n          deletar << e if result < -0.001\r\n        elsif e.is_a?(Sketchup::Edge)\r\n          p1 = e.start.position.transform(t1)\r\n          p2 = e.end.position.transform(t1)\r\n          cent = Geom::Point3d.new((p1.x+p2.x)/2.0, (p1.y+p2.y)/2.0, (p1.z+p2.z)/2.0)\r\n          result = plane[0]*cent.x + plane[1]*cent.y + plane[2]*cent.z + plane[3]\r\n          deletar << e if result < -0.001 && cent.distance_to_plane(plane) > 0.001\r\n        end\r\n      end\r\n      ents.erase_entities(deletar) unless deletar.empty?\r\n    end\r\n\r\n    def self.delete_helpers\r\n      if $helper_group && $helper_group.valid?\r\n        Sketchup.active_model.active_entities.erase_entities($helper_group)\r\n      end\r\n      $helper_group = nil\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      section = model.selection.first\r\n      \r\n      unless section.is_a?(Sketchup::SectionPlane)\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n\r\n      plane = section.get_plane\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n\r\n      ents = model.active_entities\r\n      Sketchup.set_status_text(obter_texto(:status_preparando))\r\n\r\n      make_unique_section_cut(ents, Geom::Transformation.new, plane)\r\n      knife_group = create_face_from_section(section)\r\n      \r\n      nested_slash(ents.parent, Geom::Transformation.new, knife_group, knife_group.transformation)\r\n      \r\n      ents.erase_entities(knife_group) if knife_group.valid?\r\n      delete_model_behind_plane(ents.parent, Geom::Transformation.new, plane)\r\n      delete_helpers()\r\n\r\n      model.commit_operation\r\n      UI.messagebox(obter_texto(:sucesso))\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::CortarPlanoSecao.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "cria-cena-com-elementos-isolados-c48ua",
    "title": {
      "pt": "Cria Cena com Elementos Isolados",
      "en": "Create a Scene with Isolated Elements",
      "es": "Crear una escena con elementos aislados"
    },
    "author": "Jos√© Ricardo",
    "version": "1.0",
    "description": {
      "pt": "Isola os elementos selecionados ocultando os demais e criando uma cena com os elementos em sele√ß√£o de zoom.",
      "en": "Isolate the selected elements, hiding the others and creating a scene with the zoomed-in selection of the elements.",
      "es": "A√≠sla los elementos seleccionados, ocultando los dem√°s y creando una escena con la selecci√≥n ampliada de los elementos."
    },
    "keywords": {
      "pt": [
        "isola elemento",
        "cena com sele√ß√£o"
      ],
      "en": [
        "isolates element",
        "scene with selection"
      ],
      "es": [
        "elemento aislado",
        "escena con selecci√≥n"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module CriarCenaFiltrada\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao    => \"Nenhuma entidade selecionada. Por favor, selecione objetos para manter vis√≠veis.\",\r\n        :label_cena      => \"Nome da Cena:\",\r\n        :default_cena    => \"Cena Filtrada\",\r\n        :titulo_input    => \"Criar Nova Cena\",\r\n        :cancelado       => \"Opera√ß√£o cancelada pelo usu√°rio.\",\r\n        :op_nome         => \"Ocultar N√£o Selecionados e Criar Cena\",\r\n        :sucesso         => \"Cena '%s' criada com sucesso, com zoom na sele√ß√£o e entidades ocultas.\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao    => \"No entities selected. Please select objects to keep visible.\",\r\n        :label_cena      => \"Scene Name:\",\r\n        :default_cena    => \"Filtered Scene\",\r\n        :titulo_input    => \"Create New Scene\",\r\n        :cancelado       => \"Operation canceled by user.\",\r\n        :op_nome         => \"Hide Unselected and Create Scene\",\r\n        :sucesso         => \"Scene '%s' successfully created with zoom on selection and hidden entities.\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao    => \"Ninguna entidad seleccionada. Por favor, seleccione objetos para mantener visibles.\",\r\n        :label_cena      => \"Nombre de la Escena:\",\r\n        :default_cena    => \"Escena Filtrada\",\r\n        :titulo_input    => \"Crear Nueva Escena\",\r\n        :cancelado       => \"Operaci√≥n cancelada por el usuario.\",\r\n        :op_nome         => \"Ocultar no seleccionados y Crear Escena\",\r\n        :sucesso         => \"Escena '%s' creada con √©xito, con zoom en la selecci√≥n y entidades ocultas.\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      entities = model.active_entities\r\n      selection = model.selection\r\n\r\n      if selection.empty?\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n      else\r\n        # Solicita o nome da nova cena\r\n        prompts = [obter_texto(:label_cena)]\r\n        defaults = [obter_texto(:default_cena)]\r\n        input = UI.inputbox(prompts, defaults, obter_texto(:titulo_input))\r\n        \r\n        unless input\r\n          puts obter_texto(:cancelado)\r\n          return\r\n        end\r\n\r\n        scene_name = input[0]\r\n\r\n        # Inicia opera√ß√£o\r\n        model.start_operation(obter_texto(:op_nome), true)\r\n\r\n        # Oculta entidades n√£o selecionadas (e ocult√°veis)\r\n        entities.each do |ent|\r\n          next if selection.include?(ent)\r\n          ent.hidden = true if ent.respond_to?(:hidden=)\r\n        end\r\n\r\n        # Faz zoom na sele√ß√£o\r\n        Sketchup.send_action(\"viewZoomToSelection:\")\r\n\r\n        # Aguarda um pequeno tempo para garantir o zoom e cria a cena\r\n        UI.start_timer(0.2, false) {\r\n          page = model.pages.add(scene_name)\r\n          page.use_camera = true\r\n\r\n          model.commit_operation\r\n          UI.messagebox(obter_texto(:sucesso) % scene_name)\r\n        }\r\n      end\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::CriarCenaFiltrada.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "cria-cenas-do-modelo-isolado-em-projecao-c4ad3",
    "title": {
      "pt": "Cria Cenas do Modelo Isolado em Proje√ß√£o Paralela",
      "en": "Creates Scenes of the Isolated Model in Parallel Projection",
      "es": "Crea escenas del modelo aislado en proyecci√≥n paralela"
    },
    "author": "Andr√© Silva",
    "version": "1.3",
    "description": {
      "pt": "Cria todas as exibi√ß√µes padr√µes, em proje√ß√£o paralela, do(s) elemento(s) selecionado(s) de forma isolada, ou seja, ocultando o restante do modelo. As cenas s√£o criadas usando no nome o prefixo que voc√™ informar.",
      "en": "Creates all standard views, in parallel projection, of the selected element(s) in isolation, that is, hiding the rest of the model. Scenes are created using the prefix you specify in the name.",
      "es": "Crea todas las vistas est√°ndar, en proyecci√≥n paralela, de los elementos seleccionados de forma aislada, es decir, ocultando el resto del modelo. Las escenas se crean con el prefijo especificado en el nombre."
    },
    "keywords": {
      "pt": [
        "cenas",
        "proje√ß√£o paralela"
      ],
      "en": [
        "scenes",
        "parallel projection"
      ],
      "es": [
        "escenas",
        "proyecci√≥n paralela"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module CriarVistasPadrao\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :label_prefixo => \"Prefixo das cenas:\",\r\n        :titulo_input  => \"Prefixo para os nomes das cenas\",\r\n        :op_nome       => \"Isolar Sele√ß√£o para Cenas\",\r\n        :superior      => \"Superior\",\r\n        :inferior      => \"Inferior\",\r\n        :direita       => \"Direita\",\r\n        :esquerda      => \"Esquerda\",\r\n        :posterior     => \"Posterior\",\r\n        :frontal       => \"Frontal\",\r\n        :iso           => \"ISO\"\r\n      },\r\n      'en-US' => {\r\n        :label_prefixo => \"Scene prefix:\",\r\n        :titulo_input  => \"Prefix for scene names\",\r\n        :op_nome       => \"Isolate Selection for Scenes\",\r\n        :superior      => \"Top\",\r\n        :inferior      => \"Bottom\",\r\n        :direita       => \"Right\",\r\n        :esquerda      => \"Left\",\r\n        :posterior     => \"Back\",\r\n        :frontal       => \"Front\",\r\n        :iso           => \"ISO\"\r\n      },\r\n      'es' => {\r\n        :label_prefixo => \"Prefijo de las escenas:\",\r\n        :titulo_input  => \"Prefijo para los nombres de las escenas\",\r\n        :op_nome       => \"Aislar Selecci√≥n para Escenas\",\r\n        :superior      => \"Superior\",\r\n        :inferior      => \"Inferior\",\r\n        :direita       => \"Derecha\",\r\n        :esquerda      => \"Izquierda\",\r\n        :posterior     => \"Posterior\",\r\n        :frontal       => \"Frontal\",\r\n        :iso           => \"ISO\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      entities = model.active_entities\r\n      views = model.pages\r\n      view = model.active_view\r\n      selection = model.selection\r\n\r\n      # Pergunta o prefixo\r\n      res = UI.inputbox([obter_texto(:label_prefixo)], [\"\"], obter_texto(:titulo_input))\r\n\r\n      if res # S√≥ continua se n√£o cancelou\r\n        prefixo = res[0].strip\r\n        prefixo += \" - \" unless prefixo.empty?\r\n\r\n        # Oculta tudo menos a sele√ß√£o\r\n        model.start_operation(obter_texto(:op_nome), true)\r\n        entities.each do |e|\r\n          next if selection.include?(e)\r\n          e.visible = false if e.respond_to?(:visible=)\r\n        end\r\n\r\n        # Obter centro do modelo\r\n        bounding_box = model.bounds\r\n        centro = bounding_box.center\r\n\r\n        # Dicion√°rio de vistas corrigido\r\n        vistas = {\r\n          obter_texto(:superior)  => { dir: Geom::Vector3d.new(0, 0, -1),  up: Geom::Vector3d.new(0, -1, 0) },\r\n          obter_texto(:inferior)  => { dir: Geom::Vector3d.new(0, 0, 1),   up: Geom::Vector3d.new(0, 1, 0) },\r\n          obter_texto(:direita)   => { dir: Geom::Vector3d.new(-1, 0, 0),  up: Geom::Vector3d.new(0, 0, 1) },\r\n          obter_texto(:esquerda)  => { dir: Geom::Vector3d.new(1, 0, 0),   up: Geom::Vector3d.new(0, 0, 1) },\r\n          obter_texto(:posterior) => { dir: Geom::Vector3d.new(0, -1, 0),  up: Geom::Vector3d.new(0, 0, 1) },\r\n          obter_texto(:frontal)   => { dir: Geom::Vector3d.new(0, 1, 0),   up: Geom::Vector3d.new(0, 0, 1) },\r\n          obter_texto(:iso)       => { dir: Geom::Vector3d.new(1, 1, -1),  up: Geom::Vector3d.new(0, 0, 1) }\r\n        }\r\n\r\n        # Criar cada cena\r\n        vistas.each do |nome, dados|\r\n          dir = dados[:dir].clone.normalize!\r\n          up  = dados[:up]\r\n\r\n          from_point = centro.offset(dir.reverse!.transform(300))\r\n          to_point = centro\r\n\r\n          camera = Sketchup::Camera.new(from_point, to_point, up)\r\n          camera.perspective = false  # Proje√ß√£o paralela\r\n\r\n          view.camera = camera\r\n          view.zoom_extents\r\n\r\n          # Criar cena com prefixo\r\n          page = views.add(\"#{prefixo}#{nome}\")\r\n          page.use_camera = true\r\n        end\r\n\r\n        model.commit_operation\r\n      end\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::CriarVistasPadrao.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "criar-faces-c4bvl",
    "title": {
      "pt": "Criar Faces",
      "en": "Create Faces",
      "es": "Crear caras"
    },
    "author": "Henrique Barsa",
    "version": "1.0",
    "description": {
      "pt": "Faz o preenchimento de superf√≠cies.",
      "en": "It fills surfaces.",
      "es": "Rellena superficies."
    },
    "keywords": {
      "pt": [
        "faces",
        "buracos"
      ],
      "en": [
        "faces",
        "holes"
      ],
      "es": [
        "caras",
        "agujeros"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module BarsaFace\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :aviso_selecao => \"Nenhuma sele√ß√£o encontrada. Deseja processar todo o modelo? Essa opera√ß√£o pode demorar.\",\r\n        :op_nome       => \"Criar Faces\"\r\n      },\r\n      'en-US' => {\r\n        :aviso_selecao => \"No selection found. Do you want to process the entire model? This operation may take some time.\",\r\n        :op_nome       => \"Create Faces\"\r\n      },\r\n      'es' => {\r\n        :aviso_selecao => \"No se encontr√≥ ninguna selecci√≥n. ¬øDesea procesar todo el modelo? Esta operaci√≥n puede tardar.\",\r\n        :op_nome       => \"Crear Caras\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n\r\n      if model.selection.empty?\r\n        response = UI.messagebox(obter_texto(:aviso_selecao), MB_YESNO)\r\n        return if response != IDYES\r\n        entities = model.active_entities\r\n      else\r\n        entities = model.selection\r\n      end\r\n\r\n      entities_array = entities.to_a\r\n\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n      create_faces_recursive(entities_array)\r\n      model.commit_operation\r\n    end\r\n\r\n    def self.create_faces_recursive(entities)\r\n      entities.each do |entity|\r\n        case entity\r\n        when Sketchup::Edge\r\n          faces_before = entity.faces.to_a\r\n          entity.find_faces\r\n          new_faces = entity.faces.to_a - faces_before\r\n          new_faces.each do |face|\r\n            correct_face_orientation(face)\r\n          end\r\n        when Sketchup::Group\r\n          create_faces_recursive(entity.entities)\r\n        when Sketchup::ComponentInstance\r\n          create_faces_recursive(entity.definition.entities)\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.correct_face_orientation(face)\r\n      # Define um vetor \"cima\", pode ser Z global\r\n      up = Z_AXIS\r\n      # Se a face estiver voltada para baixo (comparado ao eixo Z)\r\n      if face.normal.angle_between(up) > 90.degrees\r\n        face.reverse!\r\n      end\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::BarsaFace.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "desbloquear-tudo-c4dts",
    "title": {
      "pt": "Desbloquear Tudo",
      "en": "Unlock Everything",
      "es": "Desbloquea todo"
    },
    "author": "F√°bio Coutinho",
    "version": "1.0",
    "description": {
      "pt": "Script para desbloquear tudo, na sele√ß√£o ou no modelo. Aninhados ou n√£o.",
      "en": "Script to unlock everything, in the selection or in the model. Nested or not.",
      "es": "Script para desbloquear todo, en la selecci√≥n o en el modelo. Anidado o no."
    },
    "keywords": {
      "pt": [
        "desbloquear",
        "unlock"
      ],
      "en": [
        "unlock",
        "unlock"
      ],
      "es": [
        "descubrir",
        "descubrir"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module DesbloquearElementos\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :pergunta_modo => \"Deseja desbloquear apenas os elementos selecionados? (Sim para Sele√ß√£o, N√£o para Todo o Modelo)\",\r\n        :op_nome       => \"Desbloquear Elementos\",\r\n        :sucesso       => \"Todos os grupos e componentes foram desbloqueados!\"\r\n      },\r\n      'en-US' => {\r\n        :pergunta_modo => \"Do you want to unlock only the selected elements? (Yes for Selection, No for Entire Model)\",\r\n        :op_nome       => \"Unlock Elements\",\r\n        :sucesso       => \"All groups and components have been unlocked!\"\r\n      },\r\n      'es' => {\r\n        :pergunta_modo => \"¬øDesea desbloquear solo los elementos seleccionados? (S√≠ para Selecci√≥n, No para todo el Modelo)\",\r\n        :op_nome       => \"Desbloquear Elementos\",\r\n        :sucesso       => \"¬°Todos los grupos y componentes han sido desbloqueados!\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.ask_user(question)\r\n      result = UI.messagebox(question, MB_YESNO)\r\n      result == IDYES\r\n    end\r\n\r\n    def self.unlock_entities(entities)\r\n      # Primeiro, desbloqueia os grupos e componentes no n√≠vel atual\r\n      entities.each do |entity|\r\n        if entity.is_a?(Sketchup::Group) || entity.is_a?(Sketchup::ComponentInstance)\r\n          if entity.locked?\r\n            entity.locked = false\r\n          end\r\n        end\r\n      end\r\n\r\n      # Depois, entra nos grupos/componentes desbloqueados para desbloquear os aninhados\r\n      entities.each do |entity|\r\n        if entity.is_a?(Sketchup::Group) || entity.is_a?(Sketchup::ComponentInstance)\r\n          unlock_entities(entity.definition.entities) # Recurs√£o para desbloquear subgrupos/subcomponentes\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      # Perguntar se deseja agir na sele√ß√£o ou no modelo inteiro\r\n      use_selection = ask_user(obter_texto(:pergunta_modo))\r\n\r\n      entities = use_selection && !selection.empty? ? selection : model.active_entities\r\n\r\n      # Processar os elementos\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n\r\n      # Desbloquear todos os grupos e componentes recursivamente\r\n      unlock_entities(entities)\r\n\r\n      model.commit_operation\r\n\r\n      UI.messagebox(obter_texto(:sucesso))\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::DesbloquearElementos.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "descer-objetos-c4g8r",
    "title": {
      "pt": "Descer Objetos",
      "en": "Lower Objects",
      "es": "Objetos inferiores"
    },
    "author": "Henrique Barsa",
    "version": "1.0",
    "description": {
      "pt": "Desce o objeto at√© o abaixo dele.",
      "en": "Lower the object to the one below it.",
      "es": "Baja el objeto hasta el que est√° debajo de √©l."
    },
    "keywords": {
      "pt": [
        "drop",
        "descer"
      ],
      "en": [
        "drop",
        "to descend"
      ],
      "es": [
        "gota",
        "descender"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module ProjetarNoChao\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao => \"Nenhum objeto selecionado. Selecione ao menos um grupo ou componente.\",\r\n        :erro_raytest => \"Nenhuma geometria foi encontrada abaixo de %s para a interse√ß√£o.\",\r\n        :op_nome      => \"Projetar no Solo\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao => \"No objects selected. Please select at least one group or component.\",\r\n        :erro_raytest => \"No geometry was found below %s for intersection.\",\r\n        :op_nome      => \"Drop to Ground\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao => \"Ning√∫n objeto seleccionado. Seleccione al menos un grupo o componente.\",\r\n        :erro_raytest => \"No se encontr√≥ geometr√≠a debajo de %s para la intersecci√≥n.\",\r\n        :op_nome      => \"Proyectar al Suelo\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      ss = model.selection\r\n      \r\n      # Verifica se h√° algo selecionado\r\n      if ss.empty?\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n\r\n      dir = [0, 0, -1] # vetor para baixo (Z negativo)\r\n\r\n      ss.each do |entity|\r\n        next unless entity.respond_to?(:transformation)\r\n        \r\n        position = entity.transformation.origin\r\n        # Retorna [Geom::Point3d, entidade_intersectada]\r\n        rt = model.raytest(position, dir)\r\n\r\n        if rt.nil?\r\n          UI.messagebox(obter_texto(:erro_raytest) % entity.to_s)\r\n        else\r\n          intersect_pt = rt[0]\r\n          new_z = intersect_pt.z\r\n          \r\n          # Aplica a transforma√ß√£o mantendo X e Y, alterando apenas Z\r\n          tr = entity.transformation.to_a\r\n          tr[14] = new_z\r\n          entity.transformation = tr\r\n        end\r\n      end\r\n\r\n      model.commit_operation\r\n      \r\n      # For√ßa uma atualiza√ß√£o visual\r\n      model.active_view.invalidate\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::ProjetarNoChao.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "escala-por-eixo-mantendo-proporcao-c4hre",
    "title": {
      "pt": "Escala por Eixo Mantendo Propor√ß√£o",
      "en": "Scaling by Axis Maintaining Proportion",
      "es": "Escalado por eje manteniendo la proporci√≥n"
    },
    "author": "Ludimila Siqueira",
    "version": "1.0",
    "description": {
      "pt": "Altera a escala por eixo com possibilidade de manter a propor√ß√£o nos demais eixos.",
      "en": "It changes the scale on each axis while maintaining the aspect ratio on the other axes.",
      "es": "Cambia la escala en cada eje mientras mantiene la relaci√≥n de aspecto en los otros ejes."
    },
    "keywords": {
      "pt": [
        "escala por eixo",
        "propor√ß√£o"
      ],
      "en": [
        "scale by axis",
        "proportion"
      ],
      "es": [
        "escala por eje",
        "proporci√≥n"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module EscalarPorEixo\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :titulo_janela    => \"Escalar Componente por Eixo\",\r\n        :label_eixo       => \"Eixo de refer√™ncia:\",\r\n        :label_comprimento => \"Comprimento desejado:\",\r\n        :label_proporcao  => \"Manter propor√ß√£o\",\r\n        :btn_aplicar      => \"Aplicar Escala\",\r\n        :erro_selecao     => \"Selecione um √∫nico componente ou grupo.\",\r\n        :erro_eixo        => \"Eixo inv√°lido. Use X, Y ou Z.\",\r\n        :erro_dimensao    => \"A dimens√£o atual no eixo %s √© zero.\",\r\n        :op_nome          => \"Escalar por eixo\"\r\n      },\r\n      'en-US' => {\r\n        :titulo_janela    => \"Scale Component by Axis\",\r\n        :label_eixo       => \"Reference axis:\",\r\n        :label_comprimento => \"Desired length:\",\r\n        :label_proporcao  => \"Maintain proportion\",\r\n        :btn_aplicar      => \"Apply Scale\",\r\n        :erro_selecao     => \"Select a single component or group.\",\r\n        :erro_eixo        => \"Invalid axis. Use X, Y or Z.\",\r\n        :erro_dimensao    => \"The current dimension on axis %s is zero.\",\r\n        :op_nome          => \"Scale by axis\"\r\n      },\r\n      'es' => {\r\n        :titulo_janela    => \"Escalar Componente por Eje\",\r\n        :label_eixo       => \"Eje de referencia:\",\r\n        :label_comprimento => \"Longitud deseada:\",\r\n        :label_proporcao  => \"Mantener proporci√≥n\",\r\n        :btn_aplicar      => \"Aplicar Escala\",\r\n        :erro_selecao     => \"Seleccione un solo componente o grupo.\",\r\n        :erro_eixo        => \"Eje inv√°lido. Use X, Y o Z.\",\r\n        :erro_dimensao    => \"La dimensi√≥n actual en el eje %s es cero.\",\r\n        :op_nome          => \"Escalar por eje\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.show_ui\r\n      dlg = UI::HtmlDialog.new({\r\n        dialog_title: obter_texto(:titulo_janela),\r\n        preferences_key: \"scale_by_axis\",\r\n        scrollable: true,\r\n        resizable: false,\r\n        width: 320,\r\n        height: 260,\r\n        style: UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n\r\n      html = <<-HTML\r\n        <!DOCTYPE html>\r\n        <html>\r\n        <body style=\"font-family: sans-serif; margin: 10px;\">\r\n          <label for=\"axis\">#{obter_texto(:label_eixo)}</label><br>\r\n          <select id=\"axis\">\r\n            <option value=\"X\">X</option>\r\n            <option value=\"Y\">Y</option>\r\n            <option value=\"Z\">Z</option>\r\n          </select><br><br>\r\n\r\n          <label for=\"length\">#{obter_texto(:label_comprimento)}</label><br>\r\n          <input type=\"number\" id=\"length\" value=\"100\" />\r\n          <select id=\"unit\">\r\n            <option value=\"cm\" selected>cm</option>\r\n            <option value=\"m\">m</option>\r\n            <option value=\"mm\">mm</option>\r\n          </select><br><br>\r\n\r\n          <input type=\"checkbox\" id=\"proportional\" checked />\r\n          <label for=\"proportional\">#{obter_texto(:label_proporcao)}</label><br><br>\r\n\r\n          <button onclick=\"applyScale()\">#{obter_texto(:btn_aplicar)}</button>\r\n\r\n          <script>\r\n            function applyScale() {\r\n              const axis = document.getElementById('axis').value;\r\n              const length = parseFloat(document.getElementById('length').value);\r\n              const unit = document.getElementById('unit').value;\r\n              const proportional = document.getElementById('proportional').checked;\r\n              window.sketchup.apply_scale(axis, length, proportional, unit);\r\n            }\r\n          </script>\r\n        </body>\r\n        </html>\r\n      HTML\r\n\r\n      dlg.set_html(html)\r\n\r\n      dlg.add_action_callback(\"apply_scale\") do |_, axis, length, proportional, unit|\r\n        apply_scale(axis, length.to_f, proportional == true || proportional == \"true\", unit)\r\n      end\r\n\r\n      dlg.show\r\n    end\r\n\r\n    def self.apply_scale(axis, target_length, keep_proportion, unit)\r\n      model = Sketchup.active_model\r\n      sel = model.selection\r\n\r\n      unless sel.length == 1 && (sel.first.is_a?(Sketchup::ComponentInstance) || sel.first.is_a?(Sketchup::Group))\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n\r\n      instance = sel.first\r\n      bbox = instance.bounds\r\n\r\n      current_size = case axis\r\n      when 'X' then bbox.width\r\n      when 'Y' then bbox.height\r\n      when 'Z' then bbox.depth\r\n      else\r\n        UI.messagebox(obter_texto(:erro_eixo))\r\n        return\r\n      end\r\n\r\n      if current_size <= 0\r\n        UI.messagebox(obter_texto(:erro_dimensao) % axis)\r\n        return\r\n      end\r\n\r\n      length_inches = case unit\r\n      when 'cm' then target_length.cm\r\n      when 'm'  then target_length.m\r\n      when 'mm' then target_length.mm\r\n      else target_length.cm\r\n      end\r\n\r\n      scale_factor = length_inches / current_size\r\n\r\n      x_scale = (keep_proportion || axis == 'X') ? scale_factor : 1.0\r\n      y_scale = (keep_proportion || axis == 'Y') ? scale_factor : 1.0\r\n      z_scale = (keep_proportion || axis == 'Z') ? scale_factor : 1.0\r\n\r\n      t = Geom::Transformation.scaling(instance.transformation.origin, x_scale, y_scale, z_scale)\r\n\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n      instance.transform!(t)\r\n      model.commit_operation\r\n    end\r\n  end\r\nend\r\n\r\nScriptUpComunidade::EscalarPorEixo.show_ui"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "mapeamento-uv-em-malha-curva-c4jfl",
    "title": {
      "pt": "Mapeamento UV em Malha Curva",
      "en": "UV Mapping on Curved Mesh",
      "es": "Mapeo UV en malla curva"
    },
    "author": "F√°bio Coutinho",
    "version": "1.6",
    "description": {
      "pt": "Promove o mapeamento UV de texturas aplicadas em superf√≠cie curva.",
      "en": "It promotes UV mapping of textures applied to curved surfaces.",
      "es": "Promueve el mapeo UV de texturas aplicadas a superficies curvas."
    },
    "keywords": {
      "pt": [
        "uv map"
      ],
      "en": [
        "uv map"
      ],
      "es": [
        "mapa uv"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module MapeadorUV\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :ativar_msg      => \"üñ±Ô∏è Clique em uma face com textura aplicada (ou com material aplicado em grupo acima).\",\r\n        :status_inicio   => \"Mova o mouse sobre a malha para escolher a face e o ponto inicial.\",\r\n        :erro_face       => \"‚ùå Clique em uma face v√°lida com textura aplicada ou grupo com material.\",\r\n        :status_erro     => \"‚ùå Nenhuma face v√°lida foi selecionada. Clique em uma face com textura.\",\r\n        :ponto1_capt     => \"üìå Ponto 1 capturado: %s\",\r\n        :msg_ponto2      => \"üñ±Ô∏è Mova o mouse e clique no segundo ponto para ajustar a dire√ß√£o do mapeamento.\",\r\n        :status_ponto2   => \"Agora clique em um segundo ponto na face para definir o sentido do mapeamento.\",\r\n        :op_nome         => \"Mapeamento UV Din√¢mico\",\r\n        :ponto2_capt     => \"üìå Ponto 2 capturado: %s\",\r\n        :finalizado      => \"‚úÖ Mapeamento finalizado. Clique em nova face ou mude de ferramenta para sair.\",\r\n        :status_final    => \"Mapeamento aplicado! Clique em nova face ou mude de ferramenta.\",\r\n        :erro_dinamico   => \"‚ö†Ô∏è Erro durante mapeamento din√¢mico: %s\",\r\n        :erro_material   => \"‚ùå Nenhum material com textura encontrado na hierarquia. Aplique um material primeiro.\",\r\n        :aviso_triang    => \"üî∫ Face com mais de 4 v√©rtices ‚Äî mapeando via triangula√ß√£o inicial\",\r\n        :aviso_limitacao => \"‚ö†Ô∏è Face com mais de 4 v√©rtices ‚Äì aplicando apenas nos 4 primeiros v√©rtices para evitar erro.\",\r\n        :erro_sketchup   => \"‚ö†Ô∏è Face ignorada (SketchUp): %s\",\r\n        :insuficiente    => \"‚õî Mapeamento insuficiente em face adjacente, ignorada.\"\r\n      },\r\n      'en-US' => {\r\n        :ativar_msg      => \"üñ±Ô∏è Click on a face with texture applied (or material applied to a group above).\",\r\n        :status_inicio   => \"Move mouse over the mesh to choose face and start point.\",\r\n        :erro_face       => \"‚ùå Click on a valid face with texture or group with material.\",\r\n        :status_erro     => \"‚ùå No valid face selected. Click on a face with texture.\",\r\n        :ponto1_capt     => \"üìå Point 1 captured: %s\",\r\n        :msg_ponto2      => \"üñ±Ô∏è Move mouse and click on second point to adjust mapping direction.\",\r\n        :status_ponto2   => \"Now click a second point on the face to define mapping direction.\",\r\n        :op_nome         => \"Dynamic UV Mapping\",\r\n        :ponto2_capt     => \"üìå Point 2 captured: %s\",\r\n        :finalizado      => \"‚úÖ Mapping finished. Click a new face or change tool to exit.\",\r\n        :status_final    => \"Mapping applied! Click a new face or change tool.\",\r\n        :erro_dinamico   => \"‚ö†Ô∏è Error during dynamic mapping: %s\",\r\n        :erro_material   => \"‚ùå No textured material found in hierarchy. Apply a material first.\",\r\n        :aviso_triang    => \"üî∫ Face with more than 4 vertices ‚Äî mapping via initial triangulation\",\r\n        :aviso_limitacao => \"‚ö†Ô∏è Face with more than 4 vertices ‚Äì applying only to first 4 vertices to avoid error.\",\r\n        :erro_sketchup   => \"‚ö†Ô∏è Face ignored (SketchUp): %s\",\r\n        :insuficiente    => \"‚õî Insufficient mapping on adjacent face, ignored.\"\r\n      },\r\n      'es' => {\r\n        :ativar_msg      => \"üñ±Ô∏è Haga clic en una cara con textura aplicada (o material aplicado en grupo superior).\",\r\n        :status_inicio   => \"Mueva el rat√≥n sobre la malla para elegir la cara y el punto inicial.\",\r\n        :erro_face       => \"‚ùå Haga clic en una cara v√°lida con textura o grupo con material.\",\r\n        :status_erro     => \"‚ùå No se seleccion√≥ ninguna cara v√°lida. Haga clic en una cara con textura.\",\r\n        :ponto1_capt     => \"üìå Punto 1 capturado: %s\",\r\n        :msg_ponto2      => \"üñ±Ô∏è Mueva el rat√≥n y haga clic en el segundo punto para ajustar la direcci√≥n.\",\r\n        :status_ponto2   => \"Ahora haga clic en un segundo punto en la cara para definir el sentido del mapeo.\",\r\n        :op_nome         => \"Mapeo UV Din√°mico\",\r\n        :ponto2_capt     => \"üìå Punto 2 capturado: %s\",\r\n        :finalizado      => \"‚úÖ Mapeo finalizado. Haga clic en una nueva cara o cambie de herramienta para salir.\",\r\n        :status_final    => \"¬°Mapeo aplicado! Haga clic en una nueva cara o cambie de herramienta.\",\r\n        :erro_dinamico   => \"‚ö†Ô∏è Error durante el mapeo din√°mico: %s\",\r\n        :erro_material   => \"‚ùå No se encontr√≥ material con textura en la jerarqu√≠a. Aplique un material primero.\",\r\n        :aviso_triang    => \"üî∫ Cara con m√°s de 4 v√©rtices ‚Äî mapeando v√≠a triangulaci√≥n inicial\",\r\n        :aviso_limitacao => \"‚ö†Ô∏è Cara con m√°s de 4 v√©rtices ‚Äì aplicando solo a los primeros 4 para evitar errores.\",\r\n        :erro_sketchup   => \"‚ö†Ô∏è Cara ignorada (SketchUp): %s\",\r\n        :insuficiente    => \"‚õî Mapeo insuficiente en cara adyacente, ignorada.\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    TOLERANCE = 0.001 unless defined?(TOLERANCE)\r\n\r\n    class DynamicDirectionTool\r\n      def initialize\r\n        reset\r\n      end\r\n\r\n      def reset\r\n        @state = 0\r\n        @picked_face = nil\r\n        @input1 = Sketchup::InputPoint.new\r\n        @input2 = Sketchup::InputPoint.new\r\n        @ip_temp = Sketchup::InputPoint.new\r\n        @last_vector = nil\r\n      end\r\n\r\n      def activate\r\n        puts MapeadorUV.obter_texto(:ativar_msg)\r\n        Sketchup.set_status_text(MapeadorUV.obter_texto(:status_inicio), SB_PROMPT)\r\n      end\r\n\r\n      def onMouseMove(flags, x, y, view)\r\n        if @state == 0\r\n          @ip_temp.pick(view, x, y)\r\n          view.invalidate\r\n        elsif @state == 1\r\n          @input2.pick(view, x, y, @input1)\r\n          view.invalidate\r\n\r\n          return unless @input2.valid?\r\n\r\n          new_vec = @input2.position - @input1.position\r\n          return if new_vec.length < 1e-4\r\n\r\n          unless @last_vector && MapeadorUV.safe_samedirection?(@last_vector, new_vec)\r\n            @last_vector = new_vec\r\n            begin\r\n              success = MapeadorUV.reapply_mapping_on_face(@picked_face, @input1.position, @input2.position, @input1)\r\n              MapeadorUV.propagate_uv_using_uvhelper(@picked_face) if success\r\n            rescue => e\r\n              puts MapeadorUV.obter_texto(:erro_dinamico) % e.message\r\n            end\r\n          end\r\n        end\r\n      end\r\n\r\n      def onLButtonDown(flags, x, y, view)\r\n        model = Sketchup.active_model\r\n\r\n        if @state == 0\r\n          @input1.pick(view, x, y)\r\n          if !@input1.face\r\n            puts MapeadorUV.obter_texto(:erro_face)\r\n            Sketchup.set_status_text(MapeadorUV.obter_texto(:status_erro), SB_PROMPT)\r\n            return\r\n          end\r\n          @picked_face = @input1.face\r\n          puts MapeadorUV.obter_texto(:ponto1_capt) % @input1.position.to_s\r\n          puts MapeadorUV.obter_texto(:msg_ponto2)\r\n          Sketchup.set_status_text(MapeadorUV.obter_texto(:status_ponto2), SB_PROMPT)\r\n          model.start_operation(MapeadorUV.obter_texto(:op_nome), true)\r\n          @state = 1\r\n        elsif @state == 1\r\n          @input2.pick(view, x, y, @input1)\r\n          puts MapeadorUV.obter_texto(:ponto2_capt) % @input2.position.to_s\r\n          model.commit_operation\r\n          reset\r\n          puts MapeadorUV.obter_texto(:finalizado)\r\n          Sketchup.set_status_text(MapeadorUV.obter_texto(:status_final), SB_PROMPT)\r\n        end\r\n      end\r\n\r\n      def draw(view)\r\n        if @state == 0 && @ip_temp.valid? && @ip_temp.face\r\n          path = @ip_temp.instance_path\r\n          trans = path ? path.transformation : IDENTITY\r\n          view.drawing_color = 'red'\r\n          points = @ip_temp.face.outer_loop.vertices.map { |v| v.position.transform(trans) }\r\n          view.draw(GL_LINE_LOOP, points)\r\n        end\r\n\r\n        if @input1.valid?\r\n          view.drawing_color = 'green'\r\n          view.draw_points([@input1.position], 10, 3)\r\n        end\r\n\r\n        if @input2.valid?\r\n          view.drawing_color = 'green'\r\n          view.draw_points([@input2.position], 10, 3)\r\n          view.drawing_color = 'red'\r\n          view.draw_line(@input1.position, @input2.position)\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      Sketchup.active_model.tools.push_tool(DynamicDirectionTool.new)\r\n      true\r\n    end\r\n\r\n    def self.safe_samedirection?(vec1, vec2)\r\n      return false unless vec1.is_a?(Geom::Vector3d) && vec2.is_a?(Geom::Vector3d)\r\n      return false if vec1.length < 1e-4 || vec2.length < 1e-4\r\n      vec1.samedirection?(vec2)\r\n    rescue\r\n      false\r\n    end\r\n\r\n    def self.find_material_in_path(input_point)\r\n      return nil unless input_point\r\n      path = input_point.instance_path\r\n      return nil unless path\r\n      path.reverse_each do |entity|\r\n        next unless entity.respond_to?(:material)\r\n        mat = entity.material\r\n        return mat if mat && mat.texture\r\n      end\r\n      nil\r\n    end\r\n\r\n    def self.reapply_mapping_on_face(face, pt1, pt2, input_point)\r\n      material = face.material\r\n      material ||= find_material_in_path(input_point)\r\n\r\n      unless material && material.texture\r\n        puts obter_texto(:erro_material)\r\n        return false\r\n      end\r\n\r\n      return false if pt1.distance(pt2) < 1e-4\r\n\r\n      tex = material.texture\r\n      tex_w = tex.width.to_f\r\n      tex_h = tex.height.to_f\r\n\r\n      u_axis = (pt2 - pt1).normalize\r\n      z_axis = face.normal\r\n      v_axis = z_axis.cross(u_axis)\r\n      return false if v_axis.length < 1e-6\r\n      v_axis.normalize!\r\n      origin = pt1\r\n\r\n      if face.vertices.size > 4\r\n        puts obter_texto(:aviso_triang)\r\n        mesh = face.mesh(7)\r\n        points = mesh.points\r\n        uv_by_point = {}\r\n\r\n        points.each do |pos|\r\n          vec = pos - origin\r\n          u = vec.dot(u_axis) / tex_w\r\n          v = vec.dot(v_axis) / tex_h\r\n          uv_by_point[pos] = Geom::Point3d.new(u, v, 0)\r\n        end\r\n\r\n        triangles = mesh.polygons.map do |indices|\r\n          indices = indices.map { |i| i.abs - 1 }\r\n          [points[indices[0]], points[indices[1]], points[indices[2]]]\r\n        end\r\n\r\n        ents = face.parent.entities\r\n        ents.erase_entities(face)\r\n\r\n        triangles.each do |tri_pts|\r\n          new_face = ents.add_face(tri_pts)\r\n          next unless new_face && new_face.valid?\r\n          new_face.material = material\r\n\r\n          mapping = tri_pts.map { |pt| [pt, uv_by_point[pt]] }.flatten\r\n          begin\r\n            new_face.position_material(material, mapping, true)\r\n          rescue => e\r\n            puts \"‚ö†Ô∏è Erro: #{e.message}\"\r\n          end\r\n\r\n          new_face.edges.each do |edge|\r\n            edge.soft = true\r\n            edge.smooth = true\r\n            edge.hidden = false\r\n          end\r\n        end\r\n        return true\r\n      end\r\n\r\n      mapping = []\r\n      face.vertices.each do |v|\r\n        pos = v.position\r\n        vec = pos - origin\r\n        u = vec.dot(u_axis) / tex_w\r\n        v = vec.dot(v_axis) / tex_h\r\n        mapping << pos\r\n        mapping << Geom::Point3d.new(u, v, 0)\r\n      end\r\n\r\n      mapping = mapping[0, 8] if mapping.size > 8\r\n      face.material = material\r\n      face.position_material(material, mapping, true)\r\n      true\r\n    rescue => e\r\n      puts \"‚ö†Ô∏è Erro: #{e.message}\"\r\n      false\r\n    end\r\n\r\n    def self.propagate_uv_using_uvhelper(start_face)\r\n      material = start_face.material || find_material_in_path(Sketchup::InputPoint.new.tap { |ip| ip.pick(start_face.vertices.first.position) })\r\n      return unless material && material.texture\r\n\r\n      visited = {}\r\n      queue = [start_face]\r\n      visited[start_face] = true\r\n\r\n      while !queue.empty?\r\n        current_face = queue.shift\r\n        current_face.material = material\r\n\r\n        tw = Sketchup.create_texture_writer\r\n        tw.load(current_face, true)\r\n        uv_helper = current_face.get_UVHelper(true, true, tw)\r\n\r\n        current_face.edges.each do |edge|\r\n          next unless edge.soft?\r\n          edge.faces.each do |adj_face|\r\n            next if adj_face == current_face || visited[adj_face]\r\n            visited[adj_face] = true\r\n            shared_vertices = adj_face.vertices.select { |v1|\r\n              current_face.vertices.any? { |v2| v1.position.distance(v2.position) < TOLERANCE }\r\n            }\r\n            next if shared_vertices.size < 2\r\n\r\n            if adj_face.vertices.size <= 4\r\n              mapping_array = adj_face.vertices.map do |v|\r\n                pos = v.position\r\n                uvq = uv_helper.get_front_UVQ(pos)\r\n                (uvq && uvq.z != 0) ? [pos, Geom::Point3d.new(uvq.x / uvq.z, uvq.y / uvq.z, 0)] : nil\r\n              end.compact.flatten\r\n\r\n              if mapping_array.size > 8\r\n                puts obter_texto(:aviso_limitacao)\r\n                mapping_array = mapping_array[0, 8]\r\n              end\r\n\r\n              if mapping_array.size >= 6\r\n                begin\r\n                  adj_face.material = material\r\n                  adj_face.position_material(material, mapping_array, true)\r\n                  queue << adj_face\r\n                rescue ArgumentError => e\r\n                  puts obter_texto(:erro_sketchup) % e.message\r\n                end\r\n              else\r\n                puts obter_texto(:insuficiente)\r\n              end\r\n            else\r\n              triangulate_and_map_face(adj_face, uv_helper, material)\r\n            end\r\n          end\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.triangulate_and_map_face(face, uv_helper, material)\r\n      mesh = face.mesh(7)\r\n      ents = face.parent.entities\r\n      points = mesh.points\r\n      uv_by_point = {}\r\n      points.each do |pt|\r\n        uvq = uv_helper.get_front_UVQ(pt)\r\n        uv = (uvq && uvq.z != 0) ? Geom::Point3d.new(uvq.x / uvq.z, uvq.y / uvq.z, 0) : Geom::Point3d.new(0, 0, 0)\r\n        uv_by_point[pt] = uv\r\n      end\r\n      model_edges_before = ents.grep(Sketchup::Edge).to_set\r\n      ents.erase_entities(face)\r\n      mesh.polygons.each do |indices|\r\n        tri_pts = indices.map { |i| points[i.abs - 1] }\r\n        new_face = ents.add_face(tri_pts)\r\n        next unless new_face && new_face.valid?\r\n        new_face.material = material\r\n        mapping = tri_pts.map { |pt| [pt, uv_by_point[pt]] }.flatten\r\n        begin\r\n          new_face.position_material(material, mapping, true)\r\n        rescue => e\r\n          puts \"‚ö†Ô∏è Erro: #{e.message}\"\r\n        end\r\n        new_face.edges.each do |edge|\r\n          unless model_edges_before.include?(edge)\r\n            edge.soft = true\r\n            edge.smooth = true\r\n            edge.hidden = false\r\n          end\r\n        end\r\n      end\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::MapeadorUV.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "nivelador-de-grupos-e-componentes-c4l8s",
    "title": {
      "pt": "Nivelador de Grupos e Componentes",
      "en": "Group and Component Leveler",
      "es": "Nivelador de grupos y componentes"
    },
    "author": "Irene Magalh√£es",
    "version": "1.0",
    "description": {
      "pt": "Define o n√≠vel (altura Z) de grupos e componentes respeitando a unidade do modelo. Inspirado no drop of level.",
      "en": "Defines the level (Z-height) of groups and components while respecting the model's unity. Inspired by the drop-of-level principle.",
      "es": "Define el nivel (altura Z) de grupos y componentes, respetando la unidad del modelo. Inspirado en el principio de ca√≠da de nivel."
    },
    "keywords": {
      "pt": [
        "altura",
        "n√≠vel"
      ],
      "en": [
        "height",
        "level"
      ],
      "es": [
        "altura",
        "nivel"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module DefinirNivel\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :label_altura  => \"Altura (na unidade do modelo):\",\r\n        :titulo_input  => \"Definir N√≠vel do Objeto\",\r\n        :erro_selecao  => \"Por favor, selecione pelo menos um elemento.\",\r\n        :op_nome       => \"Ajustar N√≠vel\",\r\n        :log_info      => \"Comando 'N√≠vel' executado por Irene Magalh√£es ‚îÇ arq ‚Äì v1.00\"\r\n      },\r\n      'en-US' => {\r\n        :label_altura  => \"Height (model unit):\",\r\n        :titulo_input  => \"Set Object Level\",\r\n        :erro_selecao  => \"Please select at least one element.\",\r\n        :op_nome       => \"Adjust Level\",\r\n        :log_info      => \"Command 'Level' executed by Irene Magalh√£es ‚îÇ arq ‚Äì v1.00\"\r\n      },\r\n      'es' => {\r\n        :label_altura  => \"Altura (unidad del modelo):\",\r\n        :titulo_input  => \"Definir Nivel del Objeto\",\r\n        :erro_selecao  => \"Por favor, seleccione al menos un elemento.\",\r\n        :op_nome       => \"Ajustar Nivel\",\r\n        :log_info      => \"Comando 'Nivel' ejecutado por Irene Magalh√£es ‚îÇ arq ‚Äì v1.00\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.get_height_from_user\r\n      prompts = [obter_texto(:label_altura)]\r\n      defaults = [\"0\"]\r\n      input = UI.inputbox(prompts, defaults, obter_texto(:titulo_input))\r\n      return nil unless input\r\n      input[0].to_l\r\n    end\r\n\r\n    def self.validate_selection\r\n      selection = Sketchup.active_model.selection\r\n      if selection.empty?\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return false\r\n      end\r\n      true\r\n    end\r\n\r\n    def self.perform_drop(entity, height)\r\n      case entity\r\n      when Sketchup::Group, Sketchup::ComponentInstance\r\n        current_z = entity.transformation.origin.z\r\n        delta_z = height - current_z\r\n        entity.transform!(Geom::Transformation.translation([0, 0, delta_z]))\r\n      when Sketchup::Edge\r\n        entity.vertices.each do |vertex|\r\n          pos = vertex.position\r\n          vertex.position = Geom::Point3d.new(pos.x, pos.y, height)\r\n        end\r\n      when Sketchup::Face\r\n        # Usando o centro do bounding box para faces para determinar o deslocamento Z\r\n        current_z = entity.bounds.center.z\r\n        delta_z = height - current_z\r\n        entity.transform!(Geom::Transformation.translation([0, 0, delta_z]))\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      return unless validate_selection\r\n\r\n      height = get_height_from_user\r\n      return unless height\r\n\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n      \r\n      selection = model.selection\r\n      selection.each { |entity| perform_drop(entity, height) }\r\n\r\n      model.commit_operation\r\n      model.active_view.invalidate\r\n\r\n      puts obter_texto(:log_info)\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::DefinirNivel.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "ocultar-linhas-do-bloco-c4ms5",
    "title": {
      "pt": "Ocultar Linhas do Bloco",
      "en": "Hide Block Lines",
      "es": "Ocultar l√≠neas de bloque"
    },
    "author": "Matheus Narita",
    "version": "1.0",
    "description": {
      "pt": "Oculta todas as arestas dentro dos grupos e componentes selecionados, incluindo os aninhados.",
      "en": "Hides all edges within the selected groups and components, including nested ones.",
      "es": "Oculta todos los bordes dentro de los grupos y componentes seleccionados, incluidos los anidados."
    },
    "keywords": {
      "pt": [
        "ocultar linhas"
      ],
      "en": [
        "hide lines"
      ],
      "es": [
        "ocultar l√≠neas"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module OcultarLinhasBlocos\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :op_nome => \"Ocultar Linhas do Bloco\",\r\n        :sucesso => \"Linhas ocultadas dentro dos blocos selecionados!\"\r\n      },\r\n      'en-US' => {\r\n        :op_nome => \"Hide Block Edges\",\r\n        :sucesso => \"Edges hidden inside selected blocks!\"\r\n      },\r\n      'es' => {\r\n        :op_nome => \"Ocultar L√≠neas del Bloque\",\r\n        :sucesso => \"¬°L√≠neas ocultadas dentro de los bloques seleccionados!\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.ocultar_linhas(entities)\r\n      entities.grep(Sketchup::Edge).each do |edge|\r\n        edge.hidden = true\r\n      end\r\n\r\n      # Percorrer grupos e componentes aninhados tamb√©m\r\n      entities.grep(Sketchup::Group).each { |group| ocultar_linhas(group.entities) }\r\n      entities.grep(Sketchup::ComponentInstance).each { |comp| ocultar_linhas(comp.definition.entities) }\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n\r\n      selection.each do |entity|\r\n        if entity.is_a?(Sketchup::Group)\r\n          ocultar_linhas(entity.entities)\r\n        elsif entity.is_a?(Sketchup::ComponentInstance)\r\n          ocultar_linhas(entity.definition.entities)\r\n        end\r\n      end\r\n\r\n      model.commit_operation\r\n\r\n      puts obter_texto(:sucesso)\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::OcultarLinhasBlocos.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "orbitar-360-c4oua",
    "title": {
      "pt": "Orbitar 360¬∫",
      "en": "Orbit 360¬∫",
      "es": "√ìrbita 360¬∫"
    },
    "author": "F√°bio Couitnho",
    "version": "1.0",
    "description": {
      "pt": "Orbita, de forma cont√≠nua, 360¬∫ ao redor de um elemento selecionado, podendo controlar a velorcidade, √¢ngulo de observa√ß√£o e dist√¢ncia do objetivo.",
      "en": "It orbits continuously 360¬∫ around a selected element, allowing control over speed, viewing angle, and distance from the target.",
      "es": "Orbita continuamente 360¬∫ alrededor de un elemento seleccionado, lo que permite controlar la velocidad, el √°ngulo de visi√≥n y la distancia al objetivo."
    },
    "keywords": {
      "pt": [
        "orbitar 360"
      ],
      "en": [
        "orbit 360"
      ],
      "es": [
        "√≥rbita 360"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module VisualizacaoOrbital\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao   => \"‚ùå Selecione algum elemento antes de executar.\",\r\n        :erro_volume    => \"‚ùå Nenhum elemento com volume vis√≠vel foi encontrado na sele√ß√£o.\",\r\n        :titulo_janela  => \"Visualiza√ß√£o Orbital Cont√≠nua\",\r\n        :label_rpm      => \"Velocidade (voltas por minuto):\",\r\n        :label_pitch    => \"Inclina√ß√£o (√¢ngulo vertical):\",\r\n        :label_dist     => \"Dist√¢ncia do observador:\",\r\n        :btn_encerrar   => \"üõë Encerrar Visualiza√ß√£o\",\r\n        :msg_encerrado  => \"‚èπÔ∏è Visualiza√ß√£o orbital encerrada.\",\r\n        :op_nome        => \"√ìrbita de C√¢mera\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao   => \"‚ùå Select an element before running.\",\r\n        :erro_volume    => \"‚ùå No visible elements with volume found in selection.\",\r\n        :titulo_janela  => \"Continuous Orbit View\",\r\n        :label_rpm      => \"Speed (rotations per minute):\",\r\n        :label_pitch    => \"Pitch (vertical angle):\",\r\n        :label_dist     => \"Observer distance:\",\r\n        :btn_encerrar   => \"üõë Stop Visualization\",\r\n        :msg_encerrado  => \"‚èπÔ∏è Orbital visualization stopped.\",\r\n        :op_nome        => \"Camera Orbit\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao   => \"‚ùå Seleccione alg√∫n elemento antes de ejecutar.\",\r\n        :erro_volume    => \"‚ùå No se encontraron elementos con volumen visible en la selecci√≥n.\",\r\n        :titulo_janela  => \"Visualizaci√≥n Orbital Continua\",\r\n        :label_rpm      => \"Velocidad (vueltas por minuto):\",\r\n        :label_pitch    => \"Inclinaci√≥n (√°ngulo vertical):\",\r\n        :label_dist     => \"Distancia del observador:\",\r\n        :btn_encerrar   => \"üõë Finalizar Visualizaci√≥n\",\r\n        :msg_encerrado  => \"‚èπÔ∏è Visualizaci√≥n orbital finalizada.\",\r\n        :op_nome        => \"√ìrbita de C√°mara\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.rpm_to_rad_per_frame(rpm)\r\n      (rpm * 2 * Math::PI) / 60.0 / 60.0\r\n    end\r\n\r\n    def self.deg_to_rad(deg)\r\n      deg * Math::PI / 180.0\r\n    end\r\n\r\n    def self.update_camera_orbit\r\n      view = Sketchup.active_model.active_view\r\n      camera = view.camera\r\n\r\n      $orbita_angle += rpm_to_rad_per_frame($orbita_rpm)\r\n      radius = $orbita_base_radius * $orbita_radius_multiplier\r\n      pitch_rad = deg_to_rad($orbita_pitch_deg)\r\n\r\n      x = radius * Math.cos($orbita_angle)\r\n      y = radius * Math.sin($orbita_angle)\r\n      horizontal_distance = Math.sqrt(x**2 + y**2)\r\n      dz = Math.tan(pitch_rad) * horizontal_distance\r\n      z = $orbita_center.z + dz\r\n\r\n      eye = Geom::Point3d.new($orbita_center.x + x, $orbita_center.y + y, z)\r\n      target = $orbita_center\r\n\r\n      direction = target - eye\r\n      z_axis = Geom::Vector3d.new(0, 0, 1)\r\n      right = direction.cross(z_axis).normalize\r\n      up = right.cross(direction).normalize\r\n\r\n      camera.set(eye, target, up)\r\n      view.camera = camera\r\n      view.refresh\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      if selection.empty?\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n\r\n      bounds = Geom::BoundingBox.new\r\n      tem_bounds = false\r\n\r\n      selection.each do |e|\r\n        if e.respond_to?(:bounds)\r\n          bounds.add(e.bounds)\r\n          tem_bounds = true\r\n        end\r\n      end\r\n\r\n      if !tem_bounds\r\n        UI.messagebox(obter_texto(:erro_volume))\r\n        return\r\n      end\r\n\r\n      $orbita_center = bounds.center\r\n      model.selection.clear\r\n      $orbita_base_radius = bounds.diagonal * 1.5\r\n\r\n      $orbita_angle = 0.0\r\n      $orbita_rpm = 2.0\r\n      $orbita_pitch_deg = 15.0\r\n      $orbita_radius_multiplier = 1.0\r\n\r\n      $orbita_timer = UI.start_timer(0.016, true) { update_camera_orbit }\r\n\r\n      html = <<-HTML\r\n      <html>\r\n        <body style=\"font-family:system-ui; margin:16px; background:#f9f9f9;\">\r\n          <h2>üé• #{obter_texto(:titulo_janela)}</h2>\r\n\r\n          <label for=\"rpm\"><b>#{obter_texto(:label_rpm)}</b></label><br>\r\n          <input type=\"range\" id=\"rpm\" min=\"0.1\" max=\"20\" step=\"0.1\" value=\"#{$orbita_rpm}\" style=\"width:100%;\">\r\n          <div><span id=\"rpm_val\">#{$orbita_rpm.round(1)}</span> RPM</div>\r\n\r\n          <label for=\"pitch\"><b>#{obter_texto(:label_pitch)}</b></label><br>\r\n          <input type=\"range\" id=\"pitch\" min=\"-60\" max=\"60\" step=\"1\" value=\"#{$orbita_pitch_deg}\" style=\"width:100%;\">\r\n          <div><span id=\"pitch_val\">#{$orbita_pitch_deg.round(1)}</span>¬∞</div>\r\n\r\n          <label for=\"dist\"><b>#{obter_texto(:label_dist)}</b></label><br>\r\n          <input type=\"range\" id=\"dist\" min=\"0.5\" max=\"5\" step=\"0.1\" value=\"#{$orbita_radius_multiplier}\" style=\"width:100%;\">\r\n          <div><span id=\"dist_val\">#{$orbita_radius_multiplier.round(1)}</span>x</div>\r\n\r\n          <hr style=\"margin:16px 0;\">\r\n          <button onclick=\"window.location='skp:stop_orbit@'\" style=\"padding:8px 16px; font-weight:bold; background:#d33; color:#fff; border:none; border-radius:4px; cursor:pointer;\">\r\n            #{obter_texto(:btn_encerrar)}\r\n          </button>\r\n\r\n          <script>\r\n            function bindSlider(id, callback) {\r\n              const slider = document.getElementById(id);\r\n              const valSpan = document.getElementById(id + \"_val\");\r\n              slider.addEventListener(\"input\", () => {\r\n                valSpan.innerText = slider.value;\r\n                window.location = 'skp:' + callback + '@' + slider.value;\r\n              });\r\n            }\r\n\r\n            bindSlider(\"rpm\", \"update_rpm\");\r\n            bindSlider(\"pitch\", \"update_pitch\");\r\n            bindSlider(\"dist\", \"update_distance\");\r\n          </script>\r\n        </body>\r\n      </html>\r\n      HTML\r\n\r\n      dlg = UI::HtmlDialog.new({\r\n        dialog_title: obter_texto(:titulo_janela),\r\n        preferences_key: \"orbita_dinamica_gui\",\r\n        resizable: false,\r\n        width: 360,\r\n        height: 420,\r\n        style: UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n\r\n      dlg.set_html(html)\r\n\r\n      dlg.set_on_closed {\r\n        UI.stop_timer($orbita_timer) if $orbita_timer\r\n        $orbita_timer = nil\r\n        puts obter_texto(:msg_encerrado)\r\n      }\r\n\r\n      dlg.add_action_callback(\"update_rpm\") { |_, val| $orbita_rpm = val.to_f }\r\n      dlg.add_action_callback(\"update_pitch\") { |_, val| $orbita_pitch_deg = val.to_f }\r\n      dlg.add_action_callback(\"update_distance\") { |_, val| $orbita_radius_multiplier = val.to_f }\r\n\r\n      dlg.add_action_callback(\"stop_orbit\") do |_|\r\n        UI.stop_timer($orbita_timer) if $orbita_timer\r\n        $orbita_timer = nil\r\n        dlg.close\r\n      end\r\n\r\n      dlg.show\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::VisualizacaoOrbital.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "gerenciador-de-pavimentos-c4q93",
    "title": {
      "pt": "Gerenciador de Pavimentos",
      "en": "Floor Manager",
      "es": "Gerente de piso"
    },
    "author": "Kalylla | Arquiteta",
    "version": "1.0",
    "description": {
      "pt": "Permite criar se√ß√µes de planta-baixa, forro e cortes automaticamente de acordo com configura√ß√µes de quantidade de pavimentos e alturas personalizadas pelo usu√°rio.",
      "en": "Allows you to automatically create floor plan, ceiling, and section plans according to user-customized settings for the number of floors and heights.",
      "es": "Le permite crear autom√°ticamente planos de planta, techo y secciones seg√∫n la configuraci√≥n personalizada del usuario para la cantidad de pisos y alturas."
    },
    "keywords": {
      "pt": [
        "pavimentos"
      ],
      "en": [
        "floors"
      ],
      "es": [
        "pisos"
      ]
    },
    "code": {
      "pt": "# -------------------------------------------------------------\r\n# # Script: Gerenciador de Pavimentos\r\n# Autor: Kalylla | Arquiteta\r\n# Inspiracao: 5D Auto\r\n# Versao: v1.00\r\n# Idiomas: PT/BR | EN | ES\r\n# Descricao: Permite criar secoes de planta-baixa, forro e cortes\r\n# automaticamente de acordo com configuracoes de quantidade de\r\n# pavimentos e alturas personalizadas pelo usuario.\r\n# -------------------------------------------------------------\r\n\r\nmodule ScriptUpComunidade\r\n  module GerenciadorPavimentos\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :titulo                      => \"Gerenciador de Niveis\",\r\n        :selecionar_pavimento        => \"-- Selecione um pavimento --\",\r\n        :editar_pavimento            => \"Editar Pavimento:\",\r\n        :selecionar_unidade          => \"Unidade de Medida:\",\r\n        :nome_pavimento              => \"Nome do Pavimento:\",\r\n        :placeholder_nome            => \"Digite o nome do pavimento\",\r\n        :nivel_pavimento             => \"Nivel do Pavimento:\",\r\n        :altura_pavimento            => \"Altura do Pavimento:\",\r\n        :planta_baixa_altura         => \"Planta Baixa (altura):\",\r\n        :botao_salvar                => \"Salvar edicoes\",\r\n        :botao_criar                 => \"Criar Pavimento\",\r\n        :titulo_niveis               => \"Niveis no Projeto:\",\r\n        :carregar_dados              => \"Carregar dados\",\r\n        :botao_excluir               => \"Excluir\",\r\n        :botao_salvar_dados          => \"Salvar\",\r\n        :secoes_forro                => \"Secoes Forro\",\r\n        :secoes_planta               => \"Secoes Planta\",\r\n        :secoes_corte                => \"Secoes Corte\",\r\n        :corte_extra_x               => \"Corte Extra X\",\r\n        :corte_extra_y               => \"Corte Extra Y\",\r\n        :idioma                      => \"Idioma\",\r\n        :tema_claro                  => \"Tema Claro\",\r\n        :tema_escuro                 => \"Tema Escuro\",\r\n        :sem_geometria               => \"Nenhuma geometria encontrada para posicionar os cortes!\",\r\n        :confirmar_exclusao_titulo   => \"Deseja excluir os pavimentos selecionados?\",\r\n        :confirmar_exclusao_mensagem => \"Esta acao e irreversivel e ira apagar toda a configuracao dos pavimentos selecionados.\",\r\n        :botao_cancelar              => \"Cancelar\",\r\n        :botao_confirmar             => \"Confirmar\",\r\n        :titulo_alerta               => \"Atencao\",\r\n        :numero_invalido             => \"Por favor, insira valores numericos validos\",\r\n        :nenhum_selecionado          => \"Selecione pelo menos um pavimento\",\r\n        :dados_salvos                => \"Dados salvos com sucesso em:\",\r\n        :erro                        => \"Erro\",\r\n        :secao_frente                => \"Frente\",\r\n        :secao_tras                  => \"Tras\",\r\n        :secao_direita               => \"Direita\",\r\n        :secao_esquerda              => \"Esquerda\",\r\n        :secao                       => \"Secao\",\r\n        :nome_duplicado              => \"Ja existe um pavimento com este nome, escolha um nome exclusivo para o novo pavimento\",\r\n        :nivel_duplicado             => \"A cota do pavimento ja existe, verifique na tabela para nao criar pavimentos duplicados\",\r\n        :criar_secoes_primeiro       => \"Crie as secoes verticais primeiro ou verifique se ha geometria visivel!\",\r\n        :arquivo_invalido            => \"Arquivo invalido\",\r\n        :cabecalho_nome              => \"Pavimento\",\r\n        :cabecalho_nivel             => \"Nivel\",\r\n        :cabecalho_altura            => \"Altura\",\r\n        :cabecalho_planta            => \"Planta Baixa\",\r\n        :cabecalho_planta_z          => \"PB(z)\",\r\n        :unit_metros                 => \"Metros\",\r\n        :unit_centimetros            => \"Centimetros\",\r\n        :unit_milimetros             => \"Milimetros\",\r\n        :unit_polegadas              => \"Polegadas\",\r\n        :unit_jardas                 => \"Jardas\",\r\n        :unit_pes                    => \"Pes\"\r\n      },\r\n      'en-US' => {\r\n        :titulo                      => \"Sections Management\",\r\n        :selecionar_pavimento        => \"-- Select a floor --\",\r\n        :editar_pavimento            => \"Edit Floor:\",\r\n        :selecionar_unidade          => \"Measurement Unit:\",\r\n        :nome_pavimento              => \"Floor Name:\",\r\n        :placeholder_nome            => \"Enter floor name\",\r\n        :nivel_pavimento             => \"Floor Elevation:\",\r\n        :altura_pavimento            => \"Floor Height:\",\r\n        :planta_baixa_altura         => \"Floor Plan (height):\",\r\n        :botao_salvar                => \"Save changes\",\r\n        :botao_criar                 => \"Create Floor\",\r\n        :titulo_niveis               => \"Floors:\",\r\n        :carregar_dados              => \"Load data\",\r\n        :botao_excluir               => \"Delete\",\r\n        :botao_salvar_dados          => \"Save\",\r\n        :secoes_forro                => \"Ceiling Sections\",\r\n        :secoes_planta               => \"Plan Sections\",\r\n        :secoes_corte                => \"Sections\",\r\n        :corte_extra_x               => \"Extra Cut X\",\r\n        :corte_extra_y               => \"Extra Cut Y\",\r\n        :idioma                      => \"Language\",\r\n        :tema_claro                  => \"Light Theme\",\r\n        :tema_escuro                 => \"Dark Theme\",\r\n        :sem_geometria               => \"No geometry found to place cuts!\",\r\n        :confirmar_exclusao_titulo   => \"Do you want to delete selected floors?\",\r\n        :confirmar_exclusao_mensagem => \"This action is irreversible and will delete all configuration for selected floors.\",\r\n        :botao_cancelar              => \"Cancel\",\r\n        :botao_confirmar             => \"Confirm\",\r\n        :titulo_alerta               => \"Warning\",\r\n        :numero_invalido             => \"Please enter valid numeric values\",\r\n        :nenhum_selecionado          => \"Select at least one floor\",\r\n        :dados_salvos                => \"Data successfully saved at:\",\r\n        :erro                        => \"Error\",\r\n        :secao_frente                => \"Front\",\r\n        :secao_tras                  => \"Back\",\r\n        :secao_direita               => \"Right\",\r\n        :secao_esquerda              => \"Left\",\r\n        :secao                       => \"Section\",\r\n        :nome_duplicado              => \"A floor with this name already exists, please choose a unique name\",\r\n        :nivel_duplicado             => \"Floor elevation already exists, check the table to avoid duplicate floors\",\r\n        :criar_secoes_primeiro       => \"Create vertical sections first or check if there is visible geometry!\",\r\n        :arquivo_invalido            => \"Invalid file\",\r\n        :cabecalho_nome              => \"Floor Name\",\r\n        :cabecalho_nivel             => \"Elevation\",\r\n        :cabecalho_altura            => \"Height\",\r\n        :cabecalho_planta            => \"Floor Plan\",\r\n        :cabecalho_planta_z          => \"FP(z)\",\r\n        :unit_metros                 => \"Meters\",\r\n        :unit_centimetros            => \"Centimeters\",\r\n        :unit_milimetros             => \"Millimeters\",\r\n        :unit_polegadas              => \"Inches\",\r\n        :unit_jardas                 => \"Yards\",\r\n        :unit_pes                    => \"Feet\"\r\n      },\r\n      'es' => {\r\n        :titulo                      => \"Gestor de Pisos\",\r\n        :selecionar_pavimento        => \"-- Seleccione un piso --\",\r\n        :editar_pavimento            => \"Editar Piso:\",\r\n        :selecionar_unidade          => \"Unidad de Medida:\",\r\n        :nome_pavimento              => \"Nombre del Piso:\",\r\n        :placeholder_nome            => \"Ingrese nombre del piso\",\r\n        :nivel_pavimento             => \"Elevacion del Piso:\",\r\n        :altura_pavimento            => \"Altura del Piso:\",\r\n        :planta_baixa_altura         => \"Plano de Planta (altura):\",\r\n        :botao_salvar                => \"Guardar cambios\",\r\n        :botao_criar                 => \"Crear Piso\",\r\n        :titulo_niveis               => \"Pisos en el Proyecto:\",\r\n        :carregar_dados              => \"Cargar datos\",\r\n        :botao_excluir               => \"Eliminar\",\r\n        :botao_salvar_dados          => \"Guardar\",\r\n        :secoes_forro                => \"Secciones de Techo\",\r\n        :secoes_planta               => \"Secciones de Planta\",\r\n        :secoes_corte                => \"Secciones\",\r\n        :corte_extra_x               => \"Corte Extra X\",\r\n        :corte_extra_y               => \"Corte Extra Y\",\r\n        :idioma                      => \"Idioma\",\r\n        :tema_claro                  => \"Tema Claro\",\r\n        :tema_escuro                 => \"Tema Oscuro\",\r\n        :sem_geometria               => \"No se encontro geometria para colocar cortes!\",\r\n        :confirmar_exclusao_titulo   => \"Desea eliminar los pisos seleccionados?\",\r\n        :confirmar_exclusao_mensagem => \"Esta accion es irreversible y eliminara toda la configuracion de los pisos seleccionados.\",\r\n        :botao_cancelar              => \"Cancelar\",\r\n        :botao_confirmar             => \"Confirmar\",\r\n        :titulo_alerta               => \"Atencion\",\r\n        :numero_invalido             => \"Por favor ingrese valores numericos validos\",\r\n        :nenhum_selecionado          => \"Seleccione al menos un piso\",\r\n        :dados_salvos                => \"Datos guardados exitosamente en:\",\r\n        :erro                        => \"Error\",\r\n        :secao_frente                => \"Frente\",\r\n        :secao_tras                  => \"Atras\",\r\n        :secao_direita               => \"Derecha\",\r\n        :secao_esquerda              => \"Izquierda\",\r\n        :secao                       => \"Seccion\",\r\n        :nome_duplicado              => \"Ya existe un piso con este nombre, elija un nombre unico para el nuevo piso\",\r\n        :nivel_duplicado             => \"La elevacion del piso ya existe, verifique en la tabla para no crear pisos duplicados\",\r\n        :criar_secoes_primeiro       => \"Cree las secciones verticales primero o verifique si hay geometria visible!\",\r\n        :arquivo_invalido            => \"Archivo invalido\",\r\n        :cabecalho_nome              => \"Piso\",\r\n        :cabecalho_nivel             => \"Elevacion\",\r\n        :cabecalho_altura            => \"Altura\",\r\n        :cabecalho_planta            => \"Plano de Planta\",\r\n        :cabecalho_planta_z          => \"PL(z)\",\r\n        :unit_metros                 => \"Metros\",\r\n        :unit_centimetros            => \"Centimetros\",\r\n        :unit_milimetros             => \"Milimetros\",\r\n        :unit_polegadas              => \"Pulgadas\",\r\n        :unit_jardas                 => \"Yardas\",\r\n        :unit_pes                    => \"Pies\"\r\n      }\r\n    }\r\n\r\n    LANG_MAP = { 'pt' => 'pt-BR', 'en' => 'en-US', 'es' => 'es' }\r\n    LANG_SHORT = { 'pt-BR' => 'pt', 'en-US' => 'en', 'es' => 'es' }\r\n\r\n    UNIT_KEYS = [\r\n      ['metros',      :unit_metros],\r\n      ['centimetros', :unit_centimetros],\r\n      ['milimetros',  :unit_milimetros],\r\n      ['polegadas',   :unit_polegadas],\r\n      ['jardas',      :unit_jardas],\r\n      ['pes',         :unit_pes]\r\n    ]\r\n\r\n    # Inicializa variaveis de classe\r\n    @levels = []\r\n    @dialog = nil\r\n    @current_unit = 'metros'\r\n    @current_theme = Sketchup.read_default(\"level_manager\", \"theme\", \"day\")\r\n    @levels_mutex = Mutex.new\r\n\r\n    # Detecta idioma inicial via Sketchup.get_locale ou preferencia salva\r\n    saved_lang = Sketchup.read_default(\"level_manager\", \"language\", nil)\r\n    if saved_lang && IDIOMAS.key?(saved_lang)\r\n      @current_language = saved_lang\r\n    elsif saved_lang && LANG_MAP.key?(saved_lang)\r\n      @current_language = LANG_MAP[saved_lang]\r\n    else\r\n      locale = Sketchup.get_locale\r\n      @current_language = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n    end\r\n\r\n    def self.obter_texto(chave)\r\n      lang = @current_language || begin\r\n        locale = Sketchup.get_locale\r\n        IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      end\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    # Metodo principal para criar a interface\r\n    def self.criar_interface_niveis\r\n      begin\r\n        # Fecha o dialogo existente se estiver aberto\r\n        @dialog.close if @dialog && @dialog.visible?\r\n\r\n        options = {\r\n          :dialog_title => obter_texto(:titulo),\r\n          :preferences_key => 'com.example.levelmanager',\r\n          :width => 650,\r\n          :height => 580,\r\n          :resizable => true,\r\n          :style => UI::HtmlDialog::STYLE_DIALOG,\r\n          :min_width => 650,\r\n          :min_height => 580\r\n        }\r\n\r\n        @dialog = UI::HtmlDialog.new(options)\r\n\r\n        unit_options = UNIT_KEYS.map { |val, key| \"<option value='#{val}'>#{obter_texto(key)}</option>\" }.join\r\n        short_lang = LANG_SHORT[@current_language] || 'en'\r\n\r\n        html = <<-HTML\r\n          <!DOCTYPE html>\r\n          <html>\r\n          <head>\r\n            <meta charset=\"UTF-8\">\r\n            <style>\r\n              /* ====== ESTILOS GERAIS ====== */\r\n              body {\r\n                font-family: Arial, sans-serif;\r\n                padding: 10px;\r\n                margin: 0;\r\n                height: 100%;\r\n                box-sizing: border-box;\r\n                background-color: #ffffff;\r\n                color: #000000;\r\n              }\r\n\r\n              /* Tema noturno */\r\n              body.night {\r\n                background-color: #000000;\r\n                color: #ffffff;\r\n              }\r\n\r\n              /* ====== LAYOUT PRINCIPAL ====== */\r\n              #main-container {\r\n                display: flex;\r\n                flex-direction: column;\r\n                height: 100%;\r\n              }\r\n\r\n              /* Container da tabela */\r\n              #table-container {\r\n                flex-grow: 1;\r\n                overflow-y: auto;\r\n                margin-bottom: 10px;\r\n              }\r\n\r\n              /* ====== CABECALHOS E TITULOS ====== */\r\n              h3 {\r\n                margin-top: 0;\r\n              }\r\n\r\n              h4 {\r\n                margin-bottom: 5px;\r\n                display: flex;\r\n                align-items: center;\r\n              }\r\n\r\n              /* ====== FORMULARIOS E INPUTS ====== */\r\n              /* Grupos de inputs */\r\n              .input-group {\r\n                margin-bottom: 12px;\r\n              }\r\n\r\n              .name-input-group {\r\n                margin-top: 8px;\r\n                margin-bottom: 15px;\r\n              }\r\n\r\n              /* Linhas de inputs */\r\n              .input-row {\r\n                display: flex;\r\n                justify-content: space-between;\r\n                margin-bottom: 12px;\r\n              }\r\n\r\n              .selector-row {\r\n                display: flex;\r\n                justify-content: space-between;\r\n                margin-bottom: 15px;\r\n              }\r\n\r\n              /* Seletor de idioma */\r\n              .language-selector {\r\n                position: absolute;\r\n                top: 10px;\r\n                right: 60px;\r\n                display: flex;\r\n                align-items: center;\r\n                gap: 5px;\r\n                font-size: 9pt;\r\n              }\r\n\r\n              .language-selector select {\r\n                padding: 2px;\r\n                font-size: 9pt;\r\n              }\r\n\r\n              /* Campos individuais */\r\n              .input-field {\r\n                width: 30%;\r\n              }\r\n\r\n              .unit-selector,\r\n              .level-selector {\r\n                width: 48%;\r\n              }\r\n\r\n              /* Labels */\r\n              .input-label {\r\n                font-size: 10pt;\r\n                margin-bottom: 2px;\r\n              }\r\n\r\n              .input-field label {\r\n                font-size: 10pt;\r\n                display: block;\r\n                margin-bottom: 2px;\r\n              }\r\n\r\n              /* Inputs e selects */\r\n              .input-field input,\r\n              select,\r\n              #level_name {\r\n                width: 100%;\r\n                padding: 4px;\r\n                font-size: 11pt;\r\n                box-sizing: border-box;\r\n                background-color: #ffffff;\r\n                color: #000000;\r\n                border: 1px solid #ddd;\r\n              }\r\n\r\n              /* Input de nome do nivel */\r\n              #level_name {\r\n                width: 100%;\r\n              }\r\n\r\n              /* ====== TABELA DE NIVEIS ====== */\r\n              table {\r\n                width: 100%;\r\n                border-collapse: collapse;\r\n                margin-top: 8px;\r\n                font-size: 11pt;\r\n                table-layout: fixed;\r\n              }\r\n\r\n              th, td {\r\n                border: 1px solid #ddd;\r\n                padding: 6px;\r\n                text-align: left;\r\n                overflow: hidden;\r\n              }\r\n\r\n              th {\r\n                background-color: #f2f2f2;\r\n                font-size: 10pt;\r\n                white-space: nowrap;\r\n              }\r\n\r\n              /* Celulas editaveis */\r\n              .editable-cell {\r\n                cursor: pointer;\r\n                white-space: nowrap;\r\n                overflow: hidden;\r\n                text-overflow: ellipsis;\r\n              }\r\n\r\n              .editable-cell:hover {\r\n                background-color: #f5f5f5;\r\n              }\r\n\r\n              /* Checkbox na tabela */\r\n              .checkbox-column {\r\n                width: 30px;\r\n                text-align: center;\r\n              }\r\n\r\n              /* Input dentro da tabela */\r\n              .table-input {\r\n                width: 100%;\r\n                border: none;\r\n                padding: 0;\r\n                margin: 0;\r\n                font-size: 11pt;\r\n                background: transparent;\r\n                color: inherit;\r\n              }\r\n\r\n              /* ====== BOTOES ====== */\r\n              /* Containers de botoes */\r\n              .button-container {\r\n                display: flex;\r\n                justify-content: space-between;\r\n                margin-top: 15px;\r\n                margin-bottom: 10px;\r\n              }\r\n\r\n              .button-row {\r\n                display: flex;\r\n                justify-content: space-between;\r\n                margin-top: 10px;\r\n              }\r\n\r\n              .delete-save-container {\r\n                display: flex;\r\n                gap: 5px;\r\n              }\r\n\r\n              /* Estilo base para todos os botoes */\r\n              button {\r\n                padding: 5px 12px;\r\n                margin: 3px;\r\n                font-size: 11pt;\r\n                cursor: pointer;\r\n                border: none;\r\n                border-radius: 8px;\r\n              }\r\n\r\n              /* Cores especificas para botoes */\r\n              .delete-btn {\r\n                background-color: #f44336;\r\n                color: white;\r\n              }\r\n\r\n              .create-btn {\r\n                background-color: #2196F3;\r\n                color: white;\r\n              }\r\n\r\n              .save-btn {\r\n                background-color: #4CAF50;\r\n                color: white;\r\n              }\r\n\r\n              .section-btn {\r\n                background-color: #2196F3;\r\n                color: white;\r\n              }\r\n\r\n              .cut-btn {\r\n                background-color: #42A5F5;\r\n                color: white;\r\n              }\r\n\r\n              .load-btn {\r\n                background-color: #9E9E9E;\r\n                color: white;\r\n                padding: 3px 8px;\r\n                font-size: 10pt;\r\n                height: 24px;\r\n                margin-left: 5px;\r\n              }\r\n\r\n              /* ====== SECOES ESPECIFICAS ====== */\r\n              /* Seletor de tema */\r\n              .theme-switcher {\r\n                position: absolute;\r\n                top: 10px;\r\n                right: 10px;\r\n                display: flex;\r\n                gap: 0;\r\n              }\r\n\r\n              .theme-btn {\r\n                width: 24px;\r\n                height: 24px;\r\n                padding: 0;\r\n                margin: 0;\r\n                display: flex;\r\n                align-items: center;\r\n                justify-content: center;\r\n                border: 1px solid #ccc;\r\n                background-color: #f0f0f0;\r\n                border-radius: 0;\r\n                color: #000;\r\n              }\r\n\r\n              .theme-btn:first-child {\r\n                border-top-left-radius: 3px;\r\n                border-bottom-left-radius: 3px;\r\n              }\r\n\r\n              .theme-btn:last-child {\r\n                border-top-right-radius: 3px;\r\n                border-bottom-right-radius: 3px;\r\n              }\r\n\r\n              .theme-btn.active {\r\n                background-color: #ddd;\r\n                border: 1px solid #999;\r\n                box-shadow: inset 0 2px 3px rgba(0,0,0,0.2);\r\n              }\r\n\r\n              /* ====== DIALOGOS PERSONALIZADOS ====== */\r\n              .custom-dialog {\r\n                position: fixed;\r\n                top: 50%;\r\n                left: 50%;\r\n                transform: translate(-50%, -50%);\r\n                background-color: white;\r\n                padding: 20px;\r\n                border-radius: 5px;\r\n                box-shadow: 0 4px 8px rgba(0,0,0,0.2);\r\n                z-index: 1000;\r\n                width: 400px;\r\n                max-width: 90%;\r\n              }\r\n\r\n              .custom-dialog-title {\r\n                font-weight: bold;\r\n                margin-bottom: 15px;\r\n                font-size: 14pt;\r\n              }\r\n\r\n              .custom-dialog-message {\r\n                margin-bottom: 20px;\r\n              }\r\n\r\n              .custom-dialog-buttons {\r\n                display: flex;\r\n                justify-content: flex-end;\r\n                gap: 10px;\r\n              }\r\n\r\n              .custom-dialog-button {\r\n                padding: 8px 16px;\r\n                border: none;\r\n                border-radius: 4px;\r\n                cursor: pointer;\r\n                font-size: 11pt;\r\n              }\r\n\r\n              .custom-dialog-confirm {\r\n                background-color: #f44336;\r\n                color: white;\r\n              }\r\n\r\n              .custom-dialog-cancel {\r\n                background-color: #e0e0e0;\r\n              }\r\n\r\n              /* ====== TEMA NOTURNO ====== */\r\n              body.night .input-field input,\r\n              body.night select,\r\n              body.night #level_name,\r\n              body.night .table-input {\r\n                background-color: #333333;\r\n                color: #ffffff;\r\n                border-color: #555;\r\n              }\r\n\r\n              body.night th,\r\n              body.night td {\r\n                border-color: #555;\r\n              }\r\n\r\n              body.night th {\r\n                background-color: #333;\r\n              }\r\n\r\n              body.night .editable-cell:hover {\r\n                background-color: #333;\r\n              }\r\n\r\n              body.night .theme-btn {\r\n                background-color: #333;\r\n                border-color: #555;\r\n                color: #fff;\r\n              }\r\n\r\n              body.night .theme-btn.active {\r\n                background-color: #555;\r\n                border-color: #777;\r\n              }\r\n\r\n              body.night .custom-dialog {\r\n                background-color: #222;\r\n                color: white;\r\n              }\r\n\r\n              body.night .custom-dialog-cancel {\r\n                background-color: #444;\r\n                color: white;\r\n              }\r\n            </style>\r\n          </head>\r\n          <body class=\"#{@current_theme}\">\r\n            <div class=\"language-selector\">\r\n              <label>#{obter_texto(:idioma)}:</label>\r\n              <select id=\"language_selector\" onchange=\"changeLanguage()\">\r\n                <option value=\"pt\" #{@current_language == 'pt-BR' ? 'selected' : ''}>Portugu&#234;s</option>\r\n                <option value=\"en\" #{@current_language == 'en-US' ? 'selected' : ''}>English</option>\r\n                <option value=\"es\" #{@current_language == 'es' ? 'selected' : ''}>Espa&#241;ol</option>\r\n              </select>\r\n            </div>\r\n\r\n            <div class=\"theme-switcher\">\r\n              <button id=\"day-theme\" class=\"theme-btn #{@current_theme == 'day' ? 'active' : ''}\" onclick=\"setTheme('day')\" title=\"#{obter_texto(:tema_claro)}\">&#128262;</button>\r\n              <button id=\"night-theme\" class=\"theme-btn #{@current_theme == 'night' ? 'active' : ''}\" onclick=\"setTheme('night')\" title=\"#{obter_texto(:tema_escuro)}\">&#127769;</button>\r\n            </div>\r\n\r\n            <div id='main-container'>\r\n              <h3>#{obter_texto(:titulo)}</h3>\r\n\r\n              <div class='selector-row'>\r\n                <div class='level-selector'>\r\n                  <label class='input-label'>#{obter_texto(:editar_pavimento)}</label>\r\n                  <select id='level_selector' onchange='levelSelected()'>\r\n                    <option value=''>#{obter_texto(:selecionar_pavimento)}</option>\r\n                  </select>\r\n                </div>\r\n                <div class='unit-selector'>\r\n                  <label class='input-label'>#{obter_texto(:selecionar_unidade)}</label>\r\n                  <select id='unit_selector' onchange='unitChanged()'>\r\n                    #{unit_options}\r\n                  </select>\r\n                </div>\r\n              </div>\r\n\r\n              <div class='name-input-group'>\r\n                <label class='input-label'>#{obter_texto(:nome_pavimento)}</label>\r\n                <input type='text' id='level_name' placeholder=\"#{obter_texto(:placeholder_nome)}\" onkeypress=\"handleKeyPress(event)\">\r\n              </div>\r\n\r\n              <div class='input-row'>\r\n                <div class='input-field'>\r\n                  <label class='input-label'>#{obter_texto(:nivel_pavimento)}</label>\r\n                  <input type='text' id='base_level' value='0,00' onfocus=\"this.select();\" onkeypress=\"handleKeyPress(event)\">\r\n                </div>\r\n                <div class='input-field'>\r\n                  <label class='input-label'>#{obter_texto(:altura_pavimento)}</label>\r\n                  <input type='text' id='level_height' value='3,00' onfocus=\"this.select();\" onkeypress=\"handleKeyPress(event)\">\r\n                </div>\r\n                <div class='input-field'>\r\n                  <label class='input-label'>#{obter_texto(:planta_baixa_altura)}</label>\r\n                  <input type='text' id='plan_height' value='1,50' onfocus=\"this.select();\" onkeypress=\"handleKeyPress(event)\">\r\n                </div>\r\n              </div>\r\n\r\n              <div class='button-row'>\r\n                <button onclick='saveLevel()' class='save-btn'>#{obter_texto(:botao_salvar)}</button>\r\n                <button onclick='addLevel()' class='create-btn'>#{obter_texto(:botao_criar)}</button>\r\n              </div>\r\n\r\n              <div id='table-container'>\r\n                <h4>#{obter_texto(:titulo_niveis)}<button class='load-btn' onclick='loadData()'>#{obter_texto(:carregar_dados)}</button></h4>\r\n                <table id='levels_table'>\r\n                  <thead>\r\n                    <tr>\r\n                      <th class='checkbox-column'><input type='checkbox' id='select_all' onclick='toggleSelectAll()'></th>\r\n                      <th width='25%'>#{obter_texto(:cabecalho_nome)}</th>\r\n                      <th width='15%'>#{obter_texto(:cabecalho_nivel)}</th>\r\n                      <th width='15%'>#{obter_texto(:cabecalho_altura)}</th>\r\n                      <th width='15%'>#{obter_texto(:cabecalho_planta)}</th>\r\n                      <th width='15%'>#{obter_texto(:cabecalho_planta_z)}</th>\r\n                    </tr>\r\n                  </thead>\r\n                  <tbody id='levels_list'>\r\n                  </tbody>\r\n                </table>\r\n              </div>\r\n\r\n              <div class='button-container'>\r\n                  <div class='delete-save-container'>\r\n                      <button onclick='showDeleteConfirmation()' class='delete-btn'>#{obter_texto(:botao_excluir)}</button>\r\n                      <button onclick='saveData()' class='save-btn'>#{obter_texto(:botao_salvar_dados)}</button>\r\n                  </div>\r\n\r\n                  <div class='horizontal-sections'>\r\n                      <button onclick='createCeilingSections()' class='section-btn'>#{obter_texto(:secoes_forro)}</button>\r\n                      <button onclick='createSections()' class='section-btn'>#{obter_texto(:secoes_planta)}</button>\r\n                  </div>\r\n              </div>\r\n\r\n              <div class='button-container'>\r\n                  <div style='width: 100%; display: flex; justify-content: flex-end; gap: 5px;'>\r\n                      <button onclick='createExtraCutX()' class='section-btn'>#{obter_texto(:corte_extra_x)}</button>\r\n                      <button onclick='createExtraCutY()' class='section-btn'>#{obter_texto(:corte_extra_y)}</button>\r\n                      <button onclick='createVerticalSections()' class='section-btn cut-main-btn'>#{obter_texto(:secoes_corte)}</button>\r\n                  </div>\r\n              </div>\r\n\r\n            <script>\r\n              function validateNumber(input) {\r\n                const num = parseFloat(input.replace(',', '.'));\r\n                return !isNaN(num) && isFinite(num);\r\n              }\r\n\r\n              function formatNumber(value) {\r\n                return parseFloat(value).toFixed(2).replace('.', ',');\r\n              }\r\n\r\n              function handleKeyPress(e) {\r\n                if (e.key === 'Enter') {\r\n                  e.preventDefault();\r\n                  const levelSelector = document.getElementById('level_selector');\r\n                  if (levelSelector.value) {\r\n                    saveLevel();\r\n                  } else {\r\n                    addLevel();\r\n                  }\r\n                }\r\n              }\r\n\r\n              function toggleSelectAll() {\r\n                const selectAll = document.getElementById('select_all');\r\n                const checkboxes = document.querySelectorAll('#levels_list input[type=\"checkbox\"]');\r\n                checkboxes.forEach(checkbox => {\r\n                  checkbox.checked = selectAll.checked;\r\n                });\r\n              }\r\n\r\n              function editLevelField(levelId, field, value) {\r\n                sketchup.editLevelField(levelId, field, value);\r\n              }\r\n\r\n              function setTheme(theme) {\r\n                document.body.className = theme;\r\n                document.getElementById('day-theme').className = theme === 'day' ? 'theme-btn active' : 'theme-btn';\r\n                document.getElementById('night-theme').className = theme === 'night' ? 'theme-btn active' : 'theme-btn';\r\n                sketchup.setCurrentTheme(theme);\r\n              }\r\n\r\n              function changeLanguage() {\r\n                const langSelector = document.getElementById('language_selector');\r\n                sketchup.changeLanguage(langSelector.value);\r\n              }\r\n\r\n              function addLevel() {\r\n                const name = document.getElementById('level_name').value.trim();\r\n                if (!name) {\r\n                  showAlert('#{obter_texto(:titulo_alerta)}', '#{obter_texto(:placeholder_nome)}');\r\n                  return;\r\n                }\r\n\r\n                const baseZ = document.getElementById('base_level').value;\r\n                const height = document.getElementById('level_height').value;\r\n                const planHeight = document.getElementById('plan_height').value;\r\n\r\n                if (!validateNumber(baseZ) || !validateNumber(height) || !validateNumber(planHeight)) {\r\n                  showAlert('#{obter_texto(:titulo_alerta)}', '#{obter_texto(:numero_invalido)}');\r\n                  return;\r\n                }\r\n\r\n                sketchup.addLevel(name, baseZ.replace(',', '.'), height.replace(',', '.'), planHeight.replace(',', '.'));\r\n              }\r\n\r\n              function saveLevel() {\r\n                const levelId = document.getElementById('level_selector').value;\r\n                if (!levelId) {\r\n                  showAlert('#{obter_texto(:titulo_alerta)}', '#{obter_texto(:selecionar_pavimento)}');\r\n                  return;\r\n                }\r\n\r\n                const name = document.getElementById('level_name').value.trim();\r\n                const baseZ = document.getElementById('base_level').value;\r\n                const height = document.getElementById('level_height').value;\r\n                const planHeight = document.getElementById('plan_height').value;\r\n\r\n                if (!validateNumber(baseZ) || !validateNumber(height) || !validateNumber(planHeight)) {\r\n                  showAlert('#{obter_texto(:titulo_alerta)}', '#{obter_texto(:numero_invalido)}');\r\n                  return;\r\n                }\r\n\r\n                sketchup.saveLevel(levelId, name, baseZ.replace(',', '.'), height.replace(',', '.'), planHeight.replace(',', '.'));\r\n              }\r\n\r\n              function createSections() {\r\n                const checkboxes = document.querySelectorAll('#levels_list input[type=\"checkbox\"]:checked');\r\n                if (checkboxes.length === 0) {\r\n                  showAlert('#{obter_texto(:titulo_alerta)}', '#{obter_texto(:nenhum_selecionado)}');\r\n                  return;\r\n                }\r\n                const levelsToCreate = Array.from(checkboxes).map(cb => {\r\n                  return {\r\n                    id: cb.getAttribute('data-id'),\r\n                    height: parseFloat(cb.closest('tr').querySelector('td:nth-child(6)').textContent.replace('m', '').replace(',', '.'))\r\n                  };\r\n                });\r\n                sketchup.createSections(levelsToCreate);\r\n              }\r\n\r\n              function showAlert(title, message) {\r\n                const dialog = document.createElement('div');\r\n                dialog.className = 'custom-dialog';\r\n                dialog.innerHTML = `\r\n                  <div class=\"custom-dialog-title\">${title}</div>\r\n                  <div class=\"custom-dialog-message\">${message}</div>\r\n                  <div class=\"custom-dialog-buttons\">\r\n                    <button class=\"custom-dialog-button custom-dialog-cancel\" onclick=\"this.parentNode.parentNode.remove()\">#{obter_texto(:botao_cancelar)}</button>\r\n                  </div>\r\n                `;\r\n                document.body.appendChild(dialog);\r\n              }\r\n\r\n              function showDeleteConfirmation() {\r\n                const checkboxes = document.querySelectorAll('#levels_list input[type=\"checkbox\"]:checked');\r\n                if (checkboxes.length === 0) {\r\n                  showAlert('#{obter_texto(:titulo_alerta)}', '#{obter_texto(:nenhum_selecionado)}');\r\n                  return;\r\n                }\r\n\r\n                const dialog = document.createElement('div');\r\n                dialog.className = 'custom-dialog';\r\n                dialog.innerHTML = `\r\n                  <div class=\"custom-dialog-title\">#{obter_texto(:confirmar_exclusao_titulo)}</div>\r\n                  <div class=\"custom-dialog-message\">#{obter_texto(:confirmar_exclusao_mensagem)}</div>\r\n                  <div class=\"custom-dialog-buttons\">\r\n                    <button class=\"custom-dialog-button custom-dialog-cancel\" onclick=\"this.parentNode.parentNode.remove()\">#{obter_texto(:botao_cancelar)}</button>\r\n                    <button class=\"custom-dialog-button custom-dialog-confirm\" onclick=\"confirmDelete()\">#{obter_texto(:botao_confirmar)}</button>\r\n                  </div>\r\n                `;\r\n\r\n                document.body.appendChild(dialog);\r\n\r\n                window.confirmDelete = function() {\r\n                  const levelsToDelete = Array.from(checkboxes).map(cb => cb.getAttribute('data-id'));\r\n                  sketchup.deleteLevels(levelsToDelete);\r\n                  dialog.remove();\r\n                };\r\n              }\r\n\r\n              function levelSelected() {\r\n                const selector = document.getElementById('level_selector');\r\n                if (selector.value) {\r\n                  sketchup.loadLevel(selector.value);\r\n                }\r\n              }\r\n\r\n              function unitChanged() {\r\n                const unitSelector = document.getElementById('unit_selector');\r\n                sketchup.setCurrentUnit(unitSelector.value);\r\n              }\r\n\r\n              function updateUI() {\r\n                sketchup.updateUI();\r\n              }\r\n\r\n              function editCell(cell, levelId, field, isText = false) {\r\n                const currentValue = cell.textContent.replace('m', '').trim();\r\n                const input = document.createElement('input');\r\n                input.type = 'text';\r\n                input.className = 'table-input';\r\n                input.value = currentValue;\r\n\r\n                input.onblur = function() {\r\n                  if (input.value !== currentValue) {\r\n                    if (!isText && !validateNumber(input.value)) {\r\n                      showAlert('#{obter_texto(:titulo_alerta)}', '#{obter_texto(:numero_invalido)}');\r\n                      return;\r\n                    }\r\n                    sketchup.editLevelField(levelId, field, isText ? input.value : input.value.replace(',', '.'));\r\n                  }\r\n                  cell.textContent = isText ? input.value : formatNumber(parseFloat(input.value.replace(',', '.'))) + 'm';\r\n                };\r\n\r\n                input.onkeypress = function(e) {\r\n                  if (e.key === 'Enter') {\r\n                    input.blur();\r\n                  }\r\n                };\r\n\r\n                cell.innerHTML = '';\r\n                cell.appendChild(input);\r\n                input.focus();\r\n\r\n                setTimeout(() => {\r\n                  input.selectionStart = input.selectionEnd = input.value.length;\r\n                }, 0);\r\n              }\r\n\r\n              function loadData() {\r\n                sketchup.loadData();\r\n              }\r\n\r\n              function saveData() {\r\n                sketchup.saveData();\r\n              }\r\n\r\n              function createCeilingSections() {\r\n                const checkboxes = document.querySelectorAll('#levels_list input[type=\"checkbox\"]:checked');\r\n                if (checkboxes.length === 0) {\r\n                  showAlert('#{obter_texto(:titulo_alerta)}', '#{obter_texto(:nenhum_selecionado)}');\r\n                  return;\r\n                }\r\n                const levelsToCreate = Array.from(checkboxes).map(cb => {\r\n                  return {\r\n                    id: cb.getAttribute('data-id'),\r\n                    height: parseFloat(cb.closest('tr').querySelector('td:nth-child(6)').textContent.replace('m', '').replace(',', '.'))\r\n                  };\r\n                });\r\n                sketchup.createCeilingSections(levelsToCreate);\r\n              }\r\n\r\n              function createVerticalSections() {\r\n                sketchup.createVerticalSections();\r\n              }\r\n\r\n              function createExtraCutX() {\r\n                sketchup.createExtraCutX();\r\n              }\r\n\r\n              function createExtraCutY() {\r\n                sketchup.createExtraCutY();\r\n              }\r\n            </script>\r\n          </body>\r\n          </html>\r\n        HTML\r\n\r\n        @dialog.set_html(html)\r\n\r\n        # Callbacks\r\n        @dialog.add_action_callback('addLevel') do |action_context, name, base_z, height, plan_height|\r\n          begin\r\n            @levels_mutex.synchronize do\r\n              if @levels.any? { |l| l[:name].casecmp(name.downcase) == 0 }\r\n                show_alert(obter_texto(:titulo_alerta), obter_texto(:nome_duplicado))\r\n                next\r\n              end\r\n\r\n              if @levels.any? { |l| (l[:base_z] - base_z.to_f).abs < 0.001 }\r\n                show_alert(obter_texto(:titulo_alerta), obter_texto(:nivel_duplicado))\r\n                next\r\n              end\r\n\r\n              add_level(name, base_z.to_f, height.to_f, plan_height.to_f)\r\n            end\r\n          rescue => e\r\n            puts \"Error adding level: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('saveLevel') do |action_context, level_id, name, base_z, height, plan_height|\r\n          begin\r\n            @levels_mutex.synchronize do\r\n              save_level(level_id, name, base_z.to_f, height.to_f, plan_height.to_f)\r\n            end\r\n          rescue => e\r\n            puts \"Error saving level: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('createSections') do |action_context, levels_data|\r\n          begin\r\n            create_sections(levels_data)\r\n          rescue => e\r\n            puts \"Error creating sections: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('createVerticalSections') do |action_context|\r\n          begin\r\n            create_vertical_sections\r\n          rescue => e\r\n            puts \"Error creating vertical sections: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('createExtraCutX') do |action_context|\r\n          begin\r\n            create_extra_cut_x\r\n          rescue => e\r\n            puts \"Error creating extra cut X: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('createExtraCutY') do |action_context|\r\n          begin\r\n            create_extra_cut_y\r\n          rescue => e\r\n            puts \"Error creating extra cut Y: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('deleteLevels') do |action_context, level_ids|\r\n          begin\r\n            @levels_mutex.synchronize do\r\n              delete_levels(level_ids)\r\n            end\r\n          rescue => e\r\n            puts \"Error deleting levels: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('loadLevel') do |action_context, level_id|\r\n          begin\r\n            load_level(level_id.to_i)\r\n          rescue => e\r\n            puts \"Error loading level: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('setCurrentUnit') do |action_context, unit|\r\n          @current_unit = unit\r\n        end\r\n\r\n        @dialog.add_action_callback('updateUI') do\r\n          begin\r\n            update_ui\r\n          rescue => e\r\n            puts \"Error updating UI: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('editLevelField') do |action_context, level_id, field, value|\r\n          begin\r\n            @levels_mutex.synchronize do\r\n              edit_level_field(level_id, field, value)\r\n            end\r\n          rescue => e\r\n            puts \"Error editing field: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('setCurrentTheme') do |action_context, theme|\r\n          @current_theme = theme\r\n          Sketchup.write_default(\"level_manager\", \"theme\", theme)\r\n        end\r\n\r\n        @dialog.add_action_callback('loadData') do |action_context|\r\n          begin\r\n            load_data_from_file\r\n          rescue => e\r\n            puts \"Error loading data: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('saveData') do |action_context|\r\n          begin\r\n            save_data_to_file\r\n          rescue => e\r\n            puts \"Error saving data: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('createCeilingSections') do |action_context, levels_data|\r\n          begin\r\n            create_ceiling_sections(levels_data)\r\n          rescue => e\r\n            puts \"Error creating ceiling sections: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n            show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n          end\r\n        end\r\n\r\n        @dialog.add_action_callback('changeLanguage') do |action_context, lang|\r\n          @current_language = LANG_MAP[lang] || 'en-US'\r\n          Sketchup.write_default(\"level_manager\", \"language\", @current_language)\r\n          criar_interface_niveis\r\n        end\r\n\r\n        # Configuracao inicial\r\n        @dialog.execute_script(\"document.getElementById('language_selector').value = '#{short_lang}';\")\r\n        @dialog.execute_script(\"document.getElementById('unit_selector').value = '#{@current_unit}';\")\r\n        @dialog.execute_script(\"document.body.className = '#{@current_theme}';\")\r\n\r\n        @dialog.show\r\n      rescue => e\r\n        puts \"Error creating interface: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n        UI.messagebox(\"#{obter_texto(:erro)}: #{e.message}\")\r\n      end\r\n    end\r\n\r\n    # Metodos auxiliares\r\n    def self.show_alert(title, message)\r\n      js = <<-JS\r\n        showAlert(#{title.to_json}, #{message.to_json});\r\n      JS\r\n      @dialog.execute_script(js)\r\n    rescue\r\n      UI.messagebox(\"#{title}: #{message}\")\r\n    end\r\n\r\n    def self.add_level(name, base_z, height, plan_height)\r\n      model = Sketchup.active_model\r\n      return unless model.valid?\r\n\r\n      model.start_operation(\"#{obter_texto(:botao_criar)} #{name}\", true)\r\n\r\n      level = {\r\n        id: Time.now.to_i,\r\n        name: name,\r\n        base_z: base_z,\r\n        height: height,\r\n        plan_height: plan_height,\r\n        created_at: Time.now\r\n      }\r\n\r\n      @levels << level\r\n      @levels.sort_by! { |l| l[:base_z] }\r\n\r\n      model.commit_operation\r\n\r\n      update_ui\r\n    end\r\n\r\n    def self.save_level(level_id, name, base_z, height, plan_height)\r\n      model = Sketchup.active_model\r\n      return unless model.valid?\r\n\r\n      model.start_operation(\"#{obter_texto(:botao_salvar)} #{name}\", true)\r\n\r\n      level = @levels.find { |l| l[:id].to_s == level_id }\r\n      return unless level\r\n\r\n      if name != level[:name] && @levels.any? { |l| l[:name].casecmp(name.downcase) == 0 }\r\n        show_alert(obter_texto(:titulo_alerta), obter_texto(:nome_duplicado))\r\n        return\r\n      end\r\n\r\n      level[:name] = name unless name.empty?\r\n      level[:base_z] = base_z\r\n      level[:height] = height\r\n      level[:plan_height] = plan_height\r\n\r\n      @levels.sort_by! { |l| l[:base_z] }\r\n\r\n      model.commit_operation\r\n\r\n      update_ui\r\n    end\r\n\r\n    def self.edit_level_field(level_id, field, value)\r\n      model = Sketchup.active_model\r\n      return unless model.valid?\r\n\r\n      model.start_operation(\"#{obter_texto(:editar_pavimento)}\", true)\r\n\r\n      level = @levels.find { |l| l[:id].to_s == level_id }\r\n      return unless level\r\n\r\n      case field\r\n      when 'name'\r\n        level[:name] = value.to_s\r\n      when 'base_z'\r\n        level[:base_z] = value.to_s.gsub(',', '.').to_f\r\n        @levels.sort_by! { |l| l[:base_z] }\r\n      when 'height'\r\n        level[:height] = value.to_s.gsub(',', '.').to_f\r\n      when 'plan_height'\r\n        level[:plan_height] = value.to_s.gsub(',', '.').to_f\r\n      end\r\n\r\n      model.commit_operation\r\n\r\n      update_ui\r\n    end\r\n\r\n    def self.create_sections(levels_data)\r\n      model = Sketchup.active_model\r\n      return unless model.valid?\r\n\r\n      model.start_operation(obter_texto(:secoes_planta), true)\r\n\r\n      layers = model.layers\r\n      section_layer = layers.add(obter_texto(:secoes_planta)) unless layers[obter_texto(:secoes_planta)]\r\n      section_layer ||= layers[obter_texto(:secoes_planta)]\r\n\r\n      model.entities.grep(Sketchup::SectionPlane) do |e|\r\n        e.erase! if e.layer == section_layer\r\n      end\r\n\r\n      created = 0\r\n      levels_data.each do |level_data|\r\n        level = @levels.find { |l| l[:id].to_s == level_data['id'] }\r\n        next unless level\r\n\r\n        begin\r\n          z_position = level[:base_z] + level[:plan_height]\r\n\r\n          z_position_in_inches = case @current_unit\r\n            when 'metros' then z_position.m\r\n            when 'centimetros' then (z_position * 100).cm\r\n            when 'milimetros' then (z_position * 1000).mm\r\n            when 'polegadas' then z_position.inch\r\n            when 'jardas' then z_position.yd\r\n            when 'pes' then z_position.ft\r\n            else z_position.m\r\n          end\r\n\r\n          plane = [0, 0, -1, z_position_in_inches]\r\n          section = model.entities.add_section_plane(plane)\r\n          section.name = \"#{level[:name]} - #{obter_texto(:secoes_planta)}\"\r\n          section.layer = section_layer\r\n          section.visible = true\r\n\r\n          if section.respond_to?(:cutting_plane_visible=)\r\n            section.cutting_plane_visible = true\r\n          end\r\n\r\n          created += 1\r\n        rescue => e\r\n          puts \"Error creating section for level #{level[:name]}: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n          show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n        end\r\n      end\r\n\r\n      model.commit_operation\r\n    end\r\n\r\n    def self.create_ceiling_sections(levels_data)\r\n      model = Sketchup.active_model\r\n      return unless model.valid?\r\n\r\n      model.start_operation(obter_texto(:secoes_forro), true)\r\n\r\n      layers = model.layers\r\n      section_layer = layers.add(obter_texto(:secoes_forro)) unless layers[obter_texto(:secoes_forro)]\r\n      section_layer ||= layers[obter_texto(:secoes_forro)]\r\n\r\n      model.entities.grep(Sketchup::SectionPlane) do |e|\r\n        e.erase! if e.layer == section_layer\r\n      end\r\n\r\n      created = 0\r\n      levels_data.each do |level_data|\r\n        level = @levels.find { |l| l[:id].to_s == level_data['id'] }\r\n        next unless level\r\n\r\n        begin\r\n          z_position = level[:base_z] + level[:plan_height]\r\n\r\n          z_position_in_inches = case @current_unit\r\n            when 'metros' then z_position.m\r\n            when 'centimetros' then (z_position * 100).cm\r\n            when 'milimetros' then (z_position * 1000).mm\r\n            when 'polegadas' then z_position.inch\r\n            when 'jardas' then z_position.yd\r\n            when 'pes' then z_position.ft\r\n            else z_position.m\r\n          end\r\n\r\n          plane = [0, 0, 1, -z_position_in_inches]\r\n          section = model.entities.add_section_plane(plane)\r\n          section.name = \"#{level[:name]} - #{obter_texto(:secoes_forro)}\"\r\n          section.layer = section_layer\r\n          section.visible = true\r\n\r\n          if section.respond_to?(:cutting_plane_visible=)\r\n            section.cutting_plane_visible = true\r\n          end\r\n\r\n          created += 1\r\n        rescue => e\r\n          puts \"Error creating ceiling section for level #{level[:name]}: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n          show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n        end\r\n      end\r\n\r\n      model.commit_operation\r\n    end\r\n\r\n   def self.create_vertical_sections\r\n    model = Sketchup.active_model\r\n    return unless model.valid?\r\n\r\n    model.start_operation(obter_texto(:secoes_corte), true)\r\n\r\n    # Abordagem HIBRIDA: primeiro tenta o metodo rapido, depois fallback para metodo completo\r\n    bounding_box = Geom::BoundingBox.new\r\n\r\n    # 1. Tenta o metodo rapido primeiro (funciona na maioria dos casos)\r\n    quick_bb = model.bounds\r\n    unless quick_bb.empty?\r\n      bounding_box.add(quick_bb)\r\n    else\r\n      # 2. Fallback: metodo manual otimizado para XRefs\r\n      model.entities.each do |entity|\r\n        next unless entity.visible?\r\n\r\n        if entity.is_a?(Sketchup::Face)\r\n          entity.vertices.each { |v| bounding_box.add(v.position) }\r\n        elsif entity.is_a?(Sketchup::Group) && entity.visible?\r\n          entity.bounds.each { |point| bounding_box.add(point.transform(entity.transformation)) }\r\n        elsif entity.is_a?(Sketchup::ComponentInstance) && entity.visible?\r\n          # Para componentes e XRefs, usa a bounding box transformada\r\n          entity.bounds.each { |point| bounding_box.add(point.transform(entity.transformation)) }\r\n        end\r\n      end\r\n    end\r\n\r\n    if bounding_box.empty?\r\n      UI.messagebox(obter_texto(:sem_geometria))\r\n      model.abort_operation\r\n      return\r\n    end\r\n\r\n    min_point = bounding_box.min\r\n    max_point = bounding_box.max\r\n\r\n    # Calcula o centro REAL da geometria\r\n    center_x = (min_point.x + max_point.x) / 2.0\r\n    center_y = (min_point.y + max_point.y) / 2.0\r\n\r\n    # Offset a partir do centro (em metros)\r\n    offset = @section_offset || 1.0.m\r\n\r\n    layers = model.layers\r\n    section_layer = layers.add(obter_texto(:secoes_corte)) unless layers[obter_texto(:secoes_corte)]\r\n    section_layer ||= layers[obter_texto(:secoes_corte)]\r\n\r\n    # Remove secoes existentes apenas desta camada\r\n    model.entities.grep(Sketchup::SectionPlane) do |e|\r\n      e.erase! if e.layer == section_layer\r\n    end\r\n\r\n    # Cortes posicionados com offset A PARTIR DO CENTRO\r\n    # Secoes no eixo Y (frente/tras) - offset a partir do centro Y\r\n    create_section_plane([0, 1, 0, -(center_y - offset)], \"#{obter_texto(:secao)} #{obter_texto(:secao_frente)}\", section_layer)\r\n    create_section_plane([0, -1, 0, center_y + offset], \"#{obter_texto(:secao)} #{obter_texto(:secao_tras)}\", section_layer)\r\n\r\n    # Secoes no eixo X (direita/esquerda) - offset a partir do centro X\r\n    create_section_plane([1, 0, 0, -(center_x - offset)], \"#{obter_texto(:secao)} #{obter_texto(:secao_direita)}\", section_layer)\r\n    create_section_plane([-1, 0, 0, center_x + offset], \"#{obter_texto(:secao)} #{obter_texto(:secao_esquerda)}\", section_layer)\r\n\r\n    model.commit_operation\r\n   end\r\n\r\n   def self.create_extra_cut_x\r\n    model = Sketchup.active_model\r\n    return unless model.valid?\r\n\r\n    model.start_operation(obter_texto(:corte_extra_x), true)\r\n\r\n    # Metodo otimizado para cortes extras\r\n    bounding_box = Geom::BoundingBox.new\r\n    quick_bb = model.bounds\r\n\r\n    unless quick_bb.empty?\r\n      bounding_box.add(quick_bb)\r\n    else\r\n      # Fallback manual\r\n      model.entities.grep(Sketchup::ComponentInstance) do |instance|\r\n        next unless instance.visible?\r\n        instance.bounds.each { |point| bounding_box.add(point.transform(instance.transformation)) }\r\n      end\r\n    end\r\n\r\n    if bounding_box.empty?\r\n      UI.messagebox(obter_texto(:criar_secoes_primeiro))\r\n      model.abort_operation\r\n      return\r\n    end\r\n\r\n    center_x = (bounding_box.min.x + bounding_box.max.x) / 2.0\r\n\r\n    layers = model.layers\r\n    section_layer = layers[obter_texto(:secoes_corte)] || layers.add(obter_texto(:secoes_corte))\r\n\r\n    # Cria o corte extra exatamente no centro do eixo X\r\n    create_section_plane([0, 1, 0, -center_x], \"#{obter_texto(:secao)} #{obter_texto(:corte_extra_x)}\", section_layer)\r\n\r\n    model.commit_operation\r\n   end\r\n\r\n   def self.create_extra_cut_y\r\n    model = Sketchup.active_model\r\n    return unless model.valid?\r\n\r\n    model.start_operation(obter_texto(:corte_extra_y), true)\r\n\r\n    # Metodo otimizado para cortes extras\r\n    bounding_box = Geom::BoundingBox.new\r\n    quick_bb = model.bounds\r\n\r\n    unless quick_bb.empty?\r\n      bounding_box.add(quick_bb)\r\n    else\r\n      # Fallback manual\r\n      model.entities.grep(Sketchup::ComponentInstance) do |instance|\r\n        next unless instance.visible?\r\n        instance.bounds.each { |point| bounding_box.add(point.transform(instance.transformation)) }\r\n      end\r\n    end\r\n\r\n    if bounding_box.empty?\r\n      UI.messagebox(obter_texto(:criar_secoes_primeiro))\r\n      model.abort_operation\r\n      return\r\n    end\r\n\r\n    center_y = (bounding_box.min.y + bounding_box.max.y) / 2.0\r\n\r\n    layers = model.layers\r\n    section_layer = layers[obter_texto(:secoes_corte)] || layers.add(obter_texto(:secoes_corte))\r\n\r\n    # Cria o corte extra exatamente no centro do eixo Y\r\n    create_section_plane([1, 0, 0, -center_y], \"#{obter_texto(:secao)} #{obter_texto(:corte_extra_y)}\", section_layer)\r\n\r\n    model.commit_operation\r\n   end\r\n\r\n    def self.create_section_plane(plane_equation, name, layer)\r\n      section = Sketchup.active_model.entities.add_section_plane(plane_equation)\r\n      section.name = name\r\n      section.layer = layer\r\n      section.visible = true\r\n      if section.respond_to?(:cutting_plane_visible=)\r\n        section.cutting_plane_visible = true\r\n      end\r\n      section\r\n    end\r\n\r\n    def self.delete_levels(level_ids)\r\n      model = Sketchup.active_model\r\n      return unless model.valid?\r\n\r\n      model.start_operation(obter_texto(:botao_excluir), true)\r\n\r\n      @levels.delete_if { |l| level_ids.include?(l[:id].to_s) }\r\n\r\n      update_ui\r\n      model.commit_operation\r\n    end\r\n\r\n    def self.load_level(level_id)\r\n      level = @levels.find { |l| l[:id] == level_id.to_i }\r\n      return unless level\r\n\r\n      js = <<-JS\r\n        try {\r\n          document.getElementById('level_name').value = #{level[:name].to_json};\r\n          document.getElementById('base_level').value = #{'%.2f' % level[:base_z]}.replace('.', ',');\r\n          document.getElementById('level_height').value = #{'%.2f' % level[:height]}.replace('.', ',');\r\n          document.getElementById('plan_height').value = #{'%.2f' % level[:plan_height]}.replace('.', ',');\r\n        } catch(e) { console.error(e); }\r\n      JS\r\n\r\n      @dialog.execute_script(js)\r\n    rescue => e\r\n      puts \"Error loading level: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n    end\r\n\r\n    def self.update_ui\r\n      js = <<-JS\r\n        try {\r\n          const levelsList = document.getElementById('levels_list');\r\n          const levelSelector = document.getElementById('level_selector');\r\n          const unitSelector = document.getElementById('unit_selector');\r\n\r\n          levelsList.innerHTML = '';\r\n          levelSelector.innerHTML = '<option value=\"\">#{obter_texto(:selecionar_pavimento)}</option>';\r\n\r\n          unitSelector.value = #{@current_unit.to_json};\r\n\r\n          #{@levels.sort_by { |l| l[:base_z] }.map do |level|\r\n            pb_z = level[:base_z] + level[:plan_height]\r\n\r\n            <<-JS\r\n              var option = document.createElement('option');\r\n              option.value = '#{level[:id]}';\r\n              option.text = #{level[:name].to_json};\r\n              levelSelector.appendChild(option);\r\n\r\n              var row = document.createElement('tr');\r\n              row.innerHTML = `\r\n                <td class=\"checkbox-column\"><input type=\"checkbox\" data-id=\"#{level[:id]}\"></td>\r\n                <td class=\"editable-cell\" onclick=\"editCell(this, '#{level[:id]}', 'name', true)\">#{level[:name]}</td>\r\n                <td class=\"editable-cell\" onclick=\"editCell(this, '#{level[:id]}', 'base_z')\">#{'%.2f' % level[:base_z]}m</td>\r\n                <td class=\"editable-cell\" onclick=\"editCell(this, '#{level[:id]}', 'height')\">#{'%.2f' % level[:height]}m</td>\r\n                <td class=\"editable-cell\" onclick=\"editCell(this, '#{level[:id]}', 'plan_height')\">#{'%.2f' % level[:plan_height]}m</td>\r\n                <td>#{'%.2f' % pb_z}m</td>\r\n              `;\r\n              levelsList.appendChild(row);\r\n            JS\r\n          end.join}\r\n        } catch(e) { console.error(e); }\r\n      JS\r\n\r\n      @dialog.execute_script(js)\r\n    rescue => e\r\n      puts \"Error updating UI: #{e.message}\\n#{e.backtrace.join(\"\\n\")}\"\r\n    end\r\n\r\n    def self.load_data_from_file\r\n      path = UI.openpanel(obter_texto(:carregar_dados), \"\", \"JSON Files|*.json||\")\r\n      return unless path && File.exist?(path)\r\n\r\n      unless File.extname(path).downcase == '.json'\r\n        show_alert(obter_texto(:erro), obter_texto(:arquivo_invalido))\r\n        return\r\n      end\r\n\r\n      model = Sketchup.active_model\r\n      return unless model.valid?\r\n\r\n      model.start_operation(obter_texto(:carregar_dados), true)\r\n\r\n      json_data = File.read(path)\r\n      data = JSON.parse(json_data)\r\n\r\n      @levels = data.map do |level|\r\n        {\r\n          id: level['id'] || Time.now.to_i,\r\n          name: level['name'],\r\n          base_z: level['base_z'].to_f,\r\n          height: level['height'].to_f,\r\n          plan_height: level['plan_height'].to_f,\r\n          created_at: level['created_at'] ? Time.parse(level['created_at']) : Time.now\r\n        }\r\n      end\r\n\r\n      @levels.sort_by! { |l| l[:base_z] }\r\n\r\n      if data.first && data.first['preferences']\r\n        prefs = data.first['preferences']\r\n        @current_unit = prefs['unit'] if prefs['unit']\r\n        @current_theme = prefs['theme'] if prefs['theme']\r\n        @current_language = prefs['language'] if prefs['language']\r\n      end\r\n\r\n      model.commit_operation\r\n      update_ui\r\n    rescue => e\r\n      model.abort_operation if model\r\n      show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n    end\r\n\r\n    def self.save_data_to_file\r\n      return if @levels.empty?\r\n\r\n      path = UI.savepanel(obter_texto(:botao_salvar_dados), \"\", \"niveis_pavimentos.json\", \"JSON Files|*.json||\")\r\n      return unless path\r\n\r\n      path += \".json\" unless path.downcase.end_with?('.json')\r\n\r\n      data = @levels.map do |level|\r\n        {\r\n          id: level[:id],\r\n          name: level[:name],\r\n          base_z: level[:base_z],\r\n          height: level[:height],\r\n          plan_height: level[:plan_height],\r\n          created_at: level[:created_at].to_s\r\n        }\r\n      end\r\n\r\n      data.first[:preferences] = {\r\n        unit: @current_unit,\r\n        theme: @current_theme,\r\n        language: @current_language.to_s\r\n      }\r\n\r\n      File.open(path, 'w') { |f| f.write(JSON.pretty_generate(data)) }\r\n\r\n      show_alert(obter_texto(:dados_salvos), path)\r\n    rescue => e\r\n      show_alert(obter_texto(:erro), \"#{obter_texto(:erro)}: #{e.message}\")\r\n    end\r\n\r\n    def self.executar\r\n      criar_interface_niveis\r\n    end\r\n\r\n    unless file_loaded?(__FILE__)\r\n      UI.menu('Plugins').add_item(obter_texto(:titulo)) { executar }\r\n      file_loaded(__FILE__)\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::GerenciadorPavimentos.executar"
    },
    "enabled": false,
    "execute": true,
    "video": "https://youtu.be/LO2alFq6e0Y"
  },
  {
    "id": "posiciona-ou-centraliza-c4s9d",
    "title": {
      "pt": "Posiciona ou Centraliza",
      "en": "Position or Center",
      "es": "Posici√≥n o Centro"
    },
    "author": "Comunidade ScriptUp",
    "version": "1.9",
    "description": {
      "pt": "Posiciona ou centraliza um ou v√°rios grupos/componentes de acordo com refer√™ncia selecionadas no modelo. Use as setas para direita ou para esquerda para rotacionar. Voc√™ tamb√©m pode digitar quantos graus deseja rotacionar por clique.",
      "en": "Positions or centers one or more groups/components according to selected references in the model. Use the right or left arrows to rotate. You can also type how many degrees you want to rotate per click.",
      "es": "Posiciona o centra uno o m√°s grupos/componentes seg√∫n las referencias seleccionadas en el modelo. Usa las flechas derecha o izquierda para rotar. Tambi√©n puedes indicar cu√°ntos grados quieres rotar por clic."
    },
    "keywords": {
      "pt": [
        "centralizar;posicionar"
      ],
      "en": [
        "center; position"
      ],
      "es": [
        "centro; posici√≥n"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module CentralizadorInterativo\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao => \"Selecione um ou mais grupos ou componentes para centralizar.\",\r\n        :modo_centralizar => \"Centralizar\",\r\n        :modo_posicionar => \"Posicionar\",\r\n        :status_texto => \"Modo: %s. Clique em refer√™ncias. CTRL alterna modo. ‚Üê/‚Üí rotaciona. VCB define √¢ngulo.\",\r\n        :op_nome => \"Reposicionar bloco\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao => \"Select one or more groups or components to center.\",\r\n        :modo_centralizar => \"Center\",\r\n        :modo_posicionar => \"Position\",\r\n        :status_texto => \"Mode: %s. Click references. CTRL toggles mode. ‚Üê/‚Üí rotates. VCB sets angle.\",\r\n        :op_nome => \"Reposition block\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao => \"Seleccione uno o m√°s grupos o componentes para centrar.\",\r\n        :modo_centralizar => \"Centrar\",\r\n        :modo_posicionar => \"Posicionar\",\r\n        :status_texto => \"Modo: %s. Clic en referencias. CTRL cambia modo. ‚Üê/‚Üí rota. VCB define √°ngulo.\",\r\n        :op_nome => \"Reposicionar bloque\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    VK_LEFT     = 0x25\r\n    VK_RIGHT    = 0x27\r\n    VK_CONTROL  = 0x11\r\n\r\n    class CentralizadorTool\r\n      def initialize(alvo)\r\n        @alvo = alvo\r\n        @ref1 = nil\r\n        @ref2 = nil\r\n        @tmp_refs = []\r\n        @context = Sketchup.active_model.active_entities\r\n        @hover_preview_inst = nil\r\n        @ref1_ent = nil\r\n        @ref2_ent = nil\r\n        @modo = :centralizar\r\n        @angulo_input = 90.degrees\r\n        atualizar_mensagem_padrao\r\n      end\r\n\r\n      def atualizar_status(msg)\r\n        Sketchup.set_status_text(msg)\r\n      end\r\n\r\n      def atualizar_mensagem_padrao\r\n        modo_str = @modo == :centralizar ? CentralizadorInterativo.obter_texto(:modo_centralizar) : CentralizadorInterativo.obter_texto(:modo_posicionar)\r\n        msg = sprintf(CentralizadorInterativo.obter_texto(:status_texto), modo_str)\r\n        atualizar_status(msg)\r\n      end\r\n\r\n      def resume(view); atualizar_mensagem_padrao; end\r\n      def onResume(view); atualizar_mensagem_padrao; end\r\n      def activate; atualizar_mensagem_padrao; end\r\n\r\n      def onUserText(text, view)\r\n        valor = text.to_f\r\n        @angulo_input = valor.degrees if valor.abs > 0\r\n      end\r\n\r\n      def onKeyDown(key, repeat, flags, view)\r\n        case key\r\n        when VK_CONTROL\r\n          @modo = (@modo == :centralizar ? :posicionar : :centralizar)\r\n          atualizar_mensagem_padrao\r\n          view.invalidate\r\n        when VK_LEFT\r\n          aplicar_rotacao(-@angulo_input)\r\n        when VK_RIGHT\r\n          aplicar_rotacao(@angulo_input)\r\n        end\r\n      end\r\n\r\n      def aplicar_rotacao(angulo)\r\n        centro = bounding_box_global(@alvo).center\r\n        transform = Geom::Transformation.rotation(centro, [0, 0, 1], angulo)\r\n        @alvo.each { |ent| ent.transform!(transform) }\r\n      end\r\n\r\n      def limpar_temporarios\r\n        @tmp_refs.each { |inst| inst.erase! if inst.valid? }\r\n        @tmp_refs.clear\r\n        limpar_preview\r\n      end\r\n\r\n      def onMouseMove(flags, x, y, view)\r\n        ph = view.pick_helper\r\n        ph.do_pick(x, y)\r\n        path = ph.path_at(0)\r\n        ent = path&.reverse&.find { |e| e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance) }\r\n\r\n        if ent && !@alvo.include?(ent) && ent.valid?\r\n          limpar_preview\r\n          transf = path.reduce(Geom::Transformation.new) { |acc, e| acc *= e.transformation if e.respond_to?(:transformation); acc }\r\n          defn = ent.definition\r\n          @hover_preview_inst = @context.add_instance(defn, transf)\r\n          @hover_preview_inst.hidden = true\r\n        else\r\n          limpar_preview\r\n        end\r\n        view.invalidate\r\n      end\r\n\r\n      def draw(view)\r\n        return unless @hover_preview_inst && @hover_preview_inst.valid?\r\n        view.line_width = 3\r\n        view.drawing_color = 'red'\r\n        defn_bounds = @hover_preview_inst.definition.bounds\r\n        transf = @hover_preview_inst.transformation\r\n        corners = (0..7).map { |i| defn_bounds.corner(i).transform(transf) }\r\n        arestas = [[0,1],[1,3],[3,2],[2,0],[4,5],[5,7],[7,6],[6,4],[0,4],[1,5],[2,6],[3,7]]\r\n        linhas = arestas.flat_map { |i,j| [corners[i], corners[j]] }\r\n        view.draw(GL_LINES, *linhas)\r\n      end\r\n\r\n      def limpar_preview\r\n        @hover_preview_inst.erase! if @hover_preview_inst&.valid?\r\n        @hover_preview_inst = nil\r\n      end\r\n\r\n      def onLButtonDown(flags, x, y, view)\r\n        ph = view.pick_helper\r\n        ph.do_pick(x, y)\r\n        path = ph.path_at(0)\r\n        return unless path && !path.empty?\r\n\r\n        ref_ent = path.reverse.find { |e| e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance) }\r\n        return unless ref_ent\r\n        return if @alvo.include?(ref_ent)\r\n\r\n        ref_tmp = criar_instancia_temporaria(ref_ent, path)\r\n        return unless ref_tmp\r\n\r\n        if @modo == :posicionar\r\n          centralizar_entre(ref_tmp, ref_tmp, true)\r\n          atualizar_mensagem_padrao\r\n          return\r\n        end\r\n\r\n        if @ref1 && @ref2\r\n          @ref1 = nil\r\n          @ref2 = nil\r\n        end\r\n\r\n        if @ref1.nil?\r\n          @ref1 = ref_tmp\r\n          @ref1_ent = ref_ent\r\n        elsif @ref2.nil?\r\n          @ref2 = ref_tmp\r\n          @ref2_ent = ref_ent\r\n          mesmas_instancias = @ref1_ent == @ref2_ent && @ref1_ent.transformation == @ref2_ent.transformation\r\n          centralizar_entre(@ref1, @ref2, mesmas_instancias)\r\n          @ref1 = nil\r\n          @ref2 = nil\r\n        end\r\n\r\n        atualizar_mensagem_padrao\r\n        view.invalidate\r\n      end\r\n\r\n      def criar_instancia_temporaria(orig_ent, path)\r\n        transf_global = path.reduce(Geom::Transformation.new) { |acc, ent| acc *= ent.transformation if ent.respond_to?(:transformation); acc }\r\n        defn = orig_ent.definition\r\n        inst = @context.add_instance(defn, transf_global)\r\n        inst.hidden = true\r\n        @tmp_refs << inst\r\n        inst\r\n      end\r\n\r\n      def centralizar_entre(ref1, ref2, mesmas_entidades)\r\n        model = Sketchup.active_model\r\n        model.start_operation(CentralizadorInterativo.obter_texto(:op_nome), true)\r\n\r\n        bounds_ref = bounding_box_global(ref1)\r\n        bounds_bloco = bounding_box_global(@alvo)\r\n        centro_ref = bounds_ref.center\r\n        centro_bloco = bounds_bloco.center\r\n\r\n        deslocamento = if mesmas_entidades\r\n          eixo = detectar_eixo_de_maior_separacao(bounds_bloco, bounds_ref)\r\n          case eixo\r\n          when :x\r\n            dx = centro_bloco.x < centro_ref.x ? bounds_ref.min.x - bounds_bloco.max.x : bounds_ref.max.x - bounds_bloco.min.x\r\n            Geom::Vector3d.new(dx, 0, 0)\r\n          when :y\r\n            dy = centro_bloco.y < centro_ref.y ? bounds_ref.min.y - bounds_bloco.max.y : bounds_ref.max.y - bounds_bloco.min.y\r\n            Geom::Vector3d.new(0, dy, 0)\r\n          when :z\r\n            dz = centro_bloco.z < centro_ref.z ? bounds_ref.min.z - bounds_bloco.max.z : bounds_ref.max.z - bounds_bloco.min.z\r\n            Geom::Vector3d.new(0, 0, dz)\r\n          end\r\n        else\r\n          bb1 = bounding_box_global(ref1)\r\n          bb2 = bounding_box_global(ref2)\r\n          bb_bloco = bounding_box_global(@alvo)\r\n          eixo = detectar_eixo_de_maior_separacao(bb1, bb2)\r\n          min1, max1 = bb1.min.send(eixo), bb1.max.send(eixo)\r\n          min2, max2 = bb2.min.send(eixo), bb2.max.send(eixo)\r\n          min_face = [min1, min2].max\r\n          max_face = [max1, max2].min\r\n          centro_alvo = bb_bloco.center\r\n          meio = (min_face + max_face) / 2.0\r\n          distancia = meio - centro_alvo.send(eixo)\r\n          case eixo\r\n          when :x then Geom::Vector3d.new(distancia, 0, 0)\r\n          when :y then Geom::Vector3d.new(0, distancia, 0)\r\n          when :z then Geom::Vector3d.new(0, 0, distancia)\r\n          end\r\n        end\r\n\r\n        @alvo.each { |ent| ent.transform!(Geom::Transformation.translation(deslocamento)) }\r\n        limpar_temporarios\r\n        model.commit_operation\r\n      end\r\n\r\n      def detectar_eixo_de_maior_separacao(bounds1, bounds2)\r\n        dx = [bounds1.min.x - bounds2.max.x, bounds2.min.x - bounds1.max.x].max\r\n        dy = [bounds1.min.y - bounds2.max.y, bounds2.min.y - bounds1.max.y].max\r\n        dz = [bounds1.min.z - bounds2.max.z, bounds2.min.z - bounds1.max.z].max\r\n        return :x if dx >= dy && dx >= dz\r\n        return :y if dy >= dz\r\n        :z\r\n      end\r\n\r\n      def bounding_box_global(entidades)\r\n        bb = Geom::BoundingBox.new\r\n        if entidades.respond_to?(:each)\r\n          entidades.each do |e|\r\n            (0..7).each { |i| bb.add(e.definition.bounds.corner(i).transform(e.transformation)) }\r\n          end\r\n        else\r\n          (0..7).each { |i| bb.add(entidades.definition.bounds.corner(i).transform(entidades.transformation)) }\r\n        end\r\n        bb\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      if selection.empty? || !selection.all? { |e| e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance) }\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n\r\n      alvo = selection.to_a\r\n      model.select_tool(CentralizadorTool.new(alvo))\r\n    end\r\n  end\r\nend\r\n\r\nScriptUpComunidade::CentralizadorInterativo.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "puxar-linhas-c4u1m",
    "title": {
      "pt": "Puxar Linhas",
      "en": "Pull Lines",
      "es": "L√≠neas de tracci√≥n"
    },
    "author": "Henrique Barsa",
    "version": "1.0",
    "description": {
      "pt": "Voc√™ consegue dar Push/Pull em linhas. Selecione uma ou mais linhas, rode o Script e puxe ela para onde quiser. Use o Shift para travar no eixo.",
      "en": "You can push/pull lines. Select one or more lines, run the script, and drag it to where you want. Use Shift to lock it to the axis.",
      "es": "Puedes mover o arrastrar l√≠neas. Selecciona una o m√°s l√≠neas, ejecuta el script y arr√°stralo a donde quieras. Usa May√∫s para bloquearlo en el eje."
    },
    "keywords": {
      "pt": [
        "linhas",
        "extrus√£o",
        "puxar"
      ],
      "en": [
        "lines",
        "extrusion",
        "to pull"
      ],
      "es": [
        "pauta",
        "extrusi√≥n",
        "tirar"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module ExtrusaoDeArestas\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao => \"Selecione ao menos uma aresta antes de executar.\",\r\n        :status_p1    => \"Extrude: clique no primeiro ponto\",\r\n        :status_p2    => \"Extrude: clique no segundo ponto ou digite dist√¢ncia\",\r\n        :erro_vcb     => \"N√£o foi poss√≠vel converter ‚Äú%s‚Äù em comprimento.\",\r\n        :op_nome      => \"Extrudar Arestas\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao => \"Select at least one edge before running.\",\r\n        :status_p1    => \"Extrude: click on the first point\",\r\n        :status_p2    => \"Extrude: click on the second point or type distance\",\r\n        :erro_vcb     => \"Could not convert ‚Äú%s‚Äù into length.\",\r\n        :op_nome      => \"Extrude Edges\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao => \"Seleccione al menos una arista antes de ejecutar.\",\r\n        :status_p1    => \"Extruir: haga clic en el primer punto\",\r\n        :status_p2    => \"Extruir: haga clic en el segundo punto o escriba la distancia\",\r\n        :erro_vcb     => \"No se pudo convertir ‚Äú%s‚Äù en longitud.\",\r\n        :op_nome      => \"Extruir Aristas\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    class ExtrudeLineTool\r\n      CURSOR_MOVE ||= 641\r\n\r\n      def initialize\r\n        @ip1 = Sketchup::InputPoint.new\r\n        @ip2 = Sketchup::InputPoint.new\r\n        @state = 0\r\n        @dragging = false\r\n        @xdown = @ydown = 0\r\n      end\r\n\r\n      def activate\r\n        @edges = Sketchup.active_model.selection.grep(Sketchup::Edge)\r\n        if @edges.empty?\r\n          UI.messagebox(ExtrusaoDeArestas.obter_texto(:erro_selecao))\r\n          Skup.send_action(\"selectSelectionTool:\")\r\n          return\r\n        end\r\n        Sketchup.set_status_text(ExtrusaoDeArestas.obter_texto(:status_p1), SB_PROMPT)\r\n      end\r\n\r\n      def deactivate(view)\r\n        view.invalidate if @state != 0\r\n      end\r\n\r\n      def onSetCursor\r\n        UI.set_cursor(CURSOR_MOVE)\r\n        true\r\n      end\r\n\r\n      def onMouseMove(flags, x, y, view)\r\n        if @state.zero?\r\n          @ip1.pick(view, x, y)\r\n          view.invalidate if @ip1.valid?\r\n          view.tooltip = @ip1.tooltip\r\n        else\r\n          @ip2.pick(view, x, y, @ip1)\r\n          view.invalidate\r\n          Sketchup.set_status_text(@ip1.position.distance(@ip2.position).to_s, SB_VCB_VALUE) if @ip2.valid?\r\n          @dragging = true if (x - @xdown).abs > 5 || (y - @ydown).abs > 5\r\n        end\r\n      end\r\n\r\n      def onLButtonDown(flags, x, y, view)\r\n        if @state.zero?\r\n          @ip1.pick(view, x, y)\r\n          if @ip1.valid?\r\n            @state = 1\r\n            Sketchup.set_status_text(ExtrusaoDeArestas.obter_texto(:status_p2), SB_PROMPT)\r\n            @xdown, @ydown = x, y\r\n          end\r\n        else\r\n          finish_extrude if @ip2.valid?\r\n        end\r\n        view.lock_inference\r\n      end\r\n\r\n      def onLButtonUp(flags, x, y, view)\r\n        finish_extrude if @dragging && @ip2.valid?\r\n      end\r\n\r\n      def onUserText(text, view)\r\n        return unless @state == 1 && @ip2.valid?\r\n        length = text.to_l rescue nil\r\n        unless length\r\n          UI.beep\r\n          UI.messagebox(ExtrusaoDeArestas.obter_texto(:erro_vcb) % text)\r\n          return\r\n        end\r\n        vec = @ip2.position - @ip1.position\r\n        vec.length = length\r\n        finish_extrude(@ip1.position, @ip1.position.offset(vec))\r\n      end\r\n\r\n      def draw(view)\r\n        if @ip1.valid?\r\n          @ip1.draw(view)\r\n          view.draw_points(@ip1.position, 8, 1, \"red\")\r\n        end\r\n        if @ip2.valid?\r\n          @ip2.draw(view)\r\n          view.set_color_from_line(@ip1, @ip2) rescue view.drawing_color = \"black\"\r\n          view.draw_line(@ip1.position, @ip2.position)\r\n          view.draw_points(@ip2.position, 8, 1, \"red\")\r\n\r\n          vector = @ip1.position.vector_to(@ip2.position)\r\n          preview = Sketchup::Color.new(200,200,200,128)\r\n          view.drawing_color = preview\r\n          @edges.each do |edge|\r\n            a = edge.start.position\r\n            b = edge.end.position\r\n            a2 = a.offset(vector)\r\n            b2 = b.offset(vector)\r\n            view.draw(GL_QUADS, [a, b, b2, a2])\r\n            view.draw(GL_LINE_LOOP, [a, b, b2, a2])\r\n          end\r\n          view.drawing_color = \"black\"\r\n        end\r\n      end\r\n\r\n      private\r\n\r\n      def finish_extrude(pt1=@ip1.position, pt2=@ip2.position)\r\n        create_geometry(pt1, pt2)\r\n        Sketchup.send_action(\"selectSelectionTool:\")\r\n      end\r\n\r\n      def create_geometry(p1, p2)\r\n        model = Sketchup.active_model\r\n        model.start_operation(ExtrusaoDeArestas.obter_texto(:op_nome), true)\r\n        vector = p1.vector_to(p2)\r\n        group = model.active_entities.add_group\r\n        ents = group.entities\r\n\r\n        @edges.each do |edge|\r\n          a, b = edge.start.position, edge.end.position\r\n          ents.add_line(a, b)\r\n          ents.add_line(a.offset(vector), b.offset(vector))\r\n          ents.add_line(a, a.offset(vector))\r\n          ents.add_line(b, b.offset(vector))\r\n          ents.add_face(a, b, b.offset(vector), a.offset(vector)) rescue nil\r\n        end\r\n\r\n        group.entities.grep(Sketchup::Face).each { |f| f.reverse! if f.normal.z < 0 }\r\n        model.commit_operation\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      Sketchup.active_model.select_tool(ExtrudeLineTool.new)\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::ExtrusaoDeArestas.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "reexibe-arestas-selecionadas-c4vwn",
    "title": {
      "pt": "Reexibe Arestas Selecionadas",
      "en": "Re-display Selected Edges",
      "es": "Volver a mostrar los bordes seleccionados"
    },
    "author": "F√°bio Coutinho",
    "version": "1.1",
    "description": {
      "pt": "Reexibe as arestas selecionadas independente se elas est√£o suavizadas ou ocultas.",
      "en": "Redisplays the selected edges regardless of whether they are smoothed or hidden.",
      "es": "Vuelve a mostrar los bordes seleccionados independientemente de si est√°n suavizados u ocultos."
    },
    "keywords": {
      "pt": [
        "reexibir arestas"
      ],
      "en": [
        "redisplay edges"
      ],
      "es": [
        "volver a mostrar los bordes"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module RemoverSuavizacao\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao => \"Nenhuma entidade selecionada.\",\r\n        :op_nome      => \"Remover Suaviza√ß√£o\",\r\n        :concluido    => \"Processo conclu√≠do: suaviza√ß√£o removida e arestas reexibidas.\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao => \"No entities selected.\",\r\n        :op_nome      => \"Remove Smoothing\",\r\n        :concluido    => \"Process completed: smoothing removed and edges unhidden.\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao => \"Ninguna entidad seleccionada.\",\r\n        :op_nome      => \"Eliminar Suavizado\",\r\n        :concluido    => \"Proceso completado: suavizado eliminado y aristas mostradas.\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      if selection.empty?\r\n        puts obter_texto(:erro_selecao)\r\n      else\r\n        model.start_operation(obter_texto(:op_nome), true)\r\n\r\n        # Trata arestas diretamente na sele√ß√£o\r\n        selection.grep(Sketchup::Edge).each do |edge|\r\n          processar_aresta(edge)\r\n        end\r\n\r\n        # Itera pelas faces para garantir que arestas conectadas sejam tratadas\r\n        model.active_entities.grep(Sketchup::Face).each do |face|\r\n          face.edges.each do |edge|\r\n            if selection.include?(edge)\r\n              processar_aresta(edge)\r\n            end\r\n          end\r\n        end\r\n\r\n        model.commit_operation\r\n        puts obter_texto(:concluido)\r\n      end\r\n    end\r\n\r\n    def self.processar_aresta(edge)\r\n      # Reexibe se estiver oculta\r\n      edge.hidden = false\r\n      \r\n      # Remove soft e smooth\r\n      edge.soft = false\r\n      edge.smooth = false\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::RemoverSuavizacao.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "reexibir-tudo-c4xle",
    "title": {
      "pt": "Reexibir tudo",
      "en": "Show all again",
      "es": "Mostrar todo de nuevo"
    },
    "author": "F√°bio Coutinho",
    "version": "1.0",
    "description": {
      "pt": "Script para reexibir tudo, na sele√ß√£o ou no modelo. Grupos, componentes, faces e arestas. Aninhados ou n√£o.",
      "en": "Script to redisplay everything, in the selection or in the model. Groups, components, faces, and edges. Nested or not.",
      "es": "Script para volver a mostrar todo, en la selecci√≥n o en el modelo. Grupos, componentes, caras y aristas. Anidados o no."
    },
    "keywords": {
      "pt": [
        "reexibir",
        "unhide"
      ],
      "en": [
        "re-air",
        "unhide"
      ],
      "es": [
        "re-emisi√≥n",
        "mostrar"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module DesocultarElementos\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :pergunta_modo   => \"Deseja desocultar apenas os elementos selecionados? (Sim para Sele√ß√£o, N√£o para Todo o Modelo)\",\r\n        :pergunta_groups => \"Deseja desocultar Grupos e Componentes?\",\r\n        :pergunta_faces  => \"Deseja desocultar Linhas e Faces?\",\r\n        :op_nome         => \"Desocultar Elementos\",\r\n        :sucesso         => \"Todos os elementos selecionados foram desocultados!\"\r\n      },\r\n      'en-US' => {\r\n        :pergunta_modo   => \"Do you want to unhide only the selected elements? (Yes for Selection, No for Entire Model)\",\r\n        :pergunta_groups => \"Do you want to unhide Groups and Components?\",\r\n        :pergunta_faces  => \"Do you want to unhide Edges and Faces?\",\r\n        :op_nome         => \"Unhide Elements\",\r\n        :sucesso         => \"All selected elements have been unhidden!\"\r\n      },\r\n      'es' => {\r\n        :pergunta_modo   => \"¬øDesea desocultar solo los elementos seleccionados? (S√≠ para Selecci√≥n, No para todo el Modelo)\",\r\n        :pergunta_groups => \"¬øDesea desocultar Grupos y Componentes?\",\r\n        :pergunta_faces  => \"¬øDesea desocultar L√≠neas y Caras?\",\r\n        :op_nome         => \"Desocultar Elementos\",\r\n        :sucesso         => \"¬°Todos los elementos seleccionados han sido desocultados!\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.ask_user(question)\r\n      result = UI.messagebox(question, MB_YESNO)\r\n      result == IDYES\r\n    end\r\n\r\n    def self.unhide_groups_and_components(entities)\r\n      entities.each do |entity|\r\n        if entity.is_a?(Sketchup::Group) || entity.is_a?(Sketchup::ComponentInstance)\r\n          entity.hidden = false\r\n          unhide_groups_and_components(entity.definition.entities)\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.unhide_faces_and_edges(entities)\r\n      entities.each do |entity|\r\n        if entity.is_a?(Sketchup::Edge) || entity.is_a?(Sketchup::Face)\r\n          entity.hidden = false\r\n        elsif entity.is_a?(Sketchup::Group) || entity.is_a?(Sketchup::ComponentInstance)\r\n          # Percorre dentro de grupos/componentes j√° desocultados\r\n          unhide_faces_and_edges(entity.definition.entities)\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      # Perguntar se deseja agir na sele√ß√£o ou no modelo inteiro\r\n      use_selection = ask_user(obter_texto(:pergunta_modo))\r\n\r\n      entities = use_selection && !selection.empty? ? selection : model.active_entities\r\n\r\n      # Perguntar se quer desocultar grupos e componentes\r\n      unhide_groups = ask_user(obter_texto(:pergunta_groups))\r\n      \r\n      # Perguntar se quer desocultar arestas e faces\r\n      unhide_faces = ask_user(obter_texto(:pergunta_faces))\r\n\r\n      # Processar os elementos\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n\r\n      # Primeiro, desocultar grupos e componentes, se permitido\r\n      unhide_groups_and_components(entities) if unhide_groups\r\n\r\n      # Depois, garantir que arestas e faces sejam desocultadas\r\n      unhide_faces_and_edges(entities) if unhide_faces\r\n\r\n      model.commit_operation\r\n\r\n      UI.messagebox(obter_texto(:sucesso))\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::DesocultarElementos.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "remover-elementos-ocultos-c4zgs",
    "title": {
      "pt": "Remover Elementos Ocultos",
      "en": "Remove Hidden Elements",
      "es": "Eliminar elementos ocultos"
    },
    "author": "F√°bio Coutinho",
    "version": "1.0",
    "description": {
      "pt": "Apaga todos os grupos ou componentes ocultos em qualquer n√≠vel de aninhamento, estejam eles dentro de grupos ou componentes boqueados ou n√£o.",
      "en": "Deletes all hidden groups or components at any nesting level, whether they are inside locked groups or components or not.",
      "es": "Elimina todos los grupos o componentes ocultos en cualquier nivel de anidamiento, ya sea que est√©n dentro de grupos o componentes bloqueados o no."
    },
    "keywords": {
      "pt": [
        "remover ocultos",
        "apagar ocultos",
        "limpar ocultos"
      ],
      "en": [
        "remove hidden",
        "delete hidden",
        "clear hidden"
      ],
      "es": [
        "eliminar oculto",
        "eliminar oculto",
        "claro oculto"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module ApagarOcultosRecursivo\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao => \"Por favor, selecione um componente ou grupo para continuar.\",\r\n        :erro_tipo    => \"A sele√ß√£o cont√©m itens que n√£o s√£o componentes ou grupos.\",\r\n        :op_nome      => \"Apagar Componentes Ocultos\",\r\n        :concluido    => \"Limpeza conclu√≠da: componentes ocultos foram removidos.\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao => \"Please select a component or group to continue.\",\r\n        :erro_tipo    => \"The selection contains items that are not components or groups.\",\r\n        :op_nome      => \"Delete Hidden Components\",\r\n        :concluido    => \"Cleanup complete: hidden components have been removed.\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao => \"Por favor, seleccione un componente o grupo para continuar.\",\r\n        :erro_tipo    => \"La selecci√≥n contiene elementos que no son componentes o grupos.\",\r\n        :op_nome      => \"Eliminar Componentes Ocultos\",\r\n        :concluido    => \"Limpieza completada: los componentes ocultos han sido eliminados.\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.delete_hidden_entities_recursively(parent_entity)\r\n      # Obt√©m as entidades da defini√ß√£o (funciona para Grupo e ComponentInstance)\r\n      entities = parent_entity.is_a?(Sketchup::ComponentInstance) ? parent_entity.definition.entities : parent_entity.entities\r\n      \r\n      entities.to_a.each do |entity|\r\n        next unless entity.valid?\r\n        # Verifica se a entidade √© um componente ou grupo\r\n        if entity.is_a?(Sketchup::ComponentInstance) || entity.is_a?(Sketchup::Group)\r\n          # Remove o componente se ele estiver oculto\r\n          if entity.hidden?\r\n            entity.erase!\r\n          else\r\n            # Se n√£o estiver oculto, verifica recursivamente\r\n            delete_hidden_entities_recursively(entity)\r\n          end\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      if selection.empty?\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n\r\n      model.start_operation(obter_texto(:op_nome), true)\r\n\r\n      selection.each do |entity|\r\n        if entity.is_a?(Sketchup::ComponentInstance) || entity.is_a?(Sketchup::Group)\r\n          delete_hidden_entities_recursively(entity)\r\n        else\r\n          puts obter_texto(:erro_tipo)\r\n        end\r\n      end\r\n\r\n      model.commit_operation\r\n      puts obter_texto(:concluido)\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::ApagarOcultosRecursivo.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "retirar-tarjas-pretas-v-ray-c51zz",
    "title": {
      "pt": "Retirar Tarjas Pretas V-Ray",
      "en": "Remove Black Bars from V-Ray",
      "es": "Eliminar barras negras de V-Ray"
    },
    "author": "Henrique Barsa",
    "version": "1.0",
    "description": {
      "pt": "Retirar as tarjas pretas (safe frame) da visualiza√ß√£o.",
      "en": "Remove the black bars (safe frame) from the display.",
      "es": "Retire las barras negras (marco seguro) de la pantalla."
    },
    "keywords": {
      "pt": [
        "vray"
      ],
      "en": [
        "v-ray"
      ],
      "es": [
        "v-ray"
      ]
    },
    "code": {
      "pt": "# Obter o modelo ativo e a c√¢mera ativa\r\nmodel = Sketchup.active_model\r\ncamera = model.active_view.camera\r\n\r\n# Definir o valor L/A (aspect_ratio) para 0\r\ncamera.aspect_ratio = 0\r\n\r\n# Atualizar a vista para aplicar as altera√ß√µes da c√¢mera\r\nmodel.active_view.camera = camera\r\nmodel.active_view.refresh\r\n\r\n"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "rotacionar-visao-c53px",
    "title": {
      "pt": "Rotacionar Vis√£o",
      "en": "Rotate View",
      "es": "Girar vista"
    },
    "author": "F√°bio Coutinho",
    "version": "1.3",
    "description": {
      "pt": "Permite rotacionar a vis√£o usando as setas do teclado ou digitando um √¢ngulo.",
      "en": "Allows you to rotate the view using the keyboard arrows or by typing an angle.",
      "es": "Le permite rotar la vista usando las flechas del teclado o escribiendo un √°ngulo."
    },
    "keywords": {
      "pt": [
        "rotacionar vis√£o",
        "arfagem",
        "pitch",
        "rolagem"
      ],
      "en": [
        "rotate view",
        "panting",
        "pitch",
        "scrolling"
      ],
      "es": [
        "rotar vista",
        "jadeo",
        "paso",
        "desplazamiento"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module FerramentaGirarVista\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :desativada      => \"Ferramenta de rota√ß√£o desativada.\",\r\n        :instrucoes      => \"‚Üê ‚Üí ‚Üë ‚Üì para girar. Ctrl alterna entre 1¬∞ e 90¬∞. Modo atual: %{modo}. Digite √¢ngulo + Enter. ESC para sair.\",\r\n        :modo_1          => \"1¬∞\",\r\n        :modo_90         => \"90¬∞\"\r\n      },\r\n      'en-US' => {\r\n        :desativada      => \"Rotation tool deactivated.\",\r\n        :instrucoes      => \"‚Üê ‚Üí ‚Üë ‚Üì to rotate. Ctrl toggles 1¬∞/90¬∞. Current mode: %{modo}. Type angle + Enter. ESC to exit.\",\r\n        :modo_1          => \"1¬∞\",\r\n        :modo_90         => \"90¬∞\"\r\n      },\r\n      'es' => {\r\n        :desativada      => \"Herramienta de rotaci√≥n desactivada.\",\r\n        :instrucoes      => \"‚Üê ‚Üí ‚Üë ‚Üì para girar. Ctrl alterna entre 1¬∞ y 90¬∞. Modo actual: %{modo}. Escriba √°ngulo + Enter. ESC para salir.\",\r\n        :modo_1          => \"1¬∞\",\r\n        :modo_90         => \"90¬∞\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave, variaveis = {})\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      texto  = IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n      \r\n      variaveis.each { |k, v| texto = texto.gsub(\"%{#{k}}\", v.to_s) }\r\n      texto\r\n    end\r\n\r\n    class Tool\r\n      VK_LEFT    = 37 unless defined?(VK_LEFT)\r\n      VK_UP      = 38 unless defined?(VK_UP)\r\n      VK_RIGHT   = 39 unless defined?(VK_RIGHT)\r\n      VK_DOWN    = 40 unless defined?(VK_DOWN)\r\n      VK_ESCAPE  = 27 unless defined?(VK_ESCAPE)\r\n      VK_CONTROL = 17 unless defined?(VK_CONTROL)\r\n\r\n      BASE_ROTATE_SPEED  = 1   unless defined?(BASE_ROTATE_SPEED)\r\n      BOOST_ROTATE_SPEED = 90  unless defined?(BOOST_ROTATE_SPEED)\r\n      TIMER_INTERVAL     = 0.016 unless defined?(TIMER_INTERVAL)\r\n      CURSOR_ID          = 643 unless defined?(CURSOR_ID)\r\n\r\n      def initialize\r\n        @rotate_left = false\r\n        @rotate_right = false\r\n        @rotate_up = false\r\n        @rotate_down = false\r\n        @use_boost = false\r\n        @timer_id = nil\r\n        start_rotation_timer\r\n      end\r\n\r\n      def activate\r\n        update_status_text\r\n      end\r\n\r\n      def deactivate(view)\r\n        stop_rotation_timer\r\n        Sketchup.status_text = FerramentaGirarVista.obter_texto(:desativada)\r\n      end\r\n\r\n      def getCursor\r\n        CURSOR_ID\r\n      end\r\n\r\n      def onKeyDown(key, repeat, flags, view)\r\n        case key\r\n        when VK_LEFT\r\n          if @use_boost\r\n            rotate_view(-BOOST_ROTATE_SPEED, :roll)\r\n          else\r\n            @rotate_left = true\r\n          end\r\n        when VK_RIGHT\r\n          if @use_boost\r\n            rotate_view(+BOOST_ROTATE_SPEED, :roll)\r\n          else\r\n            @rotate_right = true\r\n          end\r\n        when VK_UP\r\n          if @use_boost\r\n            rotate_view(+BOOST_ROTATE_SPEED, :tilt)\r\n          else\r\n            @rotate_up = true\r\n          end\r\n        when VK_DOWN\r\n          if @use_boost\r\n            rotate_view(-BOOST_ROTATE_SPEED, :tilt)\r\n          else\r\n            @rotate_down = true\r\n          end\r\n        when VK_CONTROL\r\n          @use_boost = !@use_boost\r\n          update_status_text\r\n        when VK_ESCAPE\r\n          Sketchup.active_model.tools.pop_tool\r\n        end\r\n      end\r\n\r\n      def onKeyUp(key, repeat, flags, view)\r\n        case key\r\n        when VK_LEFT    then @rotate_left = false\r\n        when VK_RIGHT   then @rotate_right = false\r\n        when VK_UP      then @rotate_up = false\r\n        when VK_DOWN    then @rotate_down = false\r\n        end\r\n      end\r\n\r\n      def onUserText(text, view)\r\n        if text.strip == \"0\"\r\n          reset_view_orientation\r\n        else\r\n          angle = text.to_f\r\n          rotate_view(angle, :roll) if angle != 0\r\n        end\r\n      end\r\n\r\n      def onCancel(reason, view)\r\n        Sketchup.active_model.tools.pop_tool\r\n      end\r\n\r\n      private\r\n\r\n      def update_status_text\r\n        modo_str = @use_boost ? FerramentaGirarVista.obter_texto(:modo_90) : FerramentaGirarVista.obter_texto(:modo_1)\r\n        Sketchup.status_text = FerramentaGirarVista.obter_texto(:instrucoes, { modo: modo_str })\r\n      end\r\n\r\n      def start_rotation_timer\r\n        @timer_id = UI.start_timer(TIMER_INTERVAL, true) {\r\n          next if @use_boost  # no modo 90¬∞, n√£o repetir rota√ß√£o autom√°tica\r\n          speed = BASE_ROTATE_SPEED\r\n          rotate_view(-speed, :roll) if @rotate_left\r\n          rotate_view(+speed, :roll) if @rotate_right\r\n          rotate_view(+speed, :tilt) if @rotate_up\r\n          rotate_view(-speed, :tilt) if @rotate_down\r\n        }\r\n      end\r\n\r\n      def stop_rotation_timer\r\n        UI.stop_timer(@timer_id) if @timer_id\r\n        @timer_id = nil\r\n      end\r\n\r\n      def rotate_view(degrees, mode = :roll)\r\n        return if degrees == 0\r\n        cam = Sketchup.active_model.active_view.camera\r\n        eye = cam.eye\r\n        target = cam.target\r\n        up = cam.up\r\n        direction = target - eye\r\n        radians = degrees.degrees\r\n\r\n        case mode\r\n        when :roll\r\n          new_up = up.transform(Geom::Transformation.rotation(eye, direction, radians))\r\n          return if invalid_camera?(direction, new_up)\r\n          cam.set(eye, target, new_up)\r\n        when :tilt\r\n          axis = direction * up  # eixo lateral\r\n          t = Geom::Transformation.rotation(eye, axis, radians)\r\n          new_target = target.transform(t)\r\n          new_up = up.transform(t)\r\n          new_direction = new_target - eye\r\n          return if invalid_camera?(new_direction, new_up)\r\n          cam.set(eye, new_target, new_up)\r\n        end\r\n      end\r\n\r\n      def invalid_camera?(direction, up)\r\n        dot = direction.normalize.dot(up.normalize).abs\r\n        dot > 0.999\r\n      end\r\n\r\n      def reset_view_orientation\r\n        cam = Sketchup.active_model.active_view.camera\r\n        eye = cam.eye\r\n        target = cam.target\r\n        cam.set(eye, target, Z_AXIS)\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      Sketchup.active_model.tools.push_tool(Tool.new)\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::FerramentaGirarVista.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "selecao-de-elemento-profundo-c55s7",
    "title": {
      "pt": "Sele√ß√£o de Elemento Profundo",
      "en": "Deep Element Selection",
      "es": "Selecci√≥n de elementos profundos"
    },
    "author": "F√°bio Coutinho",
    "version": "1.9",
    "description": {
      "pt": "Ferramenta de sele√ß√£o de grupo/componente ou face em n√≠veis mais profundos de aninhamento de forma direta. Caso esteja com segmentos de arestas selecionados, voc√™ pode envi√°-lo diretamente para a face profunda com dois cliques. Isso permite planejar cortes para faces internas.",
      "en": "This tool allows you to select groups/components or faces directly at deeper nesting levels. If you have edge segments selected, you can send them directly to the deep face with two clicks. This allows you to plan cuts for internal faces.",
      "es": "Esta herramienta permite seleccionar grupos/componentes o caras directamente en niveles de anidamiento m√°s profundos. Si tiene segmentos de arista seleccionados, puede enviarlos directamente a la cara profunda con dos clics. Esto le permite planificar cortes para caras internas."
    },
    "keywords": {
      "pt": [
        "sele√ß√£o de n√≠vel",
        "selecionar subgrupo"
      ],
      "en": [
        "level selection",
        "select subgroup"
      ],
      "es": [
        "selecci√≥n de nivel",
        "seleccionar subgrupo"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module SelecaoHierarquia\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :msg_copiar      => \"Deseja usar o segmento selecionado para copiar?\",\r\n        :modo_gp_comp    => \"Modo: Grupo/Componente\",\r\n        :modo_face_edge  => \"Modo: Face/Aresta\",\r\n        :status_gp_comp  => \"Grupo/Componente\",\r\n        :status_face_ed  => \"Face/Aresta\",\r\n        :prompt_status   => \"Modo atual: %{mode} | Ctrl para alternar modo | Duplo clique ou Enter para entrar no contexto | Esc para voltar ao n√≠vel do modelo\",\r\n        :op_colar        => \"Colar no local (desagrupado)\"\r\n      },\r\n      'en-US' => {\r\n        :msg_copiar      => \"Do you want to use the selected segment to copy?\",\r\n        :modo_gp_comp    => \"Mode: Group/Component\",\r\n        :modo_face_edge  => \"Mode: Face/Edge\",\r\n        :status_gp_comp  => \"Group/Component\",\r\n        :status_face_ed  => \"Face/Edge\",\r\n        :prompt_status   => \"Current mode: %{mode} | Ctrl to toggle mode | Double click or Enter to enter context | Esc to return to model level\",\r\n        :op_colar        => \"Paste in place (exploded)\"\r\n      },\r\n      'es' => {\r\n        :msg_copiar      => \"¬øDesea utilizar el segmento seleccionado para copiar?\",\r\n        :modo_gp_comp    => \"Modo: Grupo/Componente\",\r\n        :modo_face_edge  => \"Modo: Cara/Arista\",\r\n        :status_gp_comp  => \"Grupo/Componente\",\r\n        :status_face_ed  => \"Cara/Arista\",\r\n        :prompt_status   => \"Modo actual: %{mode} | Ctrl para cambiar modo | Doble clic o Enter para entrar en el contexto | Esc para volver al nivel del modelo\",\r\n        :op_colar        => \"Pegar en su lugar (desagrupado)\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave, variaveis = {})\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      texto  = IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n      \r\n      variaveis.each { |k, v| texto = texto.gsub(\"%{#{k}}\", v.to_s) }\r\n      texto\r\n    end\r\n\r\n    class HoverSelectionTool\r\n      VK_RETURN  ||= 13\r\n      VK_CONTROL ||= 17\r\n      VK_ESCAPE  ||= 27\r\n\r\n      def initialize(ctrl_locked: false, post_enter_action: nil, clipboard_group: nil)\r\n        @model = Sketchup.active_model\r\n        @view = @model.active_view\r\n        @selection_mode = ctrl_locked ? :face_edge : :group_component\r\n        @ctrl_locked = ctrl_locked\r\n        @post_enter_action = post_enter_action\r\n        @clipboard_group = clipboard_group\r\n        @selected_entity = nil\r\n        @selected_instance_path = nil\r\n        @last_mouse_x = nil\r\n        @last_mouse_y = nil\r\n      end\r\n\r\n      def activate\r\n        update_status_text\r\n      end\r\n\r\n      def resume(view)\r\n        update_status_text\r\n        view.invalidate\r\n      end\r\n\r\n      def onMouseMove(flags, x, y, view)\r\n        @last_mouse_x = x\r\n        @last_mouse_y = y\r\n        update_selection(x, y, view)\r\n        highlight_entity(view)\r\n        view.invalidate\r\n      end\r\n\r\n      def onKeyDown(key, repeat, flags, view)\r\n        case key\r\n        when VK_CONTROL\r\n          toggle_selection_mode(view) unless @ctrl_locked\r\n        when VK_RETURN\r\n          refresh_selection_from_last_position(view)\r\n          enter_parent_context(view)\r\n        when VK_ESCAPE\r\n          exit_to_model_level\r\n        end\r\n      end\r\n\r\n      def onLButtonDoubleClick(flags, x, y, view)\r\n        refresh_selection_from_last_position(view)\r\n        enter_parent_context(view)\r\n      end\r\n\r\n      def refresh_selection_from_last_position(view)\r\n        return unless @last_mouse_x && @last_mouse_y\r\n        update_selection(@last_mouse_x, @last_mouse_y, view)\r\n        highlight_entity(view)\r\n      end\r\n\r\n      def update_selection(x, y, view)\r\n        ph = view.pick_helper\r\n        ph.do_pick(x, y)\r\n\r\n        case @selection_mode\r\n        when :group_component\r\n          @selected_entity, @selected_instance_path = find_deepest_group_or_component(ph)\r\n        when :face_edge\r\n          @selected_entity, @selected_instance_path = find_deepest_face_or_edge(ph)\r\n        end\r\n      end\r\n\r\n      def find_deepest_group_or_component(pick_helper)\r\n        path = pick_helper.path_at(0)\r\n        return nil, nil if path.nil?\r\n        entity = path.reverse.find { |e| e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance) }\r\n        return entity, build_instance_path(path) if entity\r\n        return nil, nil\r\n      end\r\n\r\n      def find_deepest_face_or_edge(pick_helper)\r\n        path = pick_helper.path_at(0)\r\n        return nil, nil if path.nil?\r\n        entity = path.reverse.find { |e| e.is_a?(Sketchup::Face) || e.is_a?(Sketchup::Edge) }\r\n        return entity, build_instance_path(path) if entity\r\n        return nil, nil\r\n      end\r\n\r\n      def toggle_selection_mode(view = nil)\r\n        @selection_mode = @selection_mode == :group_component ? :face_edge : :group_component\r\n        update_status_text\r\n        view&.invalidate\r\n      end\r\n\r\n      def onReturn(view)\r\n        refresh_selection_from_last_position(view)\r\n        enter_parent_context(view)\r\n      end\r\n\r\n      def enter_parent_context(view = nil)\r\n        return unless @selected_instance_path\r\n\r\n        target_path = target_instance_path_for_enter\r\n        return unless target_path\r\n\r\n        @model.active_path = target_path\r\n\r\n        if @post_enter_action == :paste_in_place && @clipboard_group\r\n          model = Sketchup.active_model\r\n          target_entities = model.active_entities\r\n          tr = @clipboard_group.transformation\r\n          group_def = @clipboard_group.definition\r\n\r\n          model.start_operation(SelecaoHierarquia.obter_texto(:op_colar), true)\r\n\r\n          temp_group_instance = target_entities.add_instance(group_def, tr)\r\n          exploded = temp_group_instance.explode\r\n          @clipboard_group.erase!\r\n          valid_classes = [\r\n            Sketchup::Edge,\r\n            Sketchup::Face,\r\n            Sketchup::Group,\r\n            Sketchup::ComponentInstance,\r\n            Sketchup::ConstructionLine,\r\n            Sketchup::ConstructionPoint,\r\n            Sketchup::Image\r\n          ]\r\n\r\n          safe_selection = Array(exploded).flatten.compact.select { |e|\r\n            valid_classes.include?(e.class) \r\n          }\r\n\r\n          model.selection.clear\r\n          model.selection.add(safe_selection) unless safe_selection.empty?\r\n          model.commit_operation\r\n        end\r\n\r\n        Sketchup.active_model.select_tool(nil)\r\n      end\r\n\r\n      def onCancel(reason, view)\r\n        exit_to_model_level\r\n      end\r\n\r\n      def draw(view)\r\n        return unless @last_mouse_x && @last_mouse_y\r\n\r\n        mode_text = @selection_mode == :group_component ? \r\n          SelecaoHierarquia.obter_texto(:modo_gp_comp) : \r\n          SelecaoHierarquia.obter_texto(:modo_face_edge)\r\n        \r\n        offset_x = 14\r\n        offset_y = 18\r\n\r\n        screen_point = Geom::Point3d.new(@last_mouse_x + offset_x, @last_mouse_y + offset_y, 0)\r\n\r\n        view.draw_text(\r\n          Geom::Point3d.new(screen_point.x + 1, screen_point.y + 1, 0),\r\n          mode_text,\r\n          color: Sketchup::Color.new(0, 0, 0),\r\n          size: 12\r\n        )\r\n\r\n        view.draw_text(\r\n          screen_point,\r\n          mode_text,\r\n          color: Sketchup::Color.new(230, 30, 30),\r\n          size: 12\r\n        )\r\n      end\r\n\r\n      private\r\n\r\n      def build_instance_path(path)\r\n        instance_entities = path.select { |e| e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance) }\r\n        return nil if instance_entities.empty?\r\n\r\n        active_prefix = @model.active_path ? @model.active_path.to_a : []\r\n\r\n        if !active_prefix.empty? && instance_entities.first == active_prefix.last\r\n          instance_entities = instance_entities[1..] || []\r\n        end\r\n\r\n        return nil if active_prefix.empty? && instance_entities.empty?\r\n        Sketchup::InstancePath.new(active_prefix + instance_entities)\r\n      end\r\n\r\n      def exit_to_model_level\r\n        @model.active_path = nil if @model.active_path\r\n        @model.selection.clear\r\n        @view.invalidate\r\n        Sketchup.active_model.select_tool(nil)\r\n      end\r\n\r\n      def target_instance_path_for_enter\r\n        case @selection_mode\r\n        when :group_component\r\n          entities = @selected_instance_path.to_a.select do |e|\r\n            e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance)\r\n          end\r\n          return nil if entities.size <= 1\r\n          Sketchup::InstancePath.new(entities[0...-1])\r\n        else\r\n          @selected_instance_path\r\n        end\r\n      end\r\n\r\n      def update_status_text\r\n        mode_label = @selection_mode == :group_component ? \r\n          SelecaoHierarquia.obter_texto(:status_gp_comp) : \r\n          SelecaoHierarquia.obter_texto(:status_face_ed)\r\n        \r\n        status = SelecaoHierarquia.obter_texto(:prompt_status, { mode: mode_label })\r\n        Sketchup::set_status_text(status, SB_PROMPT)\r\n      end\r\n\r\n      def highlight_entity(view)\r\n        return unless @selected_entity\r\n        view.model.selection.clear\r\n        view.model.selection.add(@selected_entity)\r\n        view.invalidate\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      if !selection.empty? && selection.all? { |e| e.is_a?(Sketchup::Edge) }\r\n        result = UI.messagebox(obter_texto(:msg_copiar), MB_YESNO)\r\n        if result == IDYES\r\n          clipboard_group = model.active_entities.add_group(selection.to_a)\r\n          clipboard_group.name = \"TEMP_CLIPBOARD_GROUP\"\r\n          model.active_entities.erase_entities(selection.to_a)\r\n\r\n          tool = HoverSelectionTool.new(ctrl_locked: true, post_enter_action: :paste_in_place, clipboard_group: clipboard_group)\r\n          model.select_tool(tool)\r\n          tool.activate\r\n          return\r\n        end\r\n      end\r\n\r\n      tool = HoverSelectionTool.new\r\n      model.select_tool(tool)\r\n      tool.activate\r\n    end\r\n  end\r\nend\r\n\r\nScriptUpComunidade::SelecaoHierarquia.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "selecao-de-sequencia-de-arestas-c57qp",
    "title": {
      "pt": "Sele√ß√£o de Sequ√™ncia de Arestas",
      "en": "Edge Sequence Selection",
      "es": "Selecci√≥n de secuencia de aristas"
    },
    "author": "F√°bio Coutinho",
    "version": "1.2",
    "description": {
      "pt": "Seleciona uma sequ√™ncia de arestas a partir da sele√ß√£o e de acordo com o √¢ngulo informado.",
      "en": "Selects a sequence of edges from the selection and according to the specified angle.",
      "es": "Selecciona una secuencia de bordes de la selecci√≥n y de acuerdo con el √°ngulo especificado."
    },
    "keywords": {
      "pt": [
        "sele√ß√£o de arestas"
      ],
      "en": [
        "edge selection"
      ],
      "es": [
        "selecci√≥n de bordes"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module SelecaoPorAngulo\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :titulo_janela   => \"Sele√ß√£o de Arestas por √Çngulo\",\r\n        :cabecalho       => \"Selecionar Arestas por √Çngulo\",\r\n        :label_slider    => \"√Çngulo M√°ximo (0¬∫ a 180¬∫)\",\r\n        :botao_atualizar => \"Atualizar Sele√ß√£o Base\",\r\n        :erro_selecao    => \"Selecione ao menos uma aresta.\",\r\n        :sucesso_base    => \"Nova sele√ß√£o base atualizada.\"\r\n      },\r\n      'en-US' => {\r\n        :titulo_janela   => \"Select Edges by Angle\",\r\n        :cabecalho       => \"Select Edges by Angle\",\r\n        :label_slider    => \"Maximum Angle (0¬∫ to 180¬∫)\",\r\n        :botao_atualizar => \"Update Base Selection\",\r\n        :erro_selecao    => \"Please select at least one edge.\",\r\n        :sucesso_base    => \"New base selection updated.\"\r\n      },\r\n      'es' => {\r\n        :titulo_janela   => \"Selecci√≥n de Aristas por √Ångulo\",\r\n        :cabecalho       => \"Seleccionar Aristas por √Ångulo\",\r\n        :label_slider    => \"√Ångulo M√°ximo (0¬∫ a 180¬∫)\",\r\n        :botao_atualizar => \"Actualizar Selecci√≥n Base\",\r\n        :erro_selecao    => \"Seleccione al menos una arista.\",\r\n        :sucesso_base    => \"Nueva selecci√≥n base actualizada.\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n      $stored_edges = selection.grep(Sketchup::Edge)\r\n\r\n      dlg = UI::HtmlDialog.new(\r\n        dialog_title: obter_texto(:titulo_janela),\r\n        scrollable: true,\r\n        resizable: true,\r\n        width: 400,\r\n        height: 300,\r\n        style: UI::HtmlDialog::STYLE_DIALOG\r\n      )\r\n\r\n      html = <<-HTML\r\n      <!DOCTYPE html>\r\n      <html>\r\n      <head>\r\n        <meta charset=\"UTF-8\">\r\n        <style>\r\n          body {\r\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\r\n            margin: 20px;\r\n          }\r\n          h2 {\r\n            font-size: 18px;\r\n            margin-bottom: 10px;\r\n            color: #323232;\r\n          }\r\n          .form-group {\r\n            margin-bottom: 15px;\r\n          }\r\n          .form-label {\r\n            margin-bottom: 5px;\r\n            font-weight: 600;\r\n          }\r\n          input[type=range] {\r\n            width: 100%;\r\n          }\r\n          .value-display {\r\n            text-align: center;\r\n            font-size: 16px;\r\n            margin-top: 10px;\r\n            font-weight: bold;\r\n          }\r\n          button {\r\n            margin-top: 20px;\r\n            width: 100%;\r\n            padding: 10px;\r\n            background-color: #0078d4;\r\n            color: white;\r\n            border: none;\r\n            border-radius: 4px;\r\n            font-weight: bold;\r\n            cursor: pointer;\r\n          }\r\n          button:hover {\r\n            background-color: #005a9e;\r\n          }\r\n        </style>\r\n      </head>\r\n      <body>\r\n        <h2>#{obter_texto(:cabecalho)}</h2>\r\n        <div class=\"form-group\">\r\n          <label class=\"form-label\" for=\"angleRange\">#{obter_texto(:label_slider)}</label>\r\n          <input type=\"range\" min=\"0\" max=\"180\" value=\"25\" id=\"angleRange\" />\r\n          <div class=\"value-display\" id=\"angleValue\">25¬∞</div>\r\n        </div>\r\n        <button onclick=\"updateBase()\">#{obter_texto(:botao_atualizar)}</button>\r\n\r\n        <script>\r\n          const slider = document.getElementById('angleRange');\r\n          const display = document.getElementById('angleValue');\r\n\r\n          slider.oninput = function() {\r\n            const value = parseInt(this.value);\r\n            display.innerText = value + '¬∞';\r\n            sketchup.update_angle(value);\r\n          };\r\n\r\n          function updateBase() {\r\n            sketchup.update_selection();\r\n          }\r\n        </script>\r\n      </body>\r\n      </html>\r\n      HTML\r\n\r\n      dlg.set_html(html)\r\n\r\n      dlg.add_action_callback(\"update_angle\") do |dialog, value|\r\n        angle = value.to_f\r\n        max_angle_rad = angle * Math::PI / 180.0\r\n        final_edges = []\r\n\r\n        if $stored_edges\r\n          $stored_edges.each { |edge|\r\n            [edge.start, edge.end].each { |start_vertex|\r\n              current_edge = edge\r\n              current_vertex = start_vertex\r\n              chain = [current_edge]\r\n\r\n              loop do\r\n                other_vertex = current_edge.other_vertex(current_vertex)\r\n                connected_edges = other_vertex.edges - [current_edge] - chain\r\n\r\n                min_angle = nil\r\n                next_edge = nil\r\n\r\n                connected_edges.each { |e|\r\n                  vec1 = current_vertex.position.vector_to(other_vertex.position)\r\n                  vec2 = e.start == other_vertex ? e.start.position.vector_to(e.end.position) : e.end.position.vector_to(e.start.position)\r\n                  ang = vec1.angle_between(vec2)\r\n\r\n                  if ang <= max_angle_rad && (min_angle.nil? || ang < min_angle)\r\n                    min_angle = ang\r\n                    next_edge = e\r\n                  end\r\n                }\r\n\r\n                break unless next_edge\r\n                chain << next_edge\r\n                current_vertex = other_vertex\r\n                current_edge = next_edge\r\n              end\r\n\r\n              final_edges.concat(chain)\r\n            }\r\n          }\r\n\r\n          model.selection.clear\r\n          model.selection.add(final_edges.uniq)\r\n        end\r\n      end\r\n\r\n      dlg.add_action_callback(\"update_selection\") do |dialog, _|\r\n        new_edges = model.selection.grep(Sketchup::Edge)\r\n        if new_edges.empty?\r\n          UI.messagebox(obter_texto(:erro_selecao))\r\n        else\r\n          $stored_edges = new_edges\r\n          UI.messagebox(obter_texto(:sucesso_base))\r\n        end\r\n      end\r\n\r\n      dlg.show\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::SelecaoPorAngulo.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "suavizar-arestas-por-angulo-c59fb",
    "title": {
      "pt": "Suavizar Arestas por √Çngulo",
      "en": "Smooth Edges by Angle",
      "es": "Bordes suaves por √°ngulo"
    },
    "author": "F√°bio Coutinho",
    "version": "1.0",
    "description": {
      "pt": "Navega por todos os grupos e componentes aninhados dentro da sele√ß√£o, aplicando suaviza√ß√£o autom√°tica nas arestas entre faces adjacentes. A suaviza√ß√£o s√≥ √© aplicada se o √¢ngulo entre as faces for menor ou igual ao valor definido pelo usu√°rio.",
      "en": "Navigates through all nested groups and components within the selection, applying automatic smoothing to the edges between adjacent faces. Smoothing is only applied if the angle between the faces is less than or equal to the value defined by the user.",
      "es": "Navega por todos los grupos y componentes anidados de la selecci√≥n, aplicando suavizado autom√°tico a los bordes entre caras adyacentes. El suavizado solo se aplica si el √°ngulo entre las caras es menor o igual al valor definido por el usuario."
    },
    "keywords": {
      "pt": [
        "suavizar",
        "arestas",
        "suaviza√ß√£o autom√°tica"
      ],
      "en": [
        "soften",
        "edges",
        "automatic smoothing"
      ],
      "es": [
        "ablandar",
        "bordes",
        "suavizado autom√°tico"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module SuavizarArestasInterativo\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao    => \"Selecione um √∫nico grupo ou componente para aplicar o suavizador.\",\r\n        :op_suavizar     => \"Suavizar Arestas\",\r\n        :titulo_janela   => \"Suavizar Arestas Interativo\",\r\n        :label_angulo    => \"√Çngulo M√°ximo para Suaviza√ß√£o\",\r\n        :btn_fechar      => \"Fechar\",\r\n        :btn_aplicar     => \"Aplicar\",\r\n        :status_concluido => \"Conclu√≠do\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao    => \"Select a single group or component to apply the smoother.\",\r\n        :op_suavizar     => \"Soften Edges\",\r\n        :titulo_janela   => \"Interactive Soften Edges\",\r\n        :label_angulo    => \"Maximum Angle for Softening\",\r\n        :btn_fechar      => \"Close\",\r\n        :btn_aplicar     => \"Apply\",\r\n        :status_concluido => \"Done\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao    => \"Seleccione un solo grupo o componente para aplicar el suavizador.\",\r\n        :op_suavizar     => \"Suavizar Aristas\",\r\n        :titulo_janela   => \"Suavizar Aristas Interactivo\",\r\n        :label_angulo    => \"√Ångulo M√°ximo para Suavizaci√≥n\",\r\n        :btn_fechar      => \"Cerrar\",\r\n        :btn_aplicar     => \"Aplicar\",\r\n        :status_concluido => \"Concluido\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.iniciar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      unless selection.length == 1 && (selection.first.is_a?(Sketchup::Group) || selection.first.is_a?(Sketchup::ComponentInstance))\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n\r\n      @entidade_raiz = selection.first\r\n      @transformacao_raiz = @entidade_raiz.transformation\r\n\r\n      mostrar_interface\r\n    end\r\n\r\n    def self.aplicar_suavizacao(angulo_graus)\r\n      model = Sketchup.active_model\r\n      view = model.active_view\r\n      model.start_operation(obter_texto(:op_suavizar), true)\r\n\r\n      @dialog.execute_script(\"atualizar_progresso(0)\")\r\n      angulo_radianos = angulo_graus.to_f.degrees\r\n\r\n      contar_total = contar_arestas(@entidade_raiz)\r\n      @processadas = 0\r\n      @total_arestas = contar_total\r\n\r\n      suavizar_entidade(@entidade_raiz, @transformacao_raiz, angulo_radianos)\r\n\r\n      @dialog.execute_script(\"atualizar_progresso(100)\")\r\n      model.commit_operation\r\n      view.invalidate\r\n    end\r\n\r\n    def self.contar_arestas(entidade)\r\n      total = 0\r\n      if entidade.is_a?(Sketchup::Group) || entidade.is_a?(Sketchup::ComponentInstance)\r\n        definicao = entidade.definition\r\n        definicao.entities.each do |e|\r\n          if e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance)\r\n            total += contar_arestas(e)\r\n          elsif e.is_a?(Sketchup::Edge) && e.faces.length == 2\r\n            total += 1\r\n          end\r\n        end\r\n      end\r\n      total\r\n    end\r\n\r\n    def self.suavizar_entidade(entidade, tr_global, angulo_maximo)\r\n      if entidade.is_a?(Sketchup::Group) || entidade.is_a?(Sketchup::ComponentInstance)\r\n        definicao = entidade.definition\r\n        tr_local = entidade.transformation\r\n        nova_tr = tr_global * tr_local\r\n\r\n        definicao.entities.each do |e|\r\n          if e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance)\r\n            suavizar_entidade(e, nova_tr, angulo_maximo)\r\n          elsif e.is_a?(Sketchup::Edge) && e.faces.length == 2\r\n            suavizar_ou_nao(e, angulo_maximo)\r\n          end\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.suavizar_ou_nao(aresta, angulo_maximo)\r\n      faces = aresta.faces\r\n      return unless faces.length == 2\r\n\r\n      normal1 = faces[0].normal\r\n      normal2 = faces[1].normal\r\n      return unless normal1 && normal2\r\n\r\n      angulo = normal1.angle_between(normal2)\r\n\r\n      if angulo <= angulo_maximo\r\n        aresta.soft = true\r\n        aresta.smooth = true\r\n      else\r\n        aresta.soft = false\r\n        aresta.smooth = false\r\n      end\r\n\r\n      @processadas += 1\r\n      if @processadas % 100 == 0 || @processadas == @total_arestas\r\n        progresso = ((@processadas.to_f / @total_arestas) * 100).round\r\n        @dialog.execute_script(\"atualizar_progresso(#{progresso})\")\r\n      end\r\n    end\r\n\r\n    def self.mostrar_interface\r\n      @dialog = UI::HtmlDialog.new({\r\n        dialog_title: obter_texto(:titulo_janela),\r\n        width: 500,\r\n        height: 260,\r\n        style: UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n\r\n      html = <<-HTML\r\n        <!DOCTYPE html>\r\n        <html>\r\n        <head>\r\n          <meta charset=\"UTF-8\">\r\n          <style>\r\n            body { font-family: \"Segoe UI\", Tahoma, sans-serif; padding: 20px; margin: 0; background-color: #f9f9f9; color: #333; }\r\n            h5 { margin-bottom: 16px; font-size: 16px; font-weight: 600; }\r\n            .slider-container { position: relative; width: 100%; padding-top: 24px; }\r\n            input[type=\"range\"] { width: 100%; margin: 0; }\r\n            .tooltip { position: absolute; top: 0; transform: translateX(-50%); background: #0053a0; color: white; padding: 4px 10px; border-radius: 6px; font-size: 13px; white-space: nowrap; }\r\n            .progresso-indicador { margin-top: 24px; text-align: center; font-size: 14px; font-weight: bold; color: #0053a0; }\r\n            .button-container { text-align: center; margin-top: 24px; }\r\n            button { min-width: 140px; padding: 8px 20px; font-weight: 600; font-size: 14px; border: none; border-radius: 6px; cursor: pointer; color: white; }\r\n            .btn-primary { background-color: #0053a0; }\r\n            .btn-success { background-color: #2e8540; }\r\n            .btn-primary:hover { background-color: #003d7a; }\r\n            .btn-success:hover { background-color: #256e34; }\r\n          </style>\r\n        </head>\r\n        <body>\r\n          <h5>#{obter_texto(:label_angulo)}</h5>\r\n          <div class=\"slider-container\">\r\n            <div id=\"tooltip\" class=\"tooltip\">85¬∞</div>\r\n            <input id=\"slider\" type=\"range\" min=\"0\" max=\"180\" step=\"1\" value=\"85\" oninput=\"onSliderChange(this.value)\">\r\n          </div>\r\n          <div id=\"progresso_texto\" class=\"progresso-indicador\">0%</div>\r\n          <div class=\"button-container\">\r\n            <button id=\"actionButton\" class=\"btn-primary\" onclick=\"botaoAcao()\">#{obter_texto(:btn_fechar)}</button>\r\n          </div>\r\n          <script>\r\n            const slider = document.getElementById(\"slider\");\r\n            const tooltip = document.getElementById(\"tooltip\");\r\n            const button = document.getElementById(\"actionButton\");\r\n            const txt_fechar = \"#{obter_texto(:btn_fechar)}\";\r\n            const txt_aplicar = \"#{obter_texto(:btn_aplicar)}\";\r\n            const txt_concluido = \"#{obter_texto(:status_concluido)}\";\r\n            let valorAplicado = \"85\";\r\n\r\n            function onSliderChange(valor) {\r\n              tooltip.innerText = valor + \"¬∞\";\r\n              atualizarTooltip();\r\n              if (valor !== valorAplicado) {\r\n                button.innerText = txt_aplicar;\r\n                button.className = \"btn-success\";\r\n              } else {\r\n                button.innerText = txt_fechar;\r\n                button.className = \"btn-primary\";\r\n              }\r\n            }\r\n\r\n            function botaoAcao() {\r\n              const valorAtual = slider.value;\r\n              if (button.innerText === txt_aplicar) {\r\n                atualizar_progresso(0);\r\n                sketchup.aplicar_angulo(valorAtual);\r\n                valorAplicado = valorAtual;\r\n                button.innerText = txt_fechar;\r\n                button.className = \"btn-primary\";\r\n              } else {\r\n                sketchup.fechar_janela();\r\n              }\r\n            }\r\n\r\n            function atualizarTooltip() {\r\n              const percent = (slider.value - slider.min) / (slider.max - slider.min);\r\n              const rangeWidth = slider.offsetWidth;\r\n              const pos = percent * (rangeWidth - 16) + 8;\r\n              tooltip.style.left = pos + \"px\";\r\n            }\r\n\r\n            function atualizar_progresso(valor) {\r\n              const texto = document.getElementById(\"progresso_texto\");\r\n              texto.innerText = valor >= 100 ? txt_concluido : valor + \"%\";\r\n            }\r\n\r\n            window.onload = () => {\r\n              atualizarTooltip();\r\n              setTimeout(() => {\r\n                sketchup.aplicar_angulo(slider.value);\r\n              }, 150);\r\n            };\r\n\r\n            slider.addEventListener(\"input\", atualizarTooltip);\r\n          </script>\r\n        </body>\r\n        </html>\r\n      HTML\r\n\r\n      @dialog.set_html(html)\r\n\r\n      @dialog.add_action_callback(\"aplicar_angulo\") do |_, angulo|\r\n        aplicar_suavizacao(angulo.to_f)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"fechar_janela\") do |_|\r\n        @dialog.close\r\n      end\r\n\r\n      @dialog.show\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::SuavizarArestasInterativo.iniciar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "substituir-textura-c5as4",
    "title": {
      "pt": "Substituir Textura",
      "en": "Replace Texture",
      "es": "Reemplazar textura"
    },
    "author": "Henrique Barsa",
    "version": "1.0",
    "description": {
      "pt": "Substitua uma textura de todo o projeto, por outra.",
      "en": "Replace one texture throughout the project with another.",
      "es": "Reemplace una textura por otra en todo el proyecto."
    },
    "keywords": {
      "pt": [
        "textura",
        "material",
        "substituir"
      ],
      "en": [
        "texture",
        "material",
        "to replace"
      ],
      "es": [
        "textura",
        "material",
        "reemplazar"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module SubstituirMateriais\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :status_inicial    => \"Selecione o material a ser substitu√≠do.\",\r\n        :status_proximo    => \"Selecione outro material para substituir %{material}.\",\r\n        :status_aguarde    => \"Substituindo materiais. Aguarde, por favor...\",\r\n        :op_nome           => \"Substituir Materiais\",\r\n        :default_mat       => \"Padr√£o\",\r\n        :msg_substituir    => \"Substituir %{material} ...\",\r\n        :msg_por           => \"Substituir %{antigo}\\npor %{novo}\"\r\n      },\r\n      'en-US' => {\r\n        :status_inicial    => \"Select the material to be replaced.\",\r\n        :status_proximo    => \"Select another material to replace %{material}.\",\r\n        :status_aguarde    => \"Replacing materials. Please wait...\",\r\n        :op_nome           => \"Replace Materials\",\r\n        :default_mat       => \"Default\",\r\n        :msg_substituir    => \"Replace %{material} ...\",\r\n        :msg_por           => \"Replace %{antigo}\\nwith %{novo}\"\r\n      },\r\n      'es' => {\r\n        :status_inicial    => \"Seleccione el material que desea reemplazar.\",\r\n        :status_proximo    => \"Seleccione otro material para reemplazar %{material}.\",\r\n        :status_aguarde    => \"Reemplazando materiales. Por favor espere...\",\r\n        :op_nome           => \"Reemplazar Materiales\",\r\n        :default_mat       => \"Predeterminado\",\r\n        :msg_substituir    => \"Reemplazar %{material} ...\",\r\n        :msg_por           => \"Reemplazar %{antigo}\\npor %{novo}\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave, variaveis = {})\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      texto  = IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n      \r\n      variaveis.each { |k, v| texto = texto.gsub(\"%{#{k}}\", v.to_s) }\r\n      texto\r\n    end\r\n\r\n    class MatReplacer\r\n      def initialize\r\n        @picked = nil\r\n        @m_org = nil\r\n        @state = 0\r\n      end\r\n\r\n      def activate\r\n        @picked = nil\r\n        @m_org = nil\r\n        @state = 0\r\n        @pos = [0, 0, 0]\r\n        @drawn = false\r\n        update_ui\r\n        @debug = nil\r\n      end\r\n\r\n      def update_ui\r\n        Sketchup.set_status_text(SubstituirMateriais.obter_texto(:status_inicial))\r\n      end\r\n\r\n      def resume(view)\r\n        update_ui\r\n      end\r\n\r\n      def deactivate(view)\r\n        view.invalidate if @drawn\r\n      end\r\n\r\n      def onMouseMove(flags, x, y, view)\r\n        ph = view.pick_helper\r\n        ph.do_pick(x, y)\r\n\r\n        picked = if ph.picked_face\r\n                   ph.picked_face\r\n                 elsif ph.picked_edge\r\n                   ph.picked_edge\r\n                 else\r\n                   ph.best_picked\r\n                 end\r\n\r\n        index = 0\r\n        for i in 1..ph.count\r\n          if ph.element_at(i) == picked\r\n            index = i\r\n            break\r\n          end\r\n        end\r\n\r\n        path = ph.path_at(index)\r\n        t = ph.transformation_at(index)\r\n\r\n        if path.nil?\r\n          @picked = nil\r\n        else\r\n          @picked = nil\r\n          n = (picked.is_a?(Sketchup::Face)) ? picked.normal.transform(t).normalize : nil\r\n          path.each do |e|\r\n            next unless e.respond_to?(:material)\r\n            if e.is_a?(Sketchup::Face)\r\n              c = Sketchup.active_model.active_view.camera.direction\r\n              m = (c % n > 0) ? e.back_material : e.material\r\n              next if m.nil?\r\n              @picked = m\r\n            else\r\n              next if e.material.nil?\r\n              @picked = e.material\r\n            end\r\n          end\r\n        end\r\n\r\n        @pos = [x, y, 0]\r\n        view.invalidate\r\n      end\r\n\r\n      def onLButtonUp(flags, x, y, view)\r\n        if @state == 0\r\n          @m_org = @picked\r\n          @state = 1\r\n          o_name = (@m_org.nil?) ? SubstituirMateriais.obter_texto(:default_mat) : @m_org.display_name\r\n          Sketchup.set_status_text(SubstituirMateriais.obter_texto(:status_proximo, { material: o_name }))\r\n        else\r\n          return if @picked == @m_org\r\n\r\n          model = Sketchup.active_model\r\n          model.start_operation(SubstituirMateriais.obter_texto(:op_nome), true)\r\n          Sketchup.set_status_text(SubstituirMateriais.obter_texto(:status_aguarde))\r\n\r\n          model.entities.each do |e|\r\n            if e.respond_to?(:material)\r\n              e.material = @picked if e.material == @m_org\r\n            end\r\n            if e.respond_to?(:back_material)\r\n              e.back_material = @picked if e.back_material == @m_org\r\n            end\r\n          end\r\n\r\n          model.definitions.each do |d|\r\n            next if d.image?\r\n            d.entities.each do |e|\r\n              if e.respond_to?(:material)\r\n                e.material = @picked if e.material == @m_org\r\n              end\r\n              if e.respond_to?(:back_material)\r\n                e.back_material = @picked if e.back_material == @m_org\r\n              end\r\n            end\r\n          end\r\n\r\n          model.commit_operation\r\n          activate\r\n        end\r\n      end\r\n\r\n      def draw(view)\r\n        pos = @pos.dup\r\n        pos[0] += 30\r\n        pos[1] -= 30\r\n\r\n        if @state == 0\r\n          p_name = (@picked.nil?) ? SubstituirMateriais.obter_texto(:default_mat) : @picked.display_name\r\n          str = SubstituirMateriais.obter_texto(:msg_substituir, { material: p_name })\r\n        else\r\n          o_name = (@m_org.nil?) ? SubstituirMateriais.obter_texto(:default_mat) : @m_org.display_name\r\n          p_name = (@picked.nil?) ? SubstituirMateriais.obter_texto(:default_mat) : @picked.display_name\r\n          str = SubstituirMateriais.obter_texto(:msg_por, { antigo: o_name, novo: p_name })\r\n        end\r\n\r\n        text_options = {\r\n          font: \"Arial\",\r\n          size: 14,\r\n          bold: true,\r\n          color: \"black\"\r\n        }\r\n\r\n        view.draw_text(pos, str, text_options)\r\n        @drawn = true\r\n      end\r\n\r\n      def onSetCursor\r\n        if @state == 0\r\n          UI.set_cursor(648)\r\n        else\r\n          UI.set_cursor(651)\r\n        end\r\n        true\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      tool = MatReplacer.new\r\n      Sketchup.active_model.tools.push_tool(tool)\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::SubstituirMateriais.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "teletransportador-de-geometria-c5cnl",
    "title": {
      "pt": "Teletransportador de Geometria",
      "en": "Geometry Teleporter",
      "es": "Teletransportador de geometr√≠a"
    },
    "author": "F√°bio Coutinho",
    "version": "1.2",
    "description": {
      "pt": "Ferramenta interativa que permite transportar grupos ou componentes do n√≠vel do modelo para dentro de outro grupo ou componente em qualquer profundidade. Possui dois modos de opera√ß√£o: transporte simples ou substitui√ß√£o do conte√∫do de destino, com preserva√ß√£o de materiais e suporte visual din√¢mico.",
      "en": "An interactive tool that allows you to transport groups or components from one model level into another group or component at any depth. It has two operating modes: simple transport or replacement of the target content, with material preservation and dynamic visual support.",
      "es": "Una herramienta interactiva que permite transportar grupos o componentes de un nivel de modelo a otro grupo o componente a cualquier profundidad. Ofrece dos modos de funcionamiento: transporte simple o reemplazo del contenido de destino, con preservaci√≥n de material y soporte visual din√°mico."
    },
    "keywords": {
      "pt": [
        "teletransporte",
        "substituir grupo",
        "mover componente"
      ],
      "en": [
        "teleportation",
        "replace group",
        "move component"
      ],
      "es": [
        "teletransportaci√≥n",
        "reemplazar grupo",
        "mover componente"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module TeletransportadorDeGeometria\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :modo_transp    => \"Transportar\",\r\n        :modo_subst     => \"Substituir\",\r\n        :local_interno  => \"Interno\",\r\n        :local_externo  => \"Externo\",\r\n        :status_origem  => \"Modo (Ctrl): %{acao} | Localiza√ß√£o (Shift): %{local} | Clique no item que ser√° transportado.\",\r\n        :status_destino => \"Modo (Ctrl): %{acao} | Localiza√ß√£o (Shift): %{local} | Clique no local de destino.\",\r\n        :op_nome        => \"Teletransporte\",\r\n        :erro_colar     => \"Erro ao colar inst√¢ncia no destino!\"\r\n      },\r\n      'en-US' => {\r\n        :modo_transp    => \"Transport\",\r\n        :modo_subst     => \"Replace\",\r\n        :local_interno  => \"Internal\",\r\n        :local_externo  => \"External\",\r\n        :status_origem  => \"Mode (Ctrl): %{acao} | Location (Shift): %{local} | Click on the item to be transported.\",\r\n        :status_destino => \"Mode (Ctrl): %{acao} | Location (Shift): %{local} | Click on the destination location.\",\r\n        :op_nome        => \"Teleport\",\r\n        :erro_colar     => \"Error pasting instance at destination!\"\r\n      },\r\n      'es' => {\r\n        :modo_transp    => \"Transportar\",\r\n        :modo_subst     => \"Sustituir\",\r\n        :local_interno  => \"Interno\",\r\n        :local_externo  => \"Externo\",\r\n        :status_origem  => \"Modo (Ctrl): %{acao} | Ubicaci√≥n (Shift): %{local} | Haga clic en el elemento a transportar.\",\r\n        :status_destino => \"Modo (Ctrl): %{acao} | Ubicaci√≥n (Shift): %{local} | Haga clic en la ubicaci√≥n de destino.\",\r\n        :op_nome        => \"Teletransporte\",\r\n        :erro_colar     => \"¬°Error al pegar la instancia en el destino!\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave, variaveis = {})\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      texto  = IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n      \r\n      variaveis.each { |k, v| texto = texto.gsub(\"%{#{k}}\", v.to_s) }\r\n      texto\r\n    end\r\n\r\n    class Tool\r\n      VK_CONTROL ||= 17\r\n      VK_SHIFT ||= 16\r\n\r\n      def initialize\r\n        @step = :select_source\r\n        @mode = :transportar\r\n        @localizacao = :externo\r\n        @source = nil\r\n      end\r\n\r\n      def activate\r\n        Sketchup.status_text = status_message\r\n        Sketchup.active_model.selection.clear\r\n      end\r\n\r\n      def status_message\r\n        acao = @mode == :transportar ? \r\n          TeletransportadorDeGeometria.obter_texto(:modo_transp) : \r\n          TeletransportadorDeGeometria.obter_texto(:modo_subst)\r\n        \r\n        local = @localizacao == :interno ? \r\n          TeletransportadorDeGeometria.obter_texto(:local_interno) : \r\n          TeletransportadorDeGeometria.obter_texto(:local_externo)\r\n        \r\n        case @step\r\n        when :select_source\r\n          TeletransportadorDeGeometria.obter_texto(:status_origem, { acao: acao, local: local })\r\n        when :select_target\r\n          TeletransportadorDeGeometria.obter_texto(:status_destino, { acao: acao, local: local })\r\n        end\r\n      end\r\n\r\n      def onKeyDown(key, repeat, flags, view)\r\n        case key\r\n        when VK_CONTROL\r\n          @mode = (@mode == :transportar ? :substituir : :transportar)\r\n        when VK_SHIFT\r\n          @localizacao = (@localizacao == :interno ? :externo : :interno)\r\n        end\r\n        Sketchup.status_text = status_message\r\n      end\r\n\r\n      def onMouseMove(flags, x, y, view)\r\n        model = Sketchup.active_model\r\n        ph = view.pick_helper\r\n        ph.do_pick(x, y)\r\n        path = ph.path_at(0)\r\n        return model.selection.clear unless path\r\n      \r\n        entity = path.to_a.first\r\n      \r\n        if @step == :select_source\r\n          if entity.is_a?(Sketchup::Group) || entity.is_a?(Sketchup::ComponentInstance)\r\n            model.selection.clear\r\n            model.selection.add(entity)\r\n          else\r\n            model.selection.clear\r\n          end\r\n        else\r\n          entity = path.to_a.reverse.find { |e| e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance) }\r\n          if entity\r\n            model.selection.clear\r\n            model.selection.add(entity)\r\n          else\r\n            model.selection.clear\r\n          end\r\n        end\r\n\r\n        Sketchup.status_text = status_message\r\n      end\r\n\r\n      def onLButtonDown(flags, x, y, view)\r\n        model = Sketchup.active_model\r\n        ph = view.pick_helper\r\n        ph.do_pick(x, y)\r\n        path = ph.path_at(0)\r\n        return unless path\r\n\r\n        path_array = path.to_a\r\n\r\n        if @step == :select_source\r\n          entity = path_array.first\r\n          return unless entity.is_a?(Sketchup::Group) || entity.is_a?(Sketchup::ComponentInstance)\r\n        else\r\n          entity = path_array.reverse.find { |e| e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance) }\r\n          return unless entity\r\n        end\r\n\r\n        entity.make_unique if entity.respond_to?(:make_unique)\r\n\r\n        instance_path = Sketchup::InstancePath.new(path_array[0..path_array.index(entity)])\r\n        global_tr = instance_path.transformation\r\n\r\n        if @step == :select_source\r\n          @source = {\r\n            entity: entity,\r\n            definition: entity.definition,\r\n            global_tr: global_tr\r\n          }\r\n          @step = :select_target\r\n          Sketchup.status_text = status_message\r\n        else\r\n          perform_transfer(@source, entity, global_tr, instance_path)\r\n          reset\r\n        end\r\n      end\r\n\r\n      def perform_transfer(source_data, destination, destination_tr, destination_path)\r\n        model = Sketchup.active_model\r\n        model.start_operation(TeletransportadorDeGeometria.obter_texto(:op_nome), true)\r\n      \r\n        source_entity = source_data[:entity]\r\n        source_definition = source_data[:definition]\r\n        source_tr = source_data[:global_tr]\r\n      \r\n        if @localizacao == :interno\r\n          dest_entities = destination.definition.entities\r\n          inverse_dest_tr = destination_tr.inverse\r\n          relative_tr = inverse_dest_tr * source_tr\r\n        else\r\n          dest_entities = destination.parent.entities\r\n      \r\n          if destination_path\r\n            parent_path = Sketchup::InstancePath.new(destination_path.to_a[0...-1])\r\n            inverse_parent_path_tr = parent_path.transformation.inverse\r\n            relative_tr = inverse_parent_path_tr * source_tr\r\n          else\r\n            relative_tr = source_tr\r\n          end\r\n        end\r\n      \r\n        new_instance = dest_entities.add_instance(source_definition, relative_tr)\r\n        new_instance.material = source_entity.material if source_entity.material\r\n      \r\n        unless new_instance && new_instance.valid?\r\n          UI.messagebox(TeletransportadorDeGeometria.obter_texto(:erro_colar))\r\n          model.abort_operation\r\n          return\r\n        end\r\n      \r\n        if @mode == :substituir\r\n          if @localizacao == :interno\r\n            keep_id = new_instance.entityID\r\n            to_erase = dest_entities.select { |e| e.entityID != keep_id }\r\n            dest_entities.erase_entities(to_erase)\r\n          else\r\n            destination.erase!\r\n          end\r\n        end\r\n      \r\n        source_entity.erase!\r\n      \r\n        model.commit_operation\r\n      end      \r\n\r\n      def reset\r\n        @step = :select_source\r\n        @source = nil\r\n        Sketchup.status_text = status_message\r\n        Sketchup.active_model.selection.clear\r\n      end\r\n\r\n      def deactivate(view)\r\n        Sketchup.status_text = \"\"\r\n        Sketchup.active_model.selection.clear\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      Sketchup.active_model.select_tool(Tool.new)\r\n    end\r\n  end\r\nend\r\n\r\nScriptUpComunidade::TeletransportadorDeGeometria.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "tornar-componentes-unicos-recursivamente-c5enw",
    "title": {
      "pt": "Tornar Componentes √önicos - Recursivamente",
      "en": "Make Components Unique - Recursively",
      "es": "Hacer que los componentes sean √∫nicos - Recursivamente"
    },
    "author": "√örsula M√ºller",
    "version": "1.0",
    "description": {
      "pt": "Torna um componente √∫nico, bem como todos os componentes aninhados dentro dele.",
      "en": "It makes a component unique, as well as all the components nested within it.",
      "es": "Hace que un componente sea √∫nico, as√≠ como todos los componentes anidados en √©l."
    },
    "keywords": {
      "pt": [
        "tornar √∫nico"
      ],
      "en": [
        "to make unique"
      ],
      "es": [
        "para hacer √∫nico"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module TornarUnicoRecursivo\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao => \"Selecione um componente.\",\r\n        :op_nome      => \"Tornar Componentes √önicos Recursivamente\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao => \"Please select a component.\",\r\n        :op_nome      => \"Make Components Unique Recursively\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao => \"Seleccione un componente.\",\r\n        :op_nome      => \"Hacer componentes √∫nicos recursivamente\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.tornar_unico_recursivamente(entidade)\r\n      return unless entidade.is_a?(Sketchup::ComponentInstance)\r\n\r\n      # Torna o componente atual √∫nico, se necess√°rio\r\n      entidade.make_unique unless entidade.definition.instances.size <= 1\r\n\r\n      # Acessa a defini√ß√£o atualizada ap√≥s make_unique\r\n      definicao = entidade.definition\r\n\r\n      # Itera sobre as entidades dentro da defini√ß√£o\r\n      definicao.entities.each do |ent|\r\n        # Se for um componente, chama a fun√ß√£o recursivamente\r\n        tornar_unico_recursivamente(ent) if ent.is_a?(Sketchup::ComponentInstance)\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      if selection.empty?\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n      else\r\n        model.start_operation(obter_texto(:op_nome), true)\r\n\r\n        selection.each do |entidade|\r\n          tornar_unico_recursivamente(entidade)\r\n        end\r\n\r\n        model.commit_operation\r\n      end\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::TornarUnicoRecursivo.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "unir-faces-coplanares-xucxs",
    "title": {
      "pt": "Unir Faces Coplanares",
      "en": "Joining Coplanar Faces",
      "es": "Unir caras coplanares"
    },
    "author": "F√°bio Coutinho",
    "version": "1.4",
    "description": {
      "pt": "Promove a uni√£o de faces coplanares dos elementos selecionados, fazendo a limpeza de faces internas e soltas.",
      "en": "It promotes the joining of coplanar faces of the selected elements, cleaning up internal and loose faces.",
      "es": "Favorece la uni√≥n de caras coplanares de los elementos seleccionados, limpiando caras internas y sueltas."
    },
    "keywords": {
      "pt": [
        "limpeza de faces coplanares"
      ],
      "en": [
        "cleaning of coplanar surfaces"
      ],
      "es": [
        "limpieza de superficies coplanares"
      ]
    },
    "code": {
      "pt": "if defined?(MySolidFix)\r\n  MySolidFix.constants.each do |const|\r\n    MySolidFix.send(:remove_const, const) rescue nil\r\n  end\r\n  Object.send(:remove_const, :MySolidFix) rescue nil\r\nend\r\n\r\nmodule ScriptUpComunidade\r\n  module UnirFacesCoplanares\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :selecao_vazia     => \"Selecione um grupo, componente ou geometria.\",\r\n        :nome_operacao     => \"Limpar Faces Internas + Unir Coplanares\",\r\n        :status_faces      => \"Inspecionando faces...\",\r\n        :status_arestas    => \"Inspecionando arestas...\",\r\n        :status_manifold   => \"Resolvendo manifold...\",\r\n        :status_analisando => \"Analisando arestas...\",\r\n        :status_bordas     => \"Ordenando bordas de superficie...\",\r\n        :status_buracos    => \"Ordenando buracos de face...\",\r\n        :faces_removidas   => \"%d faces internas removidas com precisao.\",\r\n        :arestas_removidas => \"%d arestas removidas entre faces coplanares.\"\r\n      },\r\n      'en-US' => {\r\n        :selecao_vazia     => \"Please select a group, component, or geometry.\",\r\n        :nome_operacao     => \"Clean Internal Faces + Merge Coplanar\",\r\n        :status_faces      => \"Inspecting faces...\",\r\n        :status_arestas    => \"Inspecting edges...\",\r\n        :status_manifold   => \"Resolving manifold...\",\r\n        :status_analisando => \"Analyzing edges...\",\r\n        :status_bordas     => \"Sorting surface borders...\",\r\n        :status_buracos    => \"Sorting face holes...\",\r\n        :faces_removidas   => \"%d internal faces removed with precision.\",\r\n        :arestas_removidas => \"%d edges removed between coplanar faces.\"\r\n      },\r\n      'es' => {\r\n        :selecao_vazia     => \"Por favor seleccione un grupo, componente o geometria.\",\r\n        :nome_operacao     => \"Limpiar Caras Internas + Unir Coplanares\",\r\n        :status_faces      => \"Inspeccionando caras...\",\r\n        :status_arestas    => \"Inspeccionando aristas...\",\r\n        :status_manifold   => \"Resolviendo manifold...\",\r\n        :status_analisando => \"Analizando aristas...\",\r\n        :status_bordas     => \"Ordenando bordes de superficie...\",\r\n        :status_buracos    => \"Ordenando agujeros de cara...\",\r\n        :faces_removidas   => \"%d caras internas eliminadas con precision.\",\r\n        :arestas_removidas => \"%d aristas eliminadas entre caras coplanares.\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.executar\r\n      model     = Sketchup.active_model\r\n      selection = model.selection\r\n\r\n      if selection.empty?\r\n        UI.messagebox(obter_texto(:selecao_vazia))\r\n        return\r\n      end\r\n\r\n      tolerance       = 1e-6\r\n      angle_tolerance = 1e-3\r\n\r\n      model.start_operation(obter_texto(:nome_operacao), true)\r\n\r\n      total_removed = 0\r\n      total_edges   = 0\r\n\r\n      selection.each do |ent|\r\n        ents = case ent\r\n               when Sketchup::Group             then ent.entities\r\n               when Sketchup::ComponentInstance then ent.definition.entities\r\n               when Sketchup::Face, Sketchup::Edge then ent.parent.entities\r\n               else next\r\n               end\r\n\r\n        errors = MySolidFix::ErrorFinder.find_errors(ents)\r\n\r\n        internal_faces = errors.select { |e| e.is_a?(MySolidFix::SolidErrors::InternalFace) }\r\n        internal_faces.each do |err|\r\n          face = err.entities[0]\r\n          if face.valid?\r\n            face.erase!\r\n            total_removed += 1\r\n          end\r\n        end\r\n\r\n        ents.grep(Sketchup::Edge).each do |edge|\r\n          next unless edge.valid? && edge.faces.size == 2\r\n          f1, f2 = edge.faces\r\n          begin\r\n            angle    = f1.normal.angle_between(f2.normal)\r\n            coplanar = angle < angle_tolerance &&\r\n               f2.vertices.all? { |v|\r\n                 p = v.position\r\n                 a, b, c, d = f1.plane\r\n                 (a * p.x + b * p.y + c * p.z + d).abs < tolerance\r\n               }\r\n            if coplanar\r\n              edge.erase!\r\n              total_edges += 1\r\n            end\r\n          rescue\r\n            next\r\n          end\r\n        end\r\n      end\r\n\r\n      model.commit_operation\r\n      # puts obter_texto(:faces_removidas)   % total_removed\r\n      # puts obter_texto(:arestas_removidas) % total_edges\r\n    end\r\n\r\n  end\r\nend\r\n\r\nmodule MySolidFix\r\n  module Geometry\r\n\r\n    def self.arc(center, xaxis, normal, radius, start_angle, end_angle, num_segments = 12)\r\n      tr = Geom::Transformation.rotation(center, normal, start_angle)\r\n      points = []\r\n      points << center.offset(xaxis, radius).transform(tr)\r\n      angle = (end_angle - start_angle) / num_segments\r\n      tr = Geom::Transformation.rotation(center, normal, angle)\r\n      1.upto(num_segments) { |i|\r\n        points << points.last.transform(tr)\r\n      }\r\n      return points\r\n    end\r\n\r\n    def self.arc2d(center, xaxis, radius, start_angle, end_angle, num_segments = 24)\r\n      full_angle    = end_angle - start_angle\r\n      segment_angle = full_angle / num_segments\r\n      t   = Geom::Transformation.axes(center, xaxis, xaxis * Z_AXIS, Z_AXIS)\r\n      arc = []\r\n      (0..num_segments).each { |i|\r\n        angle = start_angle + (segment_angle * i)\r\n        x = radius * Math.cos(angle)\r\n        y = radius * Math.sin(angle)\r\n        arc << Geom::Point3d.new(x, y, 0).transform!(t)\r\n      }\r\n      arc\r\n    end\r\n\r\n    def self.circle(center, normal, radius, num_segments)\r\n      pi2   = Math::PI * 2\r\n      xaxis = normal.axes.x\r\n      points = self.arc(center, xaxis, normal, radius, 0.0, pi2, num_segments)\r\n      points.pop\r\n      return points\r\n    end\r\n\r\n    def self.circle2d(center, xaxis, radius, num_segments = 24)\r\n      num_segments = num_segments.to_i\r\n      angle = 360.degrees - (360.degrees / num_segments)\r\n      self.arc2d(center, xaxis, radius, 0, angle, num_segments - 1)\r\n    end\r\n\r\n    def self.arc_segments(angle, full_circle_segments, force_even = false)\r\n      segments = (full_circle_segments * (angle.abs / (Math::PI * 2))).to_i\r\n      segments += 1 if force_even && segments % 2 > 0\r\n      segments = 1 if segments < 1\r\n      return segments\r\n    end\r\n\r\n    def self.mid_point(edge)\r\n      pt1, pt2 = edge.vertices.map { |vertex| vertex.position }\r\n      Geom.linear_combination(0.5, pt1, 0.5, pt2)\r\n    end\r\n\r\n  end\r\nend\r\n\r\nmodule MySolidFix\r\n\r\n  class HeisenBug < RuntimeError; end\r\n\r\n  class Shell\r\n\r\n    PI2 = Math::PI * 2\r\n\r\n    attr_reader :internal_faces, :external_faces, :reversed_faces\r\n\r\n    def initialize(entities)\r\n      @entities      = entities\r\n      @shell_faces   = nil\r\n      @internal_faces  = nil\r\n      @external_faces  = nil\r\n      @reversed_faces  = nil\r\n    end\r\n\r\n    def resolve\r\n      @shell_faces    = Set.new\r\n      @internal_faces = Set.new\r\n      @external_faces = Set.new\r\n      @reversed_faces = Set.new\r\n\r\n      shell_front = Set.new\r\n      find_geometry_groups(@entities) { |geometry_group|\r\n        start_face = find_start_face(geometry_group, true)\r\n        next if start_face.nil?\r\n        shell_front.merge(find_shell(start_face))\r\n      }\r\n      faces           = @entities.grep(Sketchup::Face)\r\n      @internal_faces = Set.new(faces).subtract(shell_front)\r\n\r\n      temp_reversed_faces = @reversed_faces.dup\r\n\r\n      shell_back = Set.new\r\n      find_geometry_groups(@entities) { |geometry_group|\r\n        start_face = find_start_face(geometry_group, false)\r\n        next if start_face.nil?\r\n        shell_back.merge(find_shell(start_face))\r\n      }\r\n\r\n      @shell_faces    = shell_front.intersection(shell_back)\r\n      @external_faces = Set.new(faces).subtract(@internal_faces)\r\n                                      .subtract(@shell_faces)\r\n      @reversed_faces = @shell_faces.intersection(temp_reversed_faces)\r\n      nil\r\n    end\r\n\r\n    def valid?\r\n      if @shell_faces.nil?\r\n        raise RuntimeError, \"`resolve` must be called before calling `valid?`\"\r\n      end\r\n      @shell_faces.size > 0 && @shell_faces.all? { |face|\r\n        face.edges.all? { |edge|\r\n          faces = edge.faces.select { |f| @shell_faces.include?(f) }\r\n          faces.size > 1\r\n        }\r\n      }\r\n    end\r\n\r\n    private\r\n\r\n    def find_geometry_groups(entities)\r\n      num_groups = 0\r\n      stack = entities.to_a\r\n      until stack.empty?\r\n        entity = stack.pop\r\n        next unless entity.respond_to?(:all_connected)\r\n        num_groups += 1\r\n        geometry_group = entity.all_connected\r\n        yield(geometry_group)\r\n        stack = stack - geometry_group\r\n      end\r\n      num_groups\r\n    end\r\n\r\n    def get_faces(entity)\r\n      entity.faces.reject { |face| @internal_faces.include?(face) }\r\n    end\r\n\r\n    def face_normal(face)\r\n      normal = face.normal\r\n      if @reversed_faces.include?(face)\r\n        normal.reverse!\r\n      end\r\n      normal\r\n    end\r\n\r\n    def edge_reversed_in?(edge, face)\r\n      reversed = edge.reversed_in?(face)\r\n      if @reversed_faces.include?(face)\r\n        reversed = !reversed\r\n      end\r\n      reversed\r\n    end\r\n\r\n    def reverse_face(face)\r\n      if @reversed_faces.include?(face)\r\n        @reversed_faces.delete(face)\r\n      else\r\n        @reversed_faces << face\r\n      end\r\n      face\r\n    end\r\n\r\n    def find_start_face(entities, outside)\r\n      vertices = Set.new\r\n      entities.grep(Sketchup::Edge) { |edge|\r\n        vertices.merge(edge.vertices)\r\n      }\r\n      vertices.delete_if { |vertex| get_faces(vertex).empty? }\r\n      return nil if vertices.empty?\r\n\r\n      max_z_vertex = vertices.max { |a, b|\r\n        a.position.z <=> b.position.z\r\n      }\r\n\r\n      edges = max_z_vertex.edges.delete_if { |edge| get_faces(edge).empty? }\r\n      edge  = edges.min { |a, b|\r\n        val_a = edge_normal_z_component(a)\r\n        val_b = edge_normal_z_component(b)\r\n        result = val_a <=> val_b\r\n        if result.nil?\r\n          klass_a = val_a.class.name\r\n          klass_b = val_b.class.name\r\n          raise HeisenBug, \"A: #{a.line.inspect} (#{val_a.inspect}) #{klass_a} - B: #{b.line.inspect} (#{val_b.inspect}) #{klass_b}\"\r\n        end\r\n        result\r\n      }\r\n\r\n      face = get_faces(edge).max { |a, b|\r\n        face_normal(a).z.abs <=> face_normal(b).z.abs\r\n      }\r\n\r\n      if outside\r\n        reverse_face(face) if face_normal(face).z < 0\r\n      else\r\n        reverse_face(face) if face_normal(face).z > 0\r\n      end\r\n\r\n      face\r\n    end\r\n\r\n    def edge_normal_z_component(edge)\r\n      edge.line[1].z.abs\r\n    end\r\n\r\n    def edge_vector(edge, face)\r\n      if edge_reversed_in?(edge, face)\r\n        edge.end.position.vector_to(edge.start)\r\n      else\r\n        edge.start.position.vector_to(edge.end)\r\n      end\r\n    end\r\n\r\n    def get_other_face(edge, face)\r\n      other_face = get_faces(edge).find { |edge_face| edge_face != face }\r\n      return nil if other_face.nil?\r\n      if edge_reversed_in?(edge, face) == edge_reversed_in?(edge, other_face)\r\n        reverse_face(other_face)\r\n      end\r\n      other_face\r\n    end\r\n\r\n    def find_other_shell_face(edge, face)\r\n      return nil if get_faces(edge).size == 1\r\n      return get_other_face(edge, face) if get_faces(edge).size == 2\r\n      return nil if get_faces(edge).count(face) > 1\r\n\r\n      edge_direction = edge_vector(edge, face)\r\n      face_direction = face_normal(face)\r\n      product        = face_direction.cross(edge_direction)\r\n      reversed       = edge_reversed_in?(edge, face)\r\n\r\n      minimum_angle = PI2\r\n      shell_face    = nil\r\n\r\n      get_faces(edge).each { |other_face|\r\n        next if other_face == face\r\n\r\n        other_face_direction = face_normal(other_face)\r\n        if edge_reversed_in?(edge, other_face) == reversed\r\n          other_face_direction.reverse!\r\n        end\r\n\r\n        other_product = edge_direction.cross(other_face_direction)\r\n        angle = product.angle_between(other_product)\r\n        if other_product.dot(face_direction) < 0\r\n          angle = PI2 - angle\r\n        end\r\n\r\n        if angle < minimum_angle\r\n          minimum_angle = angle\r\n          shell_face    = other_face\r\n        end\r\n      }\r\n\r\n      return nil if shell_face.nil?\r\n\r\n      if edge_reversed_in?(edge, shell_face) == reversed\r\n        reverse_face(shell_face)\r\n      end\r\n\r\n      shell_face\r\n    end\r\n\r\n    def find_shell(start_face)\r\n      stack     = []\r\n      processed = Set.new\r\n      shell     = Set.new\r\n\r\n      stack << start_face\r\n      processed << start_face\r\n\r\n      until stack.empty? do\r\n        face = stack.pop\r\n        shell << face\r\n\r\n        face.loops.each { |loop|\r\n          loop.edges.each { |edge|\r\n            next if processed.include?(edge) || get_faces(edge).size < 2\r\n\r\n            processed << edge\r\n            other_shell_face = find_other_shell_face(edge, face)\r\n\r\n            next if other_shell_face.nil?\r\n            next if processed.include?(other_shell_face)\r\n\r\n            stack << other_shell_face\r\n            processed << other_shell_face\r\n          }\r\n        }\r\n      end\r\n\r\n      shell.to_a\r\n    end\r\n\r\n  end\r\nend\r\n\r\nmodule MySolidFix\r\n\r\n  module SolidErrors\r\n\r\n    class SolidError\r\n\r\n      ERROR_COLOR_EDGE = Sketchup::Color.new(255, 0, 0, 255).freeze\r\n      ERROR_COLOR_FACE = Sketchup::Color.new(255, 0, 0, 128).freeze\r\n\r\n      def self.type_name\r\n        self.name.split(\"::\").last\r\n      end\r\n\r\n      def self.display_name\r\n        self.name\r\n      end\r\n\r\n      def self.description\r\n        \"\"\r\n      end\r\n\r\n      attr_accessor :entities\r\n\r\n      def initialize(entities)\r\n        raise TypeError if entities.nil?\r\n        if entities.is_a?(Enumerable)\r\n          @entities = entities.clone\r\n        else\r\n          @entities = [entities]\r\n        end\r\n        @fixed = false\r\n      end\r\n\r\n      def fix\r\n        raise NotImplementedError\r\n      end\r\n\r\n      def fixed?\r\n        @fixed ? true : false\r\n      end\r\n\r\n      def fixable?\r\n        is_a?(Fixable)\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        raise NotImplementedError\r\n      end\r\n\r\n      def to_json(*args)\r\n        data = {\r\n          :id         => object_id,\r\n          :is_fixable => fixable?\r\n        }\r\n        data.to_json(*args)\r\n      end\r\n\r\n    end\r\n\r\n    module Fixable\r\n    end\r\n\r\n    module EraseToFix\r\n\r\n      include Fixable\r\n\r\n      def fix\r\n        entity = @entities.find { |entity| entity.valid? }\r\n        return false if entity.nil?\r\n        entities = entity.parent.entities\r\n        entities.erase_entities(@entities)\r\n        @fixed = true\r\n        true\r\n      end\r\n\r\n    end\r\n\r\n    class HiddenFace < SolidError\r\n\r\n      include Fixable\r\n\r\n      def self.display_name\r\n        \"Hidden Faces\"\r\n      end\r\n\r\n      def self.description\r\n        \"Hidden faces will not be exported to STL file, and may cause holes \"\\\r\n        \"in a mesh.\"\r\n      end\r\n\r\n      def fix\r\n        face = @entities[0]\r\n        return false if face.deleted?\r\n        face.visible = true\r\n        @fixed = true\r\n        true\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_FACE\r\n        draw_face(view, @entities[0], transformation, texture_id: texture_id)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        @entities[0].edges.each { |edge|\r\n          draw_edge(view, edge, transformation)\r\n        }\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class BorderEdge < SolidError\r\n\r\n      def self.display_name\r\n        \"Border Edges\"\r\n      end\r\n\r\n      def self.description\r\n        \"Border edges are connected to only one face and therefore doesn't \"\\\r\n        \"form a manifold. These cannot be fixed automatically and must be \"\\\r\n        \"fixed by hand.\"\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        draw_edge(view, @entities[0], transformation)\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class InternalFaceEdge < SolidError\r\n\r\n      def self.display_name\r\n        \"Internal Face Edges\"\r\n      end\r\n\r\n      def self.description\r\n        \"Internal face edges are edges connected to internal faces. However, \"\\\r\n        \"if there are holes in the mesh it is not possible to reliably \"\\\r\n        \"determine which faces are internal. Fix the holes in the mesh and \"\\\r\n        \"then run the tool again.\"\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        draw_edge(view, @entities[0], transformation)\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class InternalFace < SolidError\r\n\r\n      include EraseToFix\r\n\r\n      def self.display_name\r\n        \"Internal Faces\"\r\n      end\r\n\r\n      def self.description\r\n        \"Internal faces are faces located on the inside of a mesh that should \"\\\r\n        \"be a solid. These are automatically fixed by erasing the internal \"\\\r\n        \"faces.\"\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_FACE\r\n        draw_face(view, @entities[0], transformation, texture_id: texture_id)\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class ExternalFace < SolidError\r\n\r\n      include EraseToFix\r\n\r\n      def self.display_name\r\n        \"External Faces\"\r\n      end\r\n\r\n      def self.description\r\n        \"External faces are faces located on the outside of a mesh that should \"\\\r\n        \"be a solid. These are automatically fixed by erasing the internal \"\\\r\n        \"faces.\"\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_FACE\r\n        draw_face(view, @entities[0], transformation, texture_id: texture_id)\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class ReversedFace < SolidError\r\n\r\n      include Fixable\r\n\r\n      def self.display_name\r\n        \"Reversed Faces\"\r\n      end\r\n\r\n      def self.description\r\n        \"Many applications will not be able to treat a mesh as a solid if the \"\\\r\n        \"face normal (direction) isn't all uniform. The front side of a face \"\\\r\n        \"must be facing outwards. These can be fixed automatically by \"\\\r\n        \"reversing the faces.\"\r\n      end\r\n\r\n      def fix\r\n        face = @entities[0]\r\n        return false if face.deleted?\r\n\r\n        front_material = face.material\r\n        back_material  = face.back_material\r\n\r\n        front_mapping = uv_mapping(face, true)\r\n        back_mapping  = uv_mapping(face, false)\r\n\r\n        front_projection = get_projection(face, true)\r\n        back_projection  = get_projection(face, false)\r\n\r\n        face.reverse!\r\n\r\n        apply_material(face, back_material,  back_mapping,  true)\r\n        apply_material(face, front_material, front_mapping, false)\r\n\r\n        apply_projection(face, back_projection,  true)\r\n        apply_projection(face, front_projection, false)\r\n\r\n        @fixed = true\r\n        true\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_FACE\r\n        draw_face(view, @entities[0], transformation, texture_id: texture_id)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        @entities[0].edges.each { |edge|\r\n          draw_edge(view, edge, transformation)\r\n        }\r\n        nil\r\n      end\r\n\r\n      private\r\n\r\n      def uv_mapping(face, front)\r\n        material = (front) ? face.material : face.back_material\r\n        if material && material.texture\r\n          start_point = face.vertices.first.position\r\n\r\n          points = [start_point]\r\n          points << points[0].offset(face.normal.axes.x, 10)\r\n          points << points[0].offset(face.normal.axes.y, 10)\r\n          points << points[1].offset(face.normal.axes.y, 10)\r\n\r\n          tw  = Sketchup.create_texture_writer\r\n          uvh = face.get_UVHelper(true, true, tw)\r\n\r\n          mapping = []\r\n          points.each_with_index { |point, index|\r\n            uvq = (front) ? uvh.get_front_UVQ(point) : uvh.get_back_UVQ(point)\r\n            mapping << point\r\n            mapping << uvq_to_uv(uvq)\r\n          }\r\n\r\n          mapping\r\n        else\r\n          nil\r\n        end\r\n      end\r\n\r\n      def apply_material(face, material, uv_mapping, front)\r\n        if material && uv_mapping\r\n          face.position_material(material, uv_mapping, front)\r\n        else\r\n          if front\r\n            face.material = material\r\n          else\r\n            face.back_material = material\r\n          end\r\n        end\r\n        nil\r\n      end\r\n\r\n      def uvq_to_uv(uvq)\r\n        Geom::Point3d.new(uvq.x / uvq.z, uvq.y / uvq.z, 1.0)\r\n      end\r\n\r\n      def apply_projection(face, projection, front)\r\n        if projection && face.respond_to?(:set_texture_projection)\r\n          face.set_texture_projection(projection, front)\r\n        end\r\n        nil\r\n      end\r\n\r\n      def get_projection(face, front)\r\n        if face.respond_to?(:get_texture_projection)\r\n          face.get_texture_projection(front)\r\n        else\r\n          nil\r\n        end\r\n      end\r\n\r\n    end\r\n\r\n    class StrayEdge < SolidError\r\n\r\n      include EraseToFix\r\n\r\n      def self.display_name\r\n        \"Stray Edges\"\r\n      end\r\n\r\n      def self.description\r\n        \"Stray edges are not connected to any faces and doesn't form any part \"\\\r\n        \"of solids. These are automatically fixed by erasing the stray edges.\"\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        draw_edge(view, @entities[0], transformation)\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class SurfaceBorder < SolidError\r\n\r\n      def self.display_name\r\n        \"Surface Borders\"\r\n      end\r\n\r\n      def self.description\r\n        \"Edges that form the border of a surface or a hole in the mesh. \"\\\r\n        \"These cannot be fixed automatically. Manually close the mesh and \"\\\r\n        \"run the tool again.\"\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        @entities.each { |edge|\r\n          draw_edge(view, edge, transformation)\r\n        }\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class FaceHole < SolidError\r\n\r\n      include EraseToFix\r\n\r\n      def self.display_name\r\n        \"Face Holes\"\r\n      end\r\n\r\n      def self.description\r\n        \"Edges that form the a hole in a face. These are fixed automatically \"\\\r\n        \"by erasing the hole.\"\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        @entities.each { |edge|\r\n          draw_edge(view, edge, transformation)\r\n        }\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class NestedInstance < SolidError\r\n\r\n      def self.display_name\r\n        \"Nested Instances\"\r\n      end\r\n\r\n      def self.description\r\n        \"Nested instances will be exported correctly to STL file format by \"\\\r\n        \"the Trimble SketchUp STL exporter, but SketchUp's Solid Tools and \"\\\r\n        \"#{PLUGIN_NAME} doesn't treat nested instances as a solid.\"\r\n      end\r\n\r\n      def fix\r\n        raise NotImplementedError\r\n\r\n        return false if @entities[0].deleted?\r\n        @entities[0].explode\r\n        @fixed = true\r\n        true\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        draw_instance(view, @entities[0], transformation)\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class ImageEntity < SolidError\r\n\r\n      def self.display_name\r\n        \"Image Entity\"\r\n      end\r\n\r\n      def self.description\r\n        \"Image entities isn't exported by the Trimble SketchUp STL exporter, \"\\\r\n        \"but it prevent SketchUp's Solid Tools from performing it's \"\\\r\n        \"operations on the object.\"\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        draw_instance(view, @entities[0], transformation)\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n    class ShortEdge < SolidError\r\n\r\n      def self.display_name\r\n        \"Short Edges\"\r\n      end\r\n\r\n      def self.description\r\n        \"Small geometry might cause unpredictable results due to precision \"\\\r\n        \"errors. It's beneficial to try to avoid such small geometry. This \"\\\r\n        \"cannot be automatically fixed. You might want to scale the model up \"\\\r\n        \"by factors of 10 to work around such problems.\"\r\n      end\r\n\r\n      def draw(view, transformation = nil, texture_id: nil)\r\n        view.drawing_color = ERROR_COLOR_EDGE\r\n        draw_edge(view, @entities[0], transformation)\r\n        nil\r\n      end\r\n\r\n    end\r\n\r\n  end\r\n\r\nend\r\n\r\nmodule MySolidFix\r\n\r\n  class ErrorFinder\r\n\r\n    def self.find_errors(entities)\r\n      raise TypeError unless entities.is_a?(Sketchup::Entities)\r\n\r\n      errors = []\r\n\r\n      self.time(\"Total analysis\") {\r\n\r\n        mesh_border_edges          = []\r\n        hole_edges                 = []\r\n        edges_with_internal_faces  = []\r\n\r\n        Sketchup.status_text = ScriptUpComunidade::UnirFacesCoplanares.obter_texto(:status_faces)\r\n\r\n        all_faces = entities.grep(Sketchup::Face)\r\n        all_faces.each { |face|\r\n          if !face.visible?\r\n            errors << SolidErrors::HiddenFace.new(face)\r\n          end\r\n        }\r\n\r\n        Sketchup.status_text = ScriptUpComunidade::UnirFacesCoplanares.obter_texto(:status_arestas)\r\n\r\n        entities.grep(Sketchup::Edge) { |edge|\r\n          num_faces = edge.faces.size\r\n          if num_faces == 0\r\n            errors << SolidErrors::StrayEdge.new(edge)\r\n          elsif num_faces == 1\r\n            face = edge.faces.first\r\n            if face.outer_loop.edges.include?(edge)\r\n              mesh_border_edges << edge\r\n            else\r\n              hole_edges << edge\r\n            end\r\n          elsif num_faces > 2\r\n            edges_with_internal_faces << edge\r\n          end\r\n        }\r\n\r\n        Sketchup.status_text = ScriptUpComunidade::UnirFacesCoplanares.obter_texto(:status_manifold)\r\n\r\n        shell = Shell.new(entities)\r\n\r\n        self.time(\"Resolving manifold\") {\r\n          shell.resolve\r\n        }\r\n\r\n        if shell.valid?\r\n          shell.internal_faces.each { |face|\r\n            errors << SolidErrors::InternalFace.new(face)\r\n          }\r\n          shell.external_faces.each { |face|\r\n            errors << SolidErrors::ExternalFace.new(face)\r\n          }\r\n          shell.reversed_faces.each { |face|\r\n            errors << SolidErrors::ReversedFace.new(face)\r\n          }\r\n        else\r\n          Sketchup.status_text = ScriptUpComunidade::UnirFacesCoplanares.obter_texto(:status_analisando)\r\n\r\n          Sketchup.status_text = ScriptUpComunidade::UnirFacesCoplanares.obter_texto(:status_bordas)\r\n          self.group_connected_edges(mesh_border_edges).each { |edges|\r\n            errors << SolidErrors::SurfaceBorder.new(edges)\r\n          }\r\n\r\n          Sketchup.status_text = ScriptUpComunidade::UnirFacesCoplanares.obter_texto(:status_buracos)\r\n          self.group_connected_edges(hole_edges).each { |edges|\r\n            errors << SolidErrors::FaceHole.new(edges)\r\n          }\r\n\r\n          edges_with_internal_faces.each { |edge|\r\n            errors << SolidErrors::InternalFaceEdge.new(edge)\r\n          }\r\n        end\r\n\r\n        self.time(\"Instance detection\") {\r\n          groups     = entities.grep(Sketchup::Group)\r\n          components = entities.grep(Sketchup::ComponentInstance)\r\n          instances  = groups + components\r\n          instances.each { |instance|\r\n            errors << SolidErrors::NestedInstance.new(instance)\r\n          }\r\n        }\r\n\r\n        self.time(\"Image detection\") {\r\n          entities.grep(Sketchup::Image) { |image|\r\n            errors << SolidErrors::ImageEntity.new(image)\r\n          }\r\n        }\r\n\r\n        if false\r\n          self.time(\"Short edge detection\") {\r\n            self.find_short_edges(entities) { |edge|\r\n              errors << SolidErrors::ShortEdge.new(edge)\r\n            }\r\n          }\r\n        end\r\n\r\n      }\r\n\r\n      Sketchup.status_text = \"\"\r\n\r\n      errors\r\n    end\r\n\r\n    def self.find_short_edges(entities, &block)\r\n      threshold = Settings.short_edge_threshold\r\n      entities.grep(Sketchup::Edge) { |edge|\r\n        if edge.length < threshold\r\n          block.call(edge)\r\n        end\r\n      }\r\n      nil\r\n    end\r\n\r\n    def self.fix_errors(errors, entities)\r\n      all_errors_fixed       = true\r\n      entities_to_be_erased  = Set.new\r\n      remaining_errors       = []\r\n      errors.each { |error|\r\n        if error.is_a?(SolidErrors::EraseToFix)\r\n          entities_to_be_erased.merge(error.entities)\r\n        else\r\n          remaining_errors << error\r\n        end\r\n      }\r\n\r\n      stray_edges = Set.new\r\n      entities_to_be_erased.grep(Sketchup::Face) { |face|\r\n        face.edges.each { |edge|\r\n          if edge.faces.all? { |f| entities_to_be_erased.include?(f) }\r\n            stray_edges << edge\r\n          end\r\n        }\r\n      }\r\n      entities_to_be_erased.merge(stray_edges)\r\n      entities_to_be_erased.reject! { |entity| entity.deleted? }\r\n\r\n      model = entities.model\r\n      begin\r\n        model.start_operation(\"Repair Solid\", true)\r\n        entities.erase_entities(entities_to_be_erased.to_a)\r\n        remaining_errors.each { |error|\r\n          begin\r\n            error.fix\r\n          rescue NotImplementedError => e\r\n            all_errors_fixed = false\r\n          end\r\n        }\r\n        model.commit_operation\r\n      rescue\r\n        model.commit_operation\r\n        raise\r\n      end\r\n      all_errors_fixed\r\n    end\r\n\r\n    def self.group_connected_edges(edges)\r\n      groups = []\r\n      stack  = edges.to_a.clone\r\n      until stack.empty?\r\n        cluster = []\r\n        cluster << stack.shift\r\n\r\n        edge     = cluster.first\r\n        haystack = self.neighbour_edges(edge) & stack\r\n        until haystack.empty?\r\n          next_edge = haystack.shift\r\n\r\n          if stack.include?(next_edge)\r\n            cluster << next_edge\r\n            stack.delete(next_edge)\r\n            haystack += self.neighbour_edges(next_edge) & stack\r\n          end\r\n        end\r\n\r\n        groups << cluster\r\n      end\r\n      groups\r\n    end\r\n\r\n    def self.neighbour_edges(edge)\r\n      (edge.start.edges + edge.end.edges) - [edge]\r\n    end\r\n\r\n    def self.time(message, &block)\r\n      start_time = Time.new\r\n      block.call\r\n      elapsed_time = Time.now - start_time\r\n      if false\r\n        puts \"> #{message} took: #{elapsed_time}s\"\r\n      end\r\n      nil\r\n    end\r\n\r\n  end\r\n\r\nend\r\n\r\nScriptUpComunidade::UnirFacesCoplanares.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "subdivide-face-6tyb6",
    "title": {
      "pt": "Subdivide Face",
      "en": "Subdivide Face",
      "es": "Subdividir cara"
    },
    "author": "F√°bio Coutinho",
    "version": "0.4",
    "description": {
      "pt": "Subdivide face selecionada em dist√¢ncias iguais com resultado de malha suavizada. Ideal para usar com a ferramenta Modelar do Snadbox ou outras ferramentas de modifica√ß√£o de malha.",
      "en": "Subdivides selected face into equal distances resulting in a smoothed mesh. Ideal for use with the Snapbox Model tool or other mesh modification tools.",
      "es": "Subdivide la cara seleccionada en distancias iguales, lo que resulta en una malla suavizada. Ideal para usar con la herramienta Modelo Snapbox u otras herramientas de modificaci√≥n de malla."
    },
    "keywords": {
      "pt": [
        "terreno",
        "malha",
        "sandbox"
      ],
      "en": [
        "land",
        "mesh",
        "sandbox"
      ],
      "es": [
        "tierra",
        "malla",
        "salvadera"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module SubdivideFaceDistancia\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao   => \"Selecione UMA face.\",\r\n        :operacao_nome  => \"Malha Interativa\",\r\n        :titulo_janela  => \"Ajuste de Malha\",\r\n        :label_h3       => \"Espa√ßamento da Malha\",\r\n        :unidade        => \"mm\",\r\n        :btn_cancelar   => \"Cancelar\",\r\n        :btn_aplicar    => \"Aplicar\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao   => \"Select ONE face.\",\r\n        :operacao_nome  => \"Interactive Mesh\",\r\n        :titulo_janela  => \"Mesh Adjustment\",\r\n        :label_h3       => \"Mesh Spacing\",\r\n        :unidade        => \"mm\",\r\n        :btn_cancelar   => \"Cancel\",\r\n        :btn_aplicar    => \"Apply\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao   => \"Seleccione UNA cara.\",\r\n        :operacao_nome  => \"Malla Interactiva\",\r\n        :titulo_janela  => \"Ajuste de Malla\",\r\n        :label_h3       => \"Espaciado de la Malla\",\r\n        :unidade        => \"mm\",\r\n        :btn_cancelar   => \"Cancelar\",\r\n        :btn_aplicar    => \"Aplicar\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    class MalhaPreviewTool\r\n      def initialize(model, face, loops2d, umin, umax, vmin, vmax, plane, t_l2w, modulo)\r\n        @model = model\r\n        @face = face\r\n        @loops2d = loops2d\r\n        @umin, @umax = umin, umax\r\n        @vmin, @vmax = vmin, vmax\r\n        @plane = plane\r\n        @t_l2w = t_l2w\r\n        @modulo = modulo\r\n        @eps = 1.0e-6\r\n        @draw_points = []\r\n        @dialog = nil\r\n        @is_applied = false\r\n      end\r\n\r\n      def activate\r\n        @model.start_operation(@modulo.obter_texto(:operacao_nome), true)\r\n        criar_dialogo\r\n        calcular_linhas(50)\r\n      end\r\n\r\n      def deactivate(view)\r\n        @dialog.close if @dialog && @dialog.visible?\r\n        @model.abort_operation unless @is_applied\r\n        view.invalidate\r\n      end\r\n\r\n      def draw(view)\r\n        return if @draw_points.empty?\r\n        view.drawing_color = \"red\"\r\n        view.line_width = 2\r\n        view.draw(GL_LINES, @draw_points)\r\n      end\r\n      \r\n      def calcular_linhas(step_val)\r\n        step = step_val.to_f.mm\r\n        return if step <= 0.0\r\n\r\n        @draw_points.clear\r\n        \r\n        uc = 0.5 * (@umin + @umax)\r\n        vc = 0.5 * (@vmin + @vmax)\r\n        nx = ((@umax - @umin) * 0.5 / step).floor\r\n        ny = ((@vmax - @vmin) * 0.5 / step).floor\r\n\r\n        vx = [uc]\r\n        (1..nx).each { |k| vx << (uc + k*step) << (uc - k*step) }\r\n        vx.select! { |x| x > @umin + @eps && x < @umax - @eps }\r\n        vx = unique_sorted(vx, @eps)\r\n\r\n        vy = [vc]\r\n        (1..ny).each { |k| vy << (vc + k*step) << (vc - k*step) }\r\n        vy.select! { |y| y > @vmin + @eps && y < @vmax - @eps }\r\n        vy = unique_sorted(vy, @eps)\r\n\r\n        vx.each do |ux|\r\n          ys = crossings_for_x(ux, @loops2d, @eps)\r\n          next if ys.length.odd?\r\n          (0...(ys.length/2)).each do |i|\r\n            y0, y1 = ys[2*i], ys[2*i + 1]\r\n            brk = [y0] + vy.select { |yy| yy > y0 + @eps && yy < y1 - @eps } + [y1]\r\n            brk = unique_sorted(brk, @eps)\r\n            (0...brk.length-1).each do |j|\r\n              adicionar_ponto(ux, brk[j], ux, brk[j+1])\r\n            end\r\n          end\r\n        end\r\n\r\n        vy.each do |vyv|\r\n          xs = crossings_for_y(vyv, @loops2d, @eps)\r\n          next if xs.length.odd?\r\n          (0...(xs.length/2)).each do |i|\r\n            x0, x1 = xs[2*i], xs[2*i + 1]\r\n            brk = [x0] + vx.select { |xx| xx > x0 + @eps && xx < x1 - @eps } + [x1]\r\n            brk = unique_sorted(brk, @eps)\r\n            (0...brk.length-1).each do |j|\r\n              adicionar_ponto(brk[j], vyv, brk[j+1], vyv)\r\n            end\r\n          end\r\n        end\r\n\r\n        @model.active_view.invalidate\r\n      end\r\n\r\n      def adicionar_ponto(x1, y1, x2, y2)\r\n        p1w = (@t_l2w * Geom::Point3d.new(x1, y1, 0)).project_to_plane(@plane)\r\n        p2w = (@t_l2w * Geom::Point3d.new(x2, y2, 0)).project_to_plane(@plane)\r\n        @draw_points << p1w << p2w\r\n      end\r\n\r\n      def criar_dialogo\r\n        html = <<-HTML\r\n        <!DOCTYPE html>\r\n        <html>\r\n        <head>\r\n          <style>\r\n            :root { --primary: #0f62fe; --bg: #f4f4f4; --text: #161616; --border: #c6c6c6; }\r\n            * { box-sizing: border-box; }\r\n            body { \r\n              font-family: \"Segoe UI\", Roboto, Helvetica, sans-serif;\r\n              padding: 20px; \r\n              background: var(--bg); \r\n              color: var(--text); \r\n              margin: 0; \r\n              display: flex; \r\n              flex-direction: column; \r\n              height: 100vh;\r\n            }\r\n            h3 { margin: 0 0 15px 0; font-size: 14px; font-weight: 600;\r\n            color: #525252; text-transform: uppercase; letter-spacing: 0.5px; }\r\n            .control-group { \r\n              background: #fff;\r\n              padding: 15px; \r\n              border-radius: 8px; \r\n              box-shadow: 0 1px 3px rgba(0,0,0,0.08);\r\n              border: 1px solid #e0e0e0;\r\n            }\r\n            .row { display: flex; align-items: center; gap: 12px; }\r\n            input[type=range] { flex-grow: 1; cursor: pointer; accent-color: var(--primary); }\r\n            input[type=number] { \r\n              width: 70px;\r\n              padding: 6px; \r\n              text-align: right; \r\n              border: 1px solid var(--border); \r\n              border-radius: 4px; \r\n              font-size: 14px;\r\n            }\r\n            input[type=number]:focus { outline: 1px solid var(--primary); border-color: var(--primary); }\r\n            .unit { font-size: 13px; color: #666; font-weight: 500; }\r\n            .actions { margin-top: auto; display: flex; gap: 10px; justify-content: flex-end;\r\n            padding-top: 15px;}\r\n            button { \r\n              padding: 8px 16px;\r\n              cursor: pointer; \r\n              border: 1px solid var(--border); \r\n              background: #fff; \r\n              border-radius: 4px; \r\n              font-size: 13px;\r\n              transition: all 0.2s ease;\r\n            }\r\n            button:hover { background: #e5e5e5; }\r\n            #btnApply { background: var(--primary); color: white; border: none; font-weight: 500; }\r\n            #btnApply:hover { background: #0353e9; }\r\n          </style>\r\n        </head>\r\n        <body>\r\n          <h3>#{@modulo.obter_texto(:label_h3)}</h3>\r\n          <div class=\"control-group\">\r\n            <div class=\"row\">\r\n              <input type=\"range\" id=\"slider\" min=\"5\" max=\"2000\" value=\"50\" step=\"1\">\r\n              <input type=\"number\" id=\"inputBox\" min=\"1\" value=\"50\">\r\n              <span class=\"unit\">#{@modulo.obter_texto(:unidade)}</span>\r\n            </div>\r\n          </div>\r\n          <div class=\"actions\">\r\n            <button id=\"btnCancel\">#{@modulo.obter_texto(:btn_cancelar)}</button>\r\n            <button id=\"btnApply\">#{@modulo.obter_texto(:btn_aplicar)}</button>\r\n          </div>\r\n          \r\n          <script>\r\n            const slider = document.getElementById('slider');\r\n            const inputBox = document.getElementById('inputBox');\r\n            let timeout = null;\r\n            \r\n            function update(val) {\r\n              clearTimeout(timeout);\r\n              timeout = setTimeout(() => sketchup.update_preview(Number(val)), 10);\r\n            }\r\n\r\n            slider.addEventListener('input', (e) => { inputBox.value = e.target.value; update(e.target.value); });\r\n            inputBox.addEventListener('change', (e) => { slider.value = e.target.value; update(e.target.value); });\r\n\r\n            document.getElementById('btnApply').addEventListener('click', () => sketchup.apply_mesh());\r\n            document.getElementById('btnCancel').addEventListener('click', () => sketchup.cancel_mesh());\r\n          </script>\r\n        </body>\r\n        </html>\r\n        HTML\r\n\r\n        @dialog = UI::HtmlDialog.new({\r\n          dialog_title: @modulo.obter_texto(:titulo_janela), \r\n          width: 360, \r\n          height: 220,\r\n          style: UI::HtmlDialog::STYLE_DIALOG, \r\n          resizable: false\r\n        })\r\n        @dialog.set_html(html)\r\n\r\n        @dialog.add_action_callback(\"update_preview\") { |_, val| calcular_linhas(val) }\r\n        @dialog.add_action_callback(\"apply_mesh\") { |_| aplicar_malha }\r\n        @dialog.add_action_callback(\"cancel_mesh\") { |_| @model.select_tool(nil) }\r\n        \r\n        @dialog.show\r\n      end\r\n\r\n      def aplicar_malha\r\n        @is_applied = true\r\n        ents = @face.parent.entities\r\n        created = []\r\n        \r\n        @draw_points.each_slice(2) do |p1, p2|\r\n          e = ents.add_line(p1, p2)\r\n          created << e if e\r\n        end\r\n        \r\n        created.compact.each { |e| e.find_faces if e.valid? && e.faces.empty? }\r\n        created.compact.each do |e|\r\n          if e.valid? && e.faces.length == 2\r\n            e.soft = true\r\n            e.smooth = true\r\n          end\r\n        end\r\n        \r\n        @model.commit_operation\r\n        @dialog.close\r\n        @model.select_tool(nil)\r\n      end\r\n\r\n      def unique_sorted(vals, eps)\r\n        vals.sort!\r\n        out = []; last = nil\r\n        vals.each do |v|\r\n          if last.nil? || (v - last).abs > eps\r\n            out << v; last = v\r\n          end\r\n        end\r\n        out\r\n      end\r\n\r\n      def crossings_for_x(ux, loops2d, eps)\r\n        ys = []\r\n        loops2d.each do |poly|\r\n          (0...poly.length).each do |i|\r\n            p1 = poly[i]; p2 = poly[(i + 1) % poly.length]\r\n            x1,y1 = p1.x, p1.y; x2,y2 = p2.x, p2.y\r\n            minx, maxx = [x1,x2].min, [x1,x2].max\r\n            next if ux < minx - eps || ux > maxx + eps\r\n            dx = x2 - x1; next if dx.abs < eps\r\n            t = (ux - x1) / dx; next if t <= 0.0 || t > 1.0 + 1e-12\r\n            ys << (y1 + t*(y2 - y1))\r\n          end\r\n        end\r\n        unique_sorted(ys, eps)\r\n      end\r\n\r\n      def crossings_for_y(vy, loops2d, eps)\r\n        xs = []\r\n        loops2d.each do |poly|\r\n          (0...poly.length).each do |i|\r\n            p1 = poly[i]; p2 = poly[(i + 1) % poly.length]\r\n            x1,y1 = p1.x, p1.y; x2,y2 = p2.x, p2.y\r\n            miny, maxy = [y1,y2].min, [y1,y2].max\r\n            next if vy < miny - eps || vy > maxy + eps\r\n            dy = y2 - y1; next if dy.abs < eps\r\n            t = (vy - y1) / dy; next if t <= 0.0 || t > 1.0 + 1e-12\r\n            xs << (x1 + t*(x2 - x1))\r\n          end\r\n        end\r\n        unique_sorted(xs, eps)\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      model = Sketchup.active_model\r\n      sel   = model.selection\r\n      unless sel[0].is_a?(Sketchup::Face)\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n      face = sel[0]\r\n      n = face.normal\r\n\r\n      longest = face.edges.max_by { |e| e.length.to_f }\r\n      u = nil\r\n      if longest\r\n        vraw = (longest.end.position - longest.start.position)\r\n        dot  = vraw.dot(n)\r\n        nsc  = Geom::Vector3d.new(n.x * dot, n.y * dot, n.z * dot)\r\n        vproj = vraw - nsc\r\n        u = vproj.length > 1e-6 ? vproj.normalize : nil\r\n      end\r\n      if u.nil? || u.length < 1e-6\r\n        u = n.cross(X_AXIS);\r\n        u = n.cross(Y_AXIS) if u.length < 1e-6\r\n        u.normalize!\r\n      end\r\n      v = n.cross(u).normalize\r\n\r\n      plane = [face.vertices.first.position, n]\r\n      bb_center = face.bounds.center\r\n      c = bb_center.project_to_plane(plane)\r\n      t_l2w = Geom::Transformation.axes(c, u, v, n)\r\n      t_w2l = t_l2w.inverse\r\n\r\n      loops2d = face.loops.map do |lp|\r\n        pts = lp.vertices.map { |vr| t_w2l * vr.position }\r\n        pts.map! { |p| Geom::Point3d.new(p.x, p.y, 0) }\r\n        pts\r\n      end\r\n\r\n      all_pts = loops2d.flatten\r\n      allx = all_pts.map(&:x)\r\n      ally = all_pts.map(&:y)\r\n      umin, umax = allx.min, allx.max\r\n      vmin, vmax = ally.min, ally.max\r\n\r\n      model.select_tool(MalhaPreviewTool.new(model, face, loops2d, umin, umax, vmin, vmax, plane, t_l2w, self))\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::SubdivideFaceDistancia.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "selecao-de-malha-por-raio-6u03g",
    "title": {
      "pt": "Sele√ß√£o de Malha por Raio",
      "en": "Mesh Selection by Radius",
      "es": "Selecci√≥n de malla por radio"
    },
    "author": "F√°bio Coutinho",
    "version": "0.3",
    "description": {
      "pt": "Permite selecionar faces de uma malha com uma ferramenta circular. Voc√™ pode definir o raio e alterar entre selecionar ou remover sele√ß√£o.",
      "en": "Allows you to select mesh faces with a circular tool. You can set the radius and switch between selecting or removing the selection.",
      "es": "Permite seleccionar caras de malla con una herramienta circular. Se puede ajustar el radio y alternar entre seleccionar o eliminar la selecci√≥n."
    },
    "keywords": {
      "pt": [
        "sele√ß√£o de malha"
      ],
      "en": [
        "mesh selection"
      ],
      "es": [
        "selecci√≥n de malla"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module PolyBrushSelecao\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :status_text    => \"Pinte com bot√£o esquerdo (commit no soltar). CTRL alterna modo. SHIFT+R reindexa. VCB: di√¢metro + ENTER.\",\r\n        :modo_remover   => \"MODO: Desfazer (CTRL alterna)\",\r\n        :modo_selecionar => \"MODO: Selecionar (CTRL alterna)\",\r\n        :hud_diametro   => \"Di√¢metro: %{diam} mm  |  Medidas: digite valor + ENTER\",\r\n        :op_nome        => \"PolyBrush Sele√ß√£o\"\r\n      },\r\n      'en-US' => {\r\n        :status_text    => \"Paint with left button (commit on release). CTRL toggles mode. SHIFT+R reindexes. VCB: diameter + ENTER.\",\r\n        :modo_remover   => \"MODE: Remove (CTRL toggles)\",\r\n        :modo_selecionar => \"MODE: Select (CTRL toggles)\",\r\n        :hud_diametro   => \"Diameter: %{diam} mm  |  Measurements: type value + ENTER\",\r\n        :op_nome        => \"PolyBrush Selection\"\r\n      },\r\n      'es' => {\r\n        :status_text    => \"Pinte con el bot√≥n izquierdo (confirmar al soltar). CTRL alterna modo. SHIFT+R reindexa. VCB: di√°metro + ENTER.\",\r\n        :modo_remover   => \"MODO: Deshacer (CTRL alterna)\",\r\n        :modo_selecionar => \"MODO: Seleccionar (CTRL alterna)\",\r\n        :hud_diametro   => \"Di√°metro: %{diam} mm  |  Medidas: escriba valor + ENTER\",\r\n        :op_nome        => \"Selecci√≥n PolyBrush\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave, variaveis = {})\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      texto  = IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n      variaveis.each { |k, v| texto = texto.gsub(\"%{#{k}}\", v.to_s) }\r\n      texto\r\n    end\r\n\r\n    class Tool\r\n      include Math\r\n\r\n      def initialize\r\n        require 'set'\r\n\r\n        @diameter_mm = 10000.0\r\n        @radius      = @diameter_mm.mm / 2.0\r\n        @mode_remove = false\r\n        @dragging    = false\r\n        @cursor_pt   = nil\r\n        @ctrl_prev   = false\r\n\r\n        model    = Sketchup.active_model\r\n        @edit_tr = model.edit_transform\r\n\r\n        # Eixos do contexto\r\n        @px = Geom::Vector3d.new(1,0,0).transform(@edit_tr)\r\n        @px.length == 0 ? @px.set!(1,0,0) : @px.normalize!\r\n        @py = Geom::Vector3d.new(0,1,0).transform(@edit_tr); @py.length == 0 ? @py.set!(0,1,0) : @py.normalize!\r\n        @pz = Geom::Vector3d.new(0,0,1).transform(@edit_tr)\r\n        @pz.length == 0 ? @pz.set!(0,0,1) : @pz.normalize!\r\n        @porigin = Geom::Point3d.new(0,0,0).transform(@edit_tr)\r\n\r\n        # √çndice espacial inicial\r\n        build_uv_cache(@radius)\r\n\r\n        # Buffers da passada atual (arrasto)\r\n        @stroke_face_pids = nil   \r\n        @stroke_painted   = Set.new \r\n        @applied_ids      = Set.new \r\n        @sel_initial_face_pids = Set.new\r\n        @sel_initial_others    = [] \r\n      end\r\n\r\n      # ---------- Utils ----------\r\n      def scale_vec(v, s) Geom::Vector3d.new(v.x*s, v.y*s, v.z*s) end\r\n\r\n      def project_uv(p3)\r\n        v = p3 - @porigin\r\n        [v.dot(@px), v.dot(@py)]\r\n      end\r\n\r\n      def pick_on_surface(x, y, view)\r\n        ray = view.pickray(x, y)\r\n        hit = Sketchup.active_model.raytest(ray, true)\r\n        pt = hit && hit[0]\r\n        pt ||= Geom.intersect_line_plane(ray, [@porigin, @pz])\r\n        pt ? pt.offset(@pz, 0.5.mm) : nil\r\n      end\r\n\r\n      def circle_points(center3d, radius_len, segments = 64)\r\n        r = radius_len.to_f\r\n        pts = []\r\n        segments.times do |i|\r\n          t  = 2.0 * PI * (i.to_f / segments)\r\n          vx = scale_vec(@px, r * Math.cos(t))\r\n          vy = scale_vec(@py, r * Math.sin(t))\r\n          pts << center3d.offset(vx + vy)\r\n        end\r\n        pts\r\n      end\r\n\r\n      # ---------- √çndice Espacial / Cache ----------\r\n      def build_uv_cache(cell_size = @radius)\r\n        ents  = Sketchup.active_model.active_entities\r\n        @faces = ents.grep(Sketchup::Face).select(&:valid?)\r\n        @pid_to_face = {}\r\n        @uv_by_pid   = {}\r\n        @grid        = {}\r\n        @cell = [cell_size.to_f, 1.mm.to_f].max\r\n\r\n        @faces.each do |f|\r\n          pid = f.persistent_id\r\n          @pid_to_face[pid] = f\r\n          uvs = f.vertices.map { |v| project_uv(v.position) }\r\n          @uv_by_pid[pid] = uvs\r\n          umin, umax = uvs.map(&:first).minmax\r\n          vmin, vmax = uvs.map(&:last ).minmax\r\n          ix0 = (umin/@cell).floor\r\n          ix1 = (umax/@cell).floor\r\n          iy0 = (vmin/@cell).floor\r\n          iy1 = (vmax/@cell).floor\r\n          (ix0..ix1).each do |ix|\r\n            (iy0..iy1).each do |iy|\r\n              key = \"#{ix},#{iy}\"\r\n              (@grid[key] ||= Set.new) << pid\r\n            end\r\n          end\r\n        end\r\n      end\r\n\r\n      def candidate_pids(center3d, radius)\r\n        uc, vc = project_uv(center3d)\r\n        r  = radius.to_f\r\n        cr = (r/@cell).ceil\r\n        cix = (uc/@cell).floor\r\n        ciy = (vc/@cell).floor\r\n        out = Set.new\r\n        (-cr..cr).each do |dx|\r\n          (-cr..cr).each do |dy|\r\n            key = \"#{cix+dx},#{ciy+dy}\"\r\n            s = @grid[key]\r\n            out.merge(s) if s\r\n          end\r\n        end\r\n        out\r\n      end\r\n\r\n      # ---------- Passada (arrasto) em mem√≥ria ----------\r\n      def begin_stroke\r\n        sel = Sketchup.active_model.selection\r\n        faces = sel.grep(Sketchup::Face)\r\n        others = sel.to_a - faces\r\n        @sel_initial_face_pids = Set.new(faces.map(&:persistent_id))\r\n        @sel_initial_others    = others\r\n        @stroke_face_pids = @sel_initial_face_pids.dup\r\n        @stroke_painted.clear\r\n        @applied_ids.clear\r\n      end\r\n\r\n      def apply_brush_at(center3d)\r\n        return unless center3d\r\n        return unless @stroke_face_pids\r\n\r\n        r   = @radius.to_f\r\n        r2  = r*r\r\n        uc, vc = project_uv(center3d)\r\n\r\n        candidate_pids(center3d, r).each do |pid|\r\n          next if @applied_ids.include?(pid)\r\n          uvs = @uv_by_pid[pid]\r\n          next unless uvs && !uvs.empty?\r\n          inside = uvs.any? { |(u,v)| ((u-uc)**2 + (v-vc)**2) <= r2 }\r\n          next unless inside\r\n\r\n          if @mode_remove\r\n            @stroke_face_pids.delete(pid)\r\n          else\r\n            @stroke_face_pids.add(pid)\r\n          end\r\n\r\n          @stroke_painted.add(pid)\r\n          @applied_ids.add(pid)\r\n        end\r\n      end\r\n\r\n      def commit_stroke\r\n        return unless @stroke_face_pids\r\n\r\n        faces_final = @stroke_face_pids.map { |pid|\r\n          f = @pid_to_face[pid]\r\n          (f && f.valid?) ? f : nil\r\n        }.compact\r\n        final_selection = @sel_initial_others + faces_final\r\n\r\n        model = Sketchup.active_model\r\n        sel   = model.selection\r\n        model.start_operation(PolyBrushSelecao.obter_texto(:op_nome), true)\r\n        sel.clear\r\n        sel.add(final_selection)\r\n        model.commit_operation\r\n\r\n        @stroke_face_pids = nil\r\n        @stroke_painted.clear\r\n        @applied_ids.clear\r\n      end\r\n\r\n      def cancel_stroke\r\n        @stroke_face_pids = nil\r\n        @stroke_painted.clear\r\n        @applied_ids.clear\r\n      end\r\n\r\n      # ---------- HUD ----------\r\n      def hud_lines\r\n        mode = @mode_remove ? PolyBrushSelecao.obter_texto(:modo_remover) : PolyBrushSelecao.obter_texto(:modo_selecionar)\r\n        dim  = PolyBrushSelecao.obter_texto(:hud_diametro, {:diam => @diameter_mm.to_i})\r\n        [mode, dim]\r\n      end\r\n\r\n      def is_ctrl_key?(key) key == 17 end \r\n      def ctrl_down?(flags) (flags & COPY_MODIFIER_KEY) == COPY_MODIFIER_KEY end\r\n\r\n      # ---------- Tool API ----------\r\n      def activate\r\n        Sketchup.status_text = PolyBrushSelecao.obter_texto(:status_text)\r\n      end\r\n\r\n      def deactivate(view); view.invalidate; end\r\n\r\n      def onMouseMove(flags, x, y, view)\r\n        @cursor_pt = pick_on_surface(x, y, view)\r\n        if @dragging\r\n          apply_brush_at(@cursor_pt)\r\n        end\r\n        view.invalidate\r\n      end\r\n\r\n      def onLButtonDown(flags, x, y, view)\r\n        @dragging = true\r\n        begin_stroke\r\n        @cursor_pt = pick_on_surface(x, y, view)\r\n        apply_brush_at(@cursor_pt)\r\n        view.invalidate\r\n      end\r\n\r\n      def onLButtonUp(flags, x, y, view)\r\n        @dragging = false\r\n        commit_stroke\r\n        view.invalidate\r\n      end\r\n\r\n      def onKeyDown(key, repeat, flags, view)\r\n        if key == 82 && (flags & SHIFT_MODIFIER_KEY) == SHIFT_MODIFIER_KEY # 'R'\r\n          build_uv_cache(@radius)\r\n          UI.beep\r\n          view.invalidate\r\n          return\r\n        end\r\n\r\n        if (is_ctrl_key?(key) || ctrl_down?(flags)) && !@ctrl_prev\r\n          @mode_remove = !@mode_remove\r\n          @ctrl_prev = true\r\n          view.invalidate\r\n        end\r\n      end\r\n\r\n      def onKeyUp(key, repeat, flags, view)\r\n        @ctrl_prev = false unless ctrl_down?(flags)\r\n      end\r\n\r\n      def onCancel(reason, view)\r\n        @dragging = false\r\n        cancel_stroke\r\n        view.invalidate\r\n      end\r\n\r\n      def onUserText(text, view)\r\n        str = text.to_s.strip\r\n        return if str.empty?\r\n        len = if str =~ /[a-zA-Z]/\r\n                begin\r\n                  str.to_l\r\n                rescue\r\n                  nil\r\n                end\r\n              else\r\n                (str.to_f).mm\r\n              end\r\n\r\n        return unless len && len > 0.0\r\n        @diameter_mm = len.to_mm\r\n        @radius      = len / 2.0\r\n        build_uv_cache(@radius)\r\n        view.invalidate\r\n      end\r\n\r\n      def draw(view)\r\n        if @cursor_pt\r\n          r = @radius.to_f\r\n          pts = circle_points(@cursor_pt, r, 72)\r\n          view.line_stipple  = \"\"\r\n          view.line_width    = 2\r\n          view.drawing_color = @mode_remove ? Sketchup::Color.new(220, 60, 60) : Sketchup::Color.new(60, 180, 60)\r\n          view.draw(GL_LINE_LOOP, pts)\r\n\r\n          cpts = circle_points(@cursor_pt, [r * 0.025, 2.mm.to_f].max, 24)\r\n          view.line_width = 1\r\n          view.drawing_color = Sketchup::Color.new(40, 40, 40)\r\n          view.draw(GL_LINE_LOOP, cpts)\r\n\r\n          scr = view.screen_coords(@cursor_pt)\r\n          y = scr.y + 18\r\n          hud_lines.each do |txt|\r\n            view.draw_text(Geom::Point3d.new(scr.x + 12, y, 0), txt)\r\n            y += 16\r\n          end\r\n        end\r\n\r\n        return unless @dragging && !@stroke_painted.empty?\r\n        view.line_width = 1\r\n        view.drawing_color = Sketchup::Color.new(30, 150, 240)\r\n        @stroke_painted.each do |pid|\r\n          f = @pid_to_face[pid]\r\n          next unless f && f.valid?\r\n          edges = f.outer_loop.edges\r\n          pts = []\r\n          edges.each do |e|\r\n            pts << e.start.position\r\n            pts << e.end.position\r\n          end\r\n          view.draw(GL_LINES, pts) unless pts.empty?\r\n        end\r\n      end\r\n\r\n      def getExtents\r\n        bb = Geom::BoundingBox.new\r\n        if @cursor_pt\r\n          r = @radius.to_f\r\n          xoff = scale_vec(@px, r)\r\n          yoff = scale_vec(@py, r)\r\n          bb.add(@cursor_pt.offset(xoff + yoff))\r\n          bb.add(@cursor_pt.offset(xoff - yoff))\r\n          bb.add(@cursor_pt.offset(scale_vec(@px, -r) + yoff))\r\n          bb.add(@cursor_pt.offset(scale_vec(@px, -r) + scale_vec(@py, -r)))\r\n        end\r\n        bb\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      Sketchup.active_model.tools.push_tool(Tool.new)\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::PolyBrushSelecao.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "remover-materiais-aplicados-6vkz5",
    "title": {
      "pt": "Remover Materiais Aplicados",
      "en": "Remove Applied Materials",
      "es": "Eliminar materiales aplicados"
    },
    "author": "F√°bio Coutinho",
    "version": "0.2",
    "description": {
      "pt": "Remove todos os materiais aplicados em toda a hierarquia dos elementos selecionados.",
      "en": "Remove all materials applied across the entire hierarchy of the selected elements.",
      "es": "Eliminar todos los materiales aplicados en toda la jerarqu√≠a de los elementos seleccionados."
    },
    "keywords": {
      "pt": [
        "remover materiais",
        "material",
        "textura"
      ],
      "en": [
        "remove materials",
        "material",
        "texture"
      ],
      "es": [
        "retirar materiales",
        "material",
        "textura"
      ]
    },
    "code": {
      "pt": "# Remover TODOS os materiais do selecionado (grupo/componente) e de toda a hierarquia\r\n# Cole no Console Ruby com um grupo ou componente selecionado.\r\n\r\nmodel = Sketchup.active_model\r\nsel = model.selection\r\nalvos = sel.grep(Sketchup::Group) + sel.grep(Sketchup::ComponentInstance)\r\n\r\nif alvos.empty?\r\n  puts \"Selecione um grupo ou componente.\"\r\n  return\r\nend\r\n\r\nfaces_limpas = 0\r\ninst_processadas = 0\r\ndefinicoes_unicas = 0\r\ndefs_processadas = {} # NOVO: Dicion√°rio para evitar reprocessamento\r\n\r\nclear_entities = nil\r\nclear_instance = nil\r\n\r\nclear_entities = lambda { |entities|\r\n  # Faces: limpa frente e verso de forma direta, sem checagens redundantes\r\n  entities.grep(Sketchup::Face).each do |f|\r\n    if f.material\r\n      f.material = nil\r\n      faces_limpas += 1\r\n    end\r\n    if f.back_material\r\n      f.back_material = nil\r\n      faces_limpas += 1\r\n    end\r\n  end\r\n\r\n  # Grupos e Componentes: concatenados para iterar apenas uma vez\r\n  (entities.grep(Sketchup::Group) + entities.grep(Sketchup::ComponentInstance)).each do |inst|\r\n    next if inst.deleted?\r\n    inst.material = nil if inst.material\r\n    inst_processadas += 1\r\n    clear_instance.call(inst)\r\n  end\r\n}\r\n\r\nclear_instance = lambda { |inst|\r\n  is_group = inst.is_a?(Sketchup::Group)\r\n  \r\n  # Removemos o make_unique. A limpeza agora age direto na raiz da Defini√ß√£o.\r\n  # Isso iguala a performance ao Material Tools.\r\n  defn = is_group ? inst.entities.parent : inst.definition\r\n  \r\n  # Checa o cache: varre as entidades internas apenas na primeira vez que encontrar esta defini√ß√£o\r\n  unless defs_processadas[defn]\r\n    defs_processadas[defn] = true\r\n    clear_entities.call(is_group ? inst.entities : defn.entities)\r\n  end\r\n}\r\n\r\nmodel.start_operation(\"Remover Materiais Recursivo\", true)\r\nbegin\r\n  alvos.each do |t|\r\n    t.material = nil if t.respond_to?(:material) && t.material\r\n    inst_processadas += 1\r\n    clear_instance.call(t)\r\n  end\r\n  model.commit_operation\r\nrescue => e\r\n  model.abort_operation\r\n  puts \"Erro: #{e}\"\r\nend\r\n\r\nputs \"Materiais removidos.\"\r\nputs \"Faces limpas: #{faces_limpas}\"\r\nputs \"Inst√¢ncias processadas: #{inst_processadas}\"\r\nputs \"Defini√ß√µes tornadas √∫nicas: #{definicoes_unicas}\""
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "regua-dinamica-de-superficie-71sd7",
    "title": {
      "pt": "R√©gua Din√¢mica de Superf√≠cie",
      "en": "Dynamic Surface Ruler",
      "es": "Regla de superficie din√°mica"
    },
    "author": "F√°bio Coutinho",
    "version": "0.4",
    "description": {
      "pt": "R√©gua din√¢mica que acompanha a posi√ß√£o do cursor e mostra a medida da superf√≠cie de aresta a aresta.",
      "en": "A dynamic ruler that follows the cursor's position and shows the surface area measurement from edge to edge.",
      "es": "Una regla din√°mica que sigue la posici√≥n del cursor y muestra la medida del √°rea de la superficie de borde a borde."
    },
    "keywords": {
      "pt": [
        "r√©gua",
        "medidas"
      ],
      "en": [
        "ruler",
        "measures"
      ],
      "es": [
        "gobernante",
        "medidas"
      ]
    },
    "code": {
      "pt": "module ScriptUpComunidade\r\n  module MedirParedes\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :status_texto => \"Unidade: %s (CTRL) | Setas ESQUERDA e DIREITA alteram a rota√ß√£o.\",\r\n        :console_ativo => \"[RaycastTool] Ativo. Medi√ß√£o parede-a-parede ignorando ocultos.\",\r\n        :console_clique => \"[Raycast] Clique ignorado. Use Ctrl para unidades.\"\r\n      },\r\n      'en-US' => {\r\n        :status_texto => \"Unit: %s (CTRL) | LEFT and RIGHT arrows change rotation.\",\r\n        :console_ativo => \"[RaycastTool] Active. Wall-to-wall measurement ignoring hidden objects.\",\r\n        :console_clique => \"[Raycast] Click ignored. Use Ctrl for units.\"\r\n      },\r\n      'es' => {\r\n        :status_texto => \"Unidad: %s (CTRL) | Flechas IZQUIERDA y DERECHA cambian la rotaci√≥n.\",\r\n        :console_ativo => \"[RaycastTool] Activo. Medici√≥n de pared a pared ignorando ocultos.\",\r\n        :console_clique => \"[Raycast] Clic ignorado. Use Ctrl para unidades.\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def self.executar\r\n      Sketchup.active_model.select_tool(Tool.new)\r\n    end\r\n\r\n    class Tool\r\n      # Constantes\r\n      EPS       = 1.mm unless defined?(EPS)\r\n      VEC_EPS   = 1e-5 unless defined?(VEC_EPS)\r\n      Z_AXIS    = Geom::Vector3d.new(0, 0, 1) unless defined?(Z_AXIS)\r\n      X_AXIS    = Geom::Vector3d.new(1, 0, 0) unless defined?(X_AXIS)\r\n\r\n      def activate\r\n        @ip = Sketchup::InputPoint.new\r\n        @preview_data = nil\r\n        @rot_index = 0 \r\n        @last_x = 0\r\n        @last_y = 0\r\n\r\n        setup_initial_unit\r\n        Sketchup.active_model.active_view.invalidate\r\n        update_status_text\r\n        puts MedirParedes.obter_texto(:console_ativo)\r\n      end\r\n\r\n      def deactivate(view)\r\n        view.invalidate\r\n      end\r\n\r\n      def resume(view)\r\n        update_status_text\r\n        view.invalidate\r\n      end\r\n\r\n      def onCancel(reason, view)\r\n        @preview_data = nil\r\n        view.invalidate\r\n      end\r\n\r\n      def onKeyUp(key, repeat, flags, view)\r\n        case key\r\n        when VK_RIGHT\r\n          @rot_index = (@rot_index + 1) % 4\r\n          trigger_update(view)\r\n        when VK_LEFT\r\n          @rot_index = (@rot_index - 1) % 4\r\n          trigger_update(view)\r\n        when VK_CONTROL\r\n          @unit_index = (@unit_index + 1) % 3\r\n          trigger_update(view)\r\n        end\r\n      end\r\n\r\n      def onKeyDown(key, repeat, flags, view)\r\n      end\r\n\r\n      def onMouseMove(flags, x, y, view)\r\n        @last_x, @last_y = x, y\r\n        @ip.pick(view, x, y)\r\n        @preview_data = calculate_raycast_hits(view, x, y)\r\n        view.invalidate\r\n      end\r\n\r\n      def draw(view)\r\n        @ip.draw(view) if @ip.valid?\r\n\r\n        if @preview_data\r\n          p_center, p_hit_pos, p_hit_neg = @preview_data\r\n          \r\n          pt_start = p_hit_neg ? p_hit_neg : p_center\r\n          pt_end   = p_hit_pos ? p_hit_pos : p_center\r\n\r\n          if pt_start != pt_end\r\n            view.line_width = 2\r\n            view.line_stipple = \"_\"\r\n            view.drawing_color = \"red\" \r\n            view.draw(GL_LINES, pt_start, pt_end)\r\n            view.draw_points([pt_start, pt_end], 10, 2, \"red\")\r\n\r\n            total_dist = pt_start.distance(pt_end)\r\n            text_str = format_distance(total_dist)\r\n\r\n            screen_p1 = view.screen_coords(pt_start)\r\n            screen_p2 = view.screen_coords(pt_end)\r\n            \r\n            text_pos = calculate_smart_text_pos(screen_p1, screen_p2)\r\n\r\n            draw_highlighted_text(view, text_pos, text_str)\r\n          end\r\n        end\r\n      end\r\n\r\n      def draw_highlighted_text(view, screen_pt, text)\r\n        options = { :color => \"red\", :size => 20, :bold => true, :font => \"Arial\" }\r\n        begin\r\n          view.draw_text(screen_pt, text, options)\r\n        rescue\r\n          view.draw_text(screen_pt, text)\r\n        end\r\n      end\r\n\r\n      def calculate_smart_text_pos(sp1, sp2)\r\n        mid_x = (sp1.x + sp2.x) / 2.0\r\n        mid_y = (sp1.y + sp2.y) / 2.0\r\n        \r\n        vx = sp2.x - sp1.x\r\n        vy = sp2.y - sp1.y\r\n        len = Math.sqrt(vx*vx + vy*vy)\r\n        offset_dist = 25.0\r\n\r\n        return Geom::Point3d.new(mid_x, mid_y - offset_dist, 0) if len < 1.0\r\n\r\n        ux = vx / len\r\n        uy = vy / len\r\n        perp_x = -uy\r\n        perp_y = ux\r\n\r\n        if perp_y > 0\r\n          perp_x = -perp_x\r\n          perp_y = -perp_y\r\n        end\r\n\r\n        final_x = mid_x + (perp_x * offset_dist) - 20\r\n        final_y = mid_y + (perp_y * offset_dist) - 10\r\n\r\n        Geom::Point3d.new(final_x, final_y, 0)\r\n      end\r\n\r\n      def onLButtonDown(flags, x, y, view)\r\n        puts MedirParedes.obter_texto(:console_clique)\r\n      end\r\n\r\n      private\r\n\r\n      def setup_initial_unit\r\n        model_unit = Sketchup.active_model.options['UnitsOptions']['LengthUnit']\r\n        case model_unit\r\n        when 2 then @unit_index = 0 # mm\r\n        when 3 then @unit_index = 1 # cm\r\n        when 4 then @unit_index = 2 # m\r\n        else        @unit_index = 1 \r\n        end\r\n      end\r\n\r\n      def format_distance(dist_inch)\r\n        val = 0.0\r\n        suffix = \"\"\r\n        case @unit_index\r\n        when 0 then val = dist_inch.to_mm; suffix = \"mm\"\r\n        when 1 then val = dist_inch.to_cm; suffix = \"cm\"\r\n        when 2 then val = dist_inch.to_m;  suffix = \"m\"\r\n        end\r\n        sprintf(\"%.2f %s\", val, suffix)\r\n      end\r\n\r\n      def update_status_text\r\n        units = [\"mm\", \"cm\", \"m\"]\r\n        cur_unit = units[@unit_index]\r\n        Sketchup.set_status_text(sprintf(MedirParedes.obter_texto(:status_texto), cur_unit))\r\n      end\r\n\r\n      def trigger_update(view)\r\n        update_status_text\r\n        onMouseMove(0, @last_x, @last_y, view)\r\n      end\r\n\r\n      def calculate_raycast_hits(view, x, y)\r\n        ph = view.pick_helper\r\n        ph.do_pick(x, y)\r\n        path = ph.path_at(0)\r\n        return nil unless path && !path.empty?\r\n\r\n        face = path.reverse.find { |e| e.is_a?(Sketchup::Face) }\r\n        return nil unless face\r\n        return nil unless @ip.valid?\r\n        \r\n        click_world = @ip.position\r\n\r\n        insts = path.take_while { |e| e.is_a?(Sketchup::ComponentInstance) || e.is_a?(Sketchup::Group) }\r\n        t_world_from_ctx = Geom::Transformation.new\r\n        insts.each { |i| t_world_from_ctx *= i.transformation }\r\n\r\n        normal_local = face.normal\r\n        side_local = normal_local.cross(Z_AXIS)\r\n        side_local = X_AXIS.clone if !side_local.valid? || side_local.length < VEC_EPS\r\n        side_local.normalize!\r\n\r\n        if @rot_index > 0\r\n          angle = @rot_index * 90.degrees\r\n          tr_rot = Geom::Transformation.rotation(Geom::Point3d.new(0,0,0), normal_local, angle)\r\n          side_local.transform!(tr_rot)\r\n        end\r\n\r\n        side_world = side_local.transform(t_world_from_ctx)\r\n        return nil if !side_world.valid? || side_world.length < VEC_EPS\r\n        side_world.normalize!\r\n\r\n        p2_pos = global_raycast_recursive(click_world, side_world)\r\n        p2_neg = global_raycast_recursive(click_world, side_world.reverse)\r\n\r\n        [click_world, p2_pos, p2_neg]\r\n      end\r\n\r\n      def global_raycast_recursive(start_pt_world, vec_world)\r\n        return nil if vec_world.nil? || !vec_world.valid?\r\n        \r\n        current_origin = start_pt_world\r\n        model = Sketchup.active_model\r\n\r\n        100.times do\r\n          origin_offset = current_origin.offset(vec_world, EPS)\r\n          ray = [origin_offset, vec_world]\r\n          \r\n          result = model.raytest(ray, true) \r\n          \r\n          return nil unless result \r\n          \r\n          hit_point, hit_path = result\r\n\r\n          if is_full_path_visible?(hit_path)\r\n            return hit_point \r\n          else\r\n            current_origin = hit_point\r\n          end\r\n        end\r\n        \r\n        return nil \r\n      end\r\n\r\n      def is_full_path_visible?(path)\r\n        path.each do |ent|\r\n          return false if ent.respond_to?(:visible?) && !ent.visible?\r\n\r\n          if ent.respond_to?(:layer)\r\n            layer = ent.layer\r\n            if layer.is_a?(String)\r\n              l_obj = Sketchup.active_model.layers[layer]\r\n              return false if l_obj && !l_obj.visible?\r\n            elsif layer.respond_to?(:visible?)\r\n              return false unless layer.visible?\r\n            end\r\n          end\r\n        end\r\n        true\r\n      end\r\n\r\n    end\r\n  end\r\nend\r\n\r\nScriptUpComunidade::MedirParedes.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "tour-virtual-71uic",
    "title": {
      "pt": "Tour Virtual",
      "en": "Virtual Tour",
      "es": "Visita virtual"
    },
    "author": "F√°bio Coutinho",
    "version": "2.6",
    "description": {
      "pt": "Permite criar e gerenciar a cria√ß√£o de cenas em linha de tempo, v√°rias linhas de tempo, apresentar a transi√ß√£o entre elas de forma suave e sem impacto de troca de cena e exporta√ß√£o de v√≠deo com FFMPEG de forma r√°pida por captura de tela enquanto apresenta.",
      "en": "It allows you to create and manage timeline scenes, multiple timelines, present the transition between them smoothly and without scene change impact, and quickly export video with FFMPEG by screen capture while presenting.",
      "es": "Le permite crear y administrar escenas de l√≠nea de tiempo, m√∫ltiples l√≠neas de tiempo, presentar la transici√≥n entre ellas sin problemas y sin impacto en el cambio de escena, y exportar r√°pidamente video con FFMPEG mediante captura de pantalla mientras se presenta."
    },
    "keywords": {
      "pt": [
        "tour",
        "apresenta√ß√£o",
        "v√≠deo"
      ],
      "en": [
        "tour",
        "presentation",
        "video"
      ],
      "es": [
        "recorrido",
        "presentaci√≥n",
        "video"
      ]
    },
    "code": {
      "pt": "require 'json'\r\nrequire 'sketchup.rb'\r\nrequire 'base64'\r\nrequire 'tmpdir'\r\nrequire 'fiddle/import'\r\nrequire 'fileutils'\r\nrequire 'open3'\r\nrequire 'etc'\r\nrequire 'open-uri'\r\nif Sketchup.platform == :platform_win\r\n  require 'win32ole'\r\nend\r\n\r\nmodule ScriptUpComunidade\r\nmodule TourVirtual\r\n\r\n# --- Defini√ß√µes de Diret√≥rios ---\r\nplugins_root = Sketchup.find_support_file(\"Plugins\")\r\nPLUGIN_DIR = if plugins_root\r\n               File.expand_path(File.join(plugins_root, 'ScriptUp'))\r\n             else\r\n               File.expand_path(File.dirname(__FILE__))\r\n             end\r\n\r\nIDIOMAS = {\r\n  'pt-BR' => {\r\n    :status_clicar_arrastar  => \"CLIQUE E ARRASTE para definir a √°rea de grava√ß√£o do v√≠deo.\",\r\n    :area_pequena            => \"√Årea muito pequena. Tente novamente.\",\r\n    :selecionar_pasta        => \"Selecione a pasta para salvar\",\r\n    :ffmpeg_nao_encontrado   => \"FFmpeg n√£o encontrado.\",\r\n    :erro_gravador           => \"Erro ao iniciar gravador: \",\r\n    :gravacao_finalizada     => \"Grava√ß√£o finalizada!\\nSalvo em: \",\r\n    :ffmpeg_instalado        => \"FFmpeg instalado. Execute o Tour Virtual novamente.\",\r\n    :titulo_dialogo          => \"Tour Virtual\",\r\n    :ffmpeg_plugins_erro     => \"N√£o foi poss√≠vel resolver a pasta Plugins automaticamente.\",\r\n    :ffmpeg_instalar_em      => \"Instalar FFmpeg em:\",\r\n    :ffmpeg_origem           => \"Origem:\",\r\n    :ffmpeg_continuar        => \"Continuar?\",\r\n    :ffmpeg_cancelada        => \"Instala√ß√£o cancelada.\",\r\n    :ffmpeg_ja_existe        => \"J√° existe:\",\r\n    :ffmpeg_sobrescrever     => \"Deseja sobrescrever?\",\r\n    :ffmpeg_falha_expand     => \"Falha no Expand-Archive (PowerShell).\",\r\n    :ffmpeg_falha_unzip      => \"Falha no unzip (macOS).\",\r\n    :ffmpeg_exe_nao_encontrado => \"Execut√°vel ffmpeg n√£o encontrado no pacote baixado.\",\r\n    :ffmpeg_sucesso          => \"FFmpeg instalado com sucesso em:\",\r\n    :ffmpeg_falhou           => \"Falhou:\",\r\n    :ffmpeg_abrindo_nav      => \"Abrindo o link no navegador...\",\r\n    :titulo                  => \"Tour Virtual\",\r\n    :subtitulo               => \"Linha do Tempo\",\r\n    :total                   => \"Total:\",\r\n    :visao                   => \"Vis√£o\",\r\n    :play                    => \"Play\",\r\n    :stop                    => \"Stop\",\r\n    :play_all                => \"Play All\",\r\n    :stop_all                => \"Stop All\",\r\n    :atalho                  => \"Atalho\",\r\n    :pressione               => \"Pressione...\",\r\n    :ok                      => \"Ok\",\r\n    :loop                    => \"Loop\",\r\n    :easing                  => \"Easing\",\r\n    :visoes_salvas           => \"Vis√µes salvas\",\r\n    :gerenciar_timeline      => \"Gerenciar Time Line\",\r\n    :nova                    => \"Nova\",\r\n    :exportar_atual          => \"Exportar Atual\",\r\n    :exportar_projeto        => \"Exportar Projeto\",\r\n    :importar                => \"Importar\",\r\n    :exportar_video          => \"Exportar V√≠deo\",\r\n    :selecione_formato       => \"Selecione o formato‚Ä¶\",\r\n    :largura                 => \"Largura\",\r\n    :altura                  => \"Altura\",\r\n    :gravar_projeto          => \"Gravar todo o projeto (todas as Time Lines)\",\r\n    :iniciar_quadro1         => \"Iniciar do quadro 1\",\r\n    :iniciar_gravacao        => \"Iniciar Grava√ß√£o\",\r\n    :gravando                => \"Gravando...\",\r\n    :ffmpeg_necessario       => \"FFmpeg necess√°rio para gravar v√≠deo.\",\r\n    :instalar_ffmpeg         => \"Instalar FFmpeg\",\r\n    :nome_arquivo            => \"Nome do arquivo\",\r\n    :extensao_mp4            => \"A extens√£o .mp4 ser√° adicionada automaticamente.\",\r\n    :cancelar                => \"Cancelar\",\r\n    :salvar                  => \"Salvar\",\r\n    :viewport_atual          => \"Viewport atual:\",\r\n    :paisagem                => \"Paisagem\",\r\n    :retrato                 => \"Retrato\",\r\n    :quadrado                => \"Quadrado\",\r\n    :classico                => \"Cl√°ssico\",\r\n    :ultra_wide              => \"Ultra-wide\",\r\n    :viewport_inteira        => \"Viewport Inteira\",\r\n    :personalizado           => \"Personalizado\",\r\n    :nome_timeline           => \"Nome da Time Line:\",\r\n    :nenhuma_visao           => \"Nenhuma vis√£o adicionada.\",\r\n    :dica_visao              => \"Posicione a c√¢mera e clique em <b>+ Vis√£o</b>.\",\r\n    :ancora                  => \"√Çncora\",\r\n    :excluir                 => \"Excluir\",\r\n    :min_duas_visoes         => \"Adicione pelo menos duas vis√µes.\",\r\n    :sem_tl_2mais            => \"Nenhuma Time Line com 2+ vis√µes.\",\r\n    :sem_visoes_exportar     => \"Nenhuma vis√£o para exportar.\",\r\n    :sem_tl_exportar         => \"Nenhuma Time Line para exportar.\",\r\n    :importada               => \"Importada\",\r\n    :formato_invalido        => \"Formato inv√°lido.\",\r\n    :erro_importar           => \"Erro ao importar: \",\r\n    :visoes                  => \"vis√µes\",\r\n    :nova_timeline           => \"Nome da nova Time Line:\",\r\n    :area_gravacao           => \"√Årea de grava√ß√£o: \",\r\n    :sem_tl_min_duas         => \"Nenhuma Time Line com pelo menos duas vis√µes.\",\r\n    :dims_invalidas          => \"Dimens√µes inv√°lidas (m√≠nimo 50 x 50 px).\",\r\n    :digite_nome             => \"Digite um nome para o arquivo.\",\r\n  },\r\n  'en-US' => {\r\n    :status_clicar_arrastar  => \"CLICK AND DRAG to define the video recording area.\",\r\n    :area_pequena            => \"Area too small. Try again.\",\r\n    :selecionar_pasta        => \"Select folder to save\",\r\n    :ffmpeg_nao_encontrado   => \"FFmpeg not found.\",\r\n    :erro_gravador           => \"Error starting recorder: \",\r\n    :gravacao_finalizada     => \"Recording finished!\\nSaved to: \",\r\n    :ffmpeg_instalado        => \"FFmpeg installed. Run Virtual Tour again.\",\r\n    :titulo_dialogo          => \"Virtual Tour\",\r\n    :ffmpeg_plugins_erro     => \"Could not resolve the Plugins folder automatically.\",\r\n    :ffmpeg_instalar_em      => \"Install FFmpeg to:\",\r\n    :ffmpeg_origem           => \"Source:\",\r\n    :ffmpeg_continuar        => \"Continue?\",\r\n    :ffmpeg_cancelada        => \"Installation cancelled.\",\r\n    :ffmpeg_ja_existe        => \"Already exists:\",\r\n    :ffmpeg_sobrescrever     => \"Overwrite?\",\r\n    :ffmpeg_falha_expand     => \"Expand-Archive failed (PowerShell).\",\r\n    :ffmpeg_falha_unzip      => \"unzip failed (macOS).\",\r\n    :ffmpeg_exe_nao_encontrado => \"FFmpeg executable not found in downloaded package.\",\r\n    :ffmpeg_sucesso          => \"FFmpeg successfully installed to:\",\r\n    :ffmpeg_falhou           => \"Failed:\",\r\n    :ffmpeg_abrindo_nav      => \"Opening the link in browser...\",\r\n    :titulo                  => \"Virtual Tour\",\r\n    :subtitulo               => \"Timeline\",\r\n    :total                   => \"Total:\",\r\n    :visao                   => \"Vision\",\r\n    :play                    => \"Play\",\r\n    :stop                    => \"Stop\",\r\n    :play_all                => \"Play All\",\r\n    :stop_all                => \"Stop All\",\r\n    :atalho                  => \"Hotkey\",\r\n    :pressione               => \"Press a key...\",\r\n    :ok                      => \"Ok\",\r\n    :loop                    => \"Loop\",\r\n    :easing                  => \"Easing\",\r\n    :visoes_salvas           => \"Saved visions\",\r\n    :gerenciar_timeline      => \"Manage Timeline\",\r\n    :nova                    => \"New\",\r\n    :exportar_atual          => \"Export Current\",\r\n    :exportar_projeto        => \"Export Project\",\r\n    :importar                => \"Import\",\r\n    :exportar_video          => \"Export Video\",\r\n    :selecione_formato       => \"Select format‚Ä¶\",\r\n    :largura                 => \"Width\",\r\n    :altura                  => \"Height\",\r\n    :gravar_projeto          => \"Record entire project (all Timelines)\",\r\n    :iniciar_quadro1         => \"Start from frame 1\",\r\n    :iniciar_gravacao        => \"Start Recording\",\r\n    :gravando                => \"Recording...\",\r\n    :ffmpeg_necessario       => \"FFmpeg is required to record video.\",\r\n    :instalar_ffmpeg         => \"Install FFmpeg\",\r\n    :nome_arquivo            => \"File name\",\r\n    :extensao_mp4            => \"The .mp4 extension will be added automatically.\",\r\n    :cancelar                => \"Cancel\",\r\n    :salvar                  => \"Save\",\r\n    :viewport_atual          => \"Current viewport:\",\r\n    :paisagem                => \"Landscape\",\r\n    :retrato                 => \"Portrait\",\r\n    :quadrado                => \"Square\",\r\n    :classico                => \"Classic\",\r\n    :ultra_wide              => \"Ultra-wide\",\r\n    :viewport_inteira        => \"Full Viewport\",\r\n    :personalizado           => \"Custom\",\r\n    :nome_timeline           => \"Timeline name:\",\r\n    :nenhuma_visao           => \"No visions added.\",\r\n    :dica_visao              => \"Position the camera and click <b>+ Vision</b>.\",\r\n    :ancora                  => \"Anchor\",\r\n    :excluir                 => \"Delete\",\r\n    :min_duas_visoes         => \"Add at least two visions.\",\r\n    :sem_tl_2mais            => \"No Timeline with 2+ visions.\",\r\n    :sem_visoes_exportar     => \"No visions to export.\",\r\n    :sem_tl_exportar         => \"No Timeline to export.\",\r\n    :importada               => \"Imported\",\r\n    :formato_invalido        => \"Invalid format.\",\r\n    :erro_importar           => \"Import error: \",\r\n    :visoes                  => \"visions\",\r\n    :nova_timeline           => \"New Timeline name:\",\r\n    :area_gravacao           => \"Recording area: \",\r\n    :sem_tl_min_duas         => \"No Timeline with at least two visions.\",\r\n    :dims_invalidas          => \"Invalid dimensions (minimum 50 x 50 px).\",\r\n    :digite_nome             => \"Enter a file name.\",\r\n  },\r\n  'es' => {\r\n    :status_clicar_arrastar  => \"HAZ CLIC Y ARRASTRA para definir el √°rea de grabaci√≥n del video.\",\r\n    :area_pequena            => \"√Årea demasiado peque√±a. Int√©ntalo de nuevo.\",\r\n    :selecionar_pasta        => \"Selecciona la carpeta para guardar\",\r\n    :ffmpeg_nao_encontrado   => \"FFmpeg no encontrado.\",\r\n    :erro_gravador           => \"Error al iniciar grabador: \",\r\n    :gravacao_finalizada     => \"¬°Grabaci√≥n finalizada!\\nGuardado en: \",\r\n    :ffmpeg_instalado        => \"FFmpeg instalado. Ejecuta Tour Virtual de nuevo.\",\r\n    :titulo_dialogo          => \"Tour Virtual\",\r\n    :ffmpeg_plugins_erro     => \"No se pudo resolver la carpeta Plugins autom√°ticamente.\",\r\n    :ffmpeg_instalar_em      => \"Instalar FFmpeg en:\",\r\n    :ffmpeg_origem           => \"Origen:\",\r\n    :ffmpeg_continuar        => \"¬øContinuar?\",\r\n    :ffmpeg_cancelada        => \"Instalaci√≥n cancelada.\",\r\n    :ffmpeg_ja_existe        => \"Ya existe:\",\r\n    :ffmpeg_sobrescrever     => \"¬øSobrescribir?\",\r\n    :ffmpeg_falha_expand     => \"Error en Expand-Archive (PowerShell).\",\r\n    :ffmpeg_falha_unzip      => \"Error en unzip (macOS).\",\r\n    :ffmpeg_exe_nao_encontrado => \"Ejecutable FFmpeg no encontrado en el paquete descargado.\",\r\n    :ffmpeg_sucesso          => \"FFmpeg instalado con √©xito en:\",\r\n    :ffmpeg_falhou           => \"Fall√≥:\",\r\n    :ffmpeg_abrindo_nav      => \"Abriendo el enlace en el navegador...\",\r\n    :titulo                  => \"Tour Virtual\",\r\n    :subtitulo               => \"L√≠nea de Tiempo\",\r\n    :total                   => \"Total:\",\r\n    :visao                   => \"Visi√≥n\",\r\n    :play                    => \"Play\",\r\n    :stop                    => \"Stop\",\r\n    :play_all                => \"Play All\",\r\n    :stop_all                => \"Stop All\",\r\n    :atalho                  => \"Atajo\",\r\n    :pressione               => \"Presiona...\",\r\n    :ok                      => \"Ok\",\r\n    :loop                    => \"Loop\",\r\n    :easing                  => \"Easing\",\r\n    :visoes_salvas           => \"Visiones guardadas\",\r\n    :gerenciar_timeline      => \"Gestionar L√≠nea de Tiempo\",\r\n    :nova                    => \"Nueva\",\r\n    :exportar_atual          => \"Exportar Actual\",\r\n    :exportar_projeto        => \"Exportar Proyecto\",\r\n    :importar                => \"Importar\",\r\n    :exportar_video          => \"Exportar Video\",\r\n    :selecione_formato       => \"Selecciona el formato‚Ä¶\",\r\n    :largura                 => \"Ancho\",\r\n    :altura                  => \"Alto\",\r\n    :gravar_projeto          => \"Grabar todo el proyecto (todas las L√≠neas de Tiempo)\",\r\n    :iniciar_quadro1         => \"Iniciar desde el cuadro 1\",\r\n    :iniciar_gravacao        => \"Iniciar Grabaci√≥n\",\r\n    :gravando                => \"Grabando...\",\r\n    :ffmpeg_necessario       => \"FFmpeg necesario para grabar video.\",\r\n    :instalar_ffmpeg         => \"Instalar FFmpeg\",\r\n    :nome_arquivo            => \"Nombre del archivo\",\r\n    :extensao_mp4            => \"La extensi√≥n .mp4 se a√±adir√° autom√°ticamente.\",\r\n    :cancelar                => \"Cancelar\",\r\n    :salvar                  => \"Guardar\",\r\n    :viewport_atual          => \"Viewport actual:\",\r\n    :paisagem                => \"Paisaje\",\r\n    :retrato                 => \"Retrato\",\r\n    :quadrado                => \"Cuadrado\",\r\n    :classico                => \"Cl√°sico\",\r\n    :ultra_wide              => \"Ultra-wide\",\r\n    :viewport_inteira        => \"Viewport Completa\",\r\n    :personalizado           => \"Personalizado\",\r\n    :nome_timeline           => \"Nombre de la L√≠nea de Tiempo:\",\r\n    :nenhuma_visao           => \"Ninguna visi√≥n a√±adida.\",\r\n    :dica_visao              => \"Posiciona la c√°mara y haz clic en <b>+ Visi√≥n</b>.\",\r\n    :ancora                  => \"Ancla\",\r\n    :excluir                 => \"Eliminar\",\r\n    :min_duas_visoes         => \"A√±ade al menos dos visiones.\",\r\n    :sem_tl_2mais            => \"Ninguna L√≠nea de Tiempo con 2+ visiones.\",\r\n    :sem_visoes_exportar     => \"Ninguna visi√≥n para exportar.\",\r\n    :sem_tl_exportar         => \"Ninguna L√≠nea de Tiempo para exportar.\",\r\n    :importada               => \"Importada\",\r\n    :formato_invalido        => \"Formato inv√°lido.\",\r\n    :erro_importar           => \"Error al importar: \",\r\n    :visoes                  => \"visiones\",\r\n    :nova_timeline           => \"Nombre de la nueva L√≠nea de Tiempo:\",\r\n    :area_gravacao           => \"√Årea de grabaci√≥n: \",\r\n    :sem_tl_min_duas         => \"Ninguna L√≠nea de Tiempo con al menos dos visiones.\",\r\n    :dims_invalidas          => \"Dimensiones inv√°lidas (m√≠nimo 50 x 50 px).\",\r\n    :digite_nome             => \"Escribe un nombre para el archivo.\",\r\n  },\r\n}\r\n\r\ndef self.obter_texto(chave)\r\n  locale = Sketchup.get_locale\r\n  lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n  IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\nend\r\n\r\n# --- Script de Instala√ß√£o do FFmpeg (Mantido) ---\r\nFFMPEG_INSTALL_SCRIPT ||= <<~'RUBY'\r\n  require 'sketchup'\r\n  require 'open-uri'\r\n  require 'fileutils'\r\n  require 'tmpdir'\r\n\r\n  URL_WIN ||= 'https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-master-latest-win64-gpl.zip'\r\n  URL_MAC ||= 'https://evermeet.cx/ffmpeg/getrelease/zip'\r\n\r\n  win = Sketchup.platform == :platform_win\r\n  major = Sketchup.version.to_s[/^\\d+/].to_i\r\n  sketchup_year = 2000 + major\r\n\r\n  plugins_dir = Sketchup.find_support_file('Plugins')\r\n  if !plugins_dir || plugins_dir.empty? || !Dir.exist?(plugins_dir)\r\n    if win\r\n      base = ENV['APPDATA'].to_s\r\n      plugins_dir = File.join(base, 'SketchUp', \"SketchUp #{sketchup_year}\", 'SketchUp', 'Plugins')\r\n    else\r\n      plugins_dir = File.expand_path(\"~/Library/Application Support/SketchUp #{sketchup_year}/SketchUp/Plugins\")\r\n    end\r\n  end\r\n\r\n  target_dir = File.join(plugins_dir, 'ScriptUp', 'ffmpeg')\r\n  target_exe = File.join(target_dir, win ? 'ffmpeg.exe' : 'ffmpeg')\r\n  url = win ? URL_WIN : URL_MAC\r\n  default_zip_name = win ? 'ffmpeg-win64-gpl-latest.zip' : 'ffmpeg-macos-release.zip'\r\n\r\n  proceed = true\r\n\r\n  unless plugins_dir && !plugins_dir.empty?\r\n    UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_plugins_erro))\r\n    proceed = false\r\n  end\r\n\r\n  if proceed\r\n    msg = \"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_instalar_em)}\\n#{target_dir}\\n\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_origem)}\\n#{url}\\n\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_continuar)}\"\r\n    if UI.messagebox(msg, MB_YESNO) != IDYES\r\n      UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_cancelada))\r\n      proceed = false\r\n    end\r\n  end\r\n\r\n  if proceed && File.exist?(target_exe)\r\n    overwrite = UI.messagebox(\"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_ja_existe)}\\n#{target_exe}\\n\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_sobrescrever)}\", MB_YESNO)\r\n    if overwrite != IDYES\r\n      UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_cancelada))\r\n      proceed = false\r\n    end\r\n  end\r\n\r\n  if proceed\r\n    Dir.mktmpdir('ffmpeg_dl_') do |tmp|\r\n      zip_path = File.join(tmp, default_zip_name)\r\n      extract_dir = File.join(tmp, 'unzipped')\r\n      begin\r\n        URI.open(url, 'rb') do |io|\r\n          File.open(zip_path, 'wb') { |f| IO.copy_stream(io, f) }\r\n        end\r\n        Dir.mkdir(extract_dir)\r\n        if win\r\n          ps = 'powershell -NoProfile -ExecutionPolicy Bypass -Command'\r\n          cmd = \"#{ps} \\\"Expand-Archive -LiteralPath '#{zip_path}' -DestinationPath '#{extract_dir}' -Force\\\"\"\r\n          ok = system(cmd)\r\n          raise ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_falha_expand) unless ok\r\n        else\r\n          ok = system(\"unzip -o -q '#{zip_path}' -d '#{extract_dir}'\")\r\n          raise ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_falha_unzip) unless ok\r\n        end\r\n\r\n        pattern = win ? '**/ffmpeg.exe' : '**/ffmpeg'\r\n        bin = Dir.glob(File.join(extract_dir, pattern)).find { |p| File.file?(p) }\r\n        raise ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_exe_nao_encontrado) unless bin\r\n\r\n        FileUtils.mkdir_p(target_dir) unless Dir.exist?(target_dir)\r\n        FileUtils.cp(bin, target_exe)\r\n        unless win\r\n          FileUtils.chmod(0o755, target_exe)\r\n          system(\"xattr -d com.apple.quarantine '#{target_exe}' 2>/dev/null\")\r\n        end\r\n\r\n        UI.messagebox(\"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_sucesso)}\\n#{target_exe}\")\r\n        puts \"OK: #{target_exe}\"\r\n      rescue => e\r\n        UI.messagebox(\"#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_falhou)} #{e.message}\\n#{ScriptUpComunidade::TourVirtual.obter_texto(:ffmpeg_abrindo_nav)}\")\r\n        UI.openURL(url)\r\n      end\r\n    end\r\n  end\r\nRUBY\r\n\r\n# --- M√≥dulo WindowUtils ---\r\nmodule WindowUtils\r\n  extend Fiddle::Importer\r\n  dlload 'user32.dll' if Sketchup.platform == :platform_win\r\n\r\n  if Sketchup.platform == :platform_win\r\n    typealias 'HWND', 'void*'\r\n    extern 'HWND GetActiveWindow()'\r\n    extern 'HWND GetForegroundWindow()'\r\n    extern 'HWND GetWindow(HWND, int)'\r\n    extern 'int GetWindowRect(HWND, void*)'\r\n    extern 'HWND GetParent(HWND)'\r\n    \r\n    GW_CHILD = 5\r\n    GW_HWNDNEXT = 2\r\n    Rect = struct ['long left', 'long top', 'long right', 'long bottom']\r\n  end\r\n\r\n  def self.get_viewport_rect_deep(view)\r\n    return nil unless Sketchup.platform == :platform_win\r\n    \r\n    hwnd = GetForegroundWindow()\r\n    return nil if hwnd.nil? || hwnd == 0\r\n\r\n    vw = view.vpwidth\r\n    vh = view.vpheight\r\n    \r\n    found = find_recursive(hwnd, vw, vh)\r\n    return found if found\r\n\r\n    parent = GetParent(hwnd)\r\n    if parent && parent != 0\r\n      found = find_recursive(parent, vw, vh)\r\n      return found if found\r\n    end\r\n\r\n    nil\r\n  end\r\n\r\n  def self.find_recursive(parent_hwnd, target_w, target_h)\r\n    child = GetWindow(parent_hwnd, GW_CHILD)\r\n    while child && child.to_i != 0\r\n      rect = Rect.malloc\r\n      if GetWindowRect(child, rect) != 0\r\n        w = rect.right - rect.left\r\n        h = rect.bottom - rect.top\r\n        match = check_match(w, h, target_w, target_h, rect)\r\n        return match if match\r\n      end\r\n      found_in_child = find_recursive(child, target_w, target_h)\r\n      return found_in_child if found_in_child\r\n      child = GetWindow(child, GW_HWNDNEXT)\r\n    end\r\n    nil\r\n  end\r\n\r\n  def self.check_match(w, h, target_w, target_h, rect)\r\n    tol = 30\r\n    [1.0, 1.25, 1.5, 2.0].each do |scale|\r\n      if (w - target_w * scale).abs <= tol && (h - target_h * scale).abs <= tol\r\n        return { :x => rect.left, :y => rect.top, :w => w, :h => h, :scale => scale }\r\n      end\r\n    end\r\n    nil\r\n  end\r\nend\r\n\r\n# --- M√≥dulo ScreenCapture (GDI32) ---\r\n# Captures the SketchUp viewport via Win32 GDI and produces a BMP thumbnail\r\n# encoded as Base64, suitable for embedding in an HTML <img> tag.\r\n#\r\n# Uses Fiddle::Importer (Ruby stdlib) to call gdi32.dll and user32.dll functions.\r\n# Also declares PrintWindow from user32.dll as a fallback for occluded windows.\r\n#\r\n# Fiddle type mapping reference (from fiddle/types.rb Win32Types):\r\n#   HANDLE / HDC / HWND / HBITMAP  ->  void*   (pointer-sized, correct for 32/64-bit)\r\n#   DWORD                          ->  unsigned long\r\n#   BOOL                           ->  int\r\n#   UINT                           ->  unsigned int\r\n#\r\n# The extern signatures below use 'void*' directly for all handle types\r\n# (HDC, HBITMAP, HGDIOBJ) so we do not need to include Fiddle::Win32Types\r\n# or add custom typealiases beyond what WindowUtils already defines.\r\nmodule ScreenCapture\r\n  extend Fiddle::Importer\r\n\r\n  if Sketchup.platform == :platform_win\r\n    dlload 'gdi32.dll', 'user32.dll'\r\n\r\n    # --- user32.dll functions ---\r\n    # HDC GetDC(HWND hWnd)\r\n    #   hWnd=NULL(0) returns DC for entire screen\r\n    extern 'void* GetDC(void*)'\r\n\r\n    # int ReleaseDC(HWND hWnd, HDC hDC)\r\n    extern 'int ReleaseDC(void*, void*)'\r\n\r\n    # BOOL PrintWindow(HWND hwnd, HDC hdcBlt, UINT nFlags)\r\n    #   Asks the window to paint itself into the given DC.\r\n    #   Works even when the window is partially occluded (unlike BitBlt from screen DC).\r\n    extern 'int PrintWindow(void*, void*, unsigned int)'\r\n\r\n    # --- gdi32.dll functions ---\r\n    # HDC CreateCompatibleDC(HDC hdc)\r\n    extern 'void* CreateCompatibleDC(void*)'\r\n\r\n    # HBITMAP CreateCompatibleBitmap(HDC hdc, int cx, int cy)\r\n    extern 'void* CreateCompatibleBitmap(void*, int, int)'\r\n\r\n    # HGDIOBJ SelectObject(HDC hdc, HGDIOBJ h)\r\n    extern 'void* SelectObject(void*, void*)'\r\n\r\n    # BOOL BitBlt(HDC hdc, int x, int y, int cx, int cy,\r\n    #             HDC hdcSrc, int x1, int y1, DWORD rop)\r\n    extern 'int BitBlt(void*, int, int, int, int, void*, int, int, unsigned long)'\r\n\r\n    # BOOL StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest,\r\n    #                 HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop)\r\n    extern 'int StretchBlt(void*, int, int, int, int, void*, int, int, int, int, unsigned long)'\r\n\r\n    # int SetStretchBltMode(HDC hdc, int mode)\r\n    extern 'int SetStretchBltMode(void*, int)'\r\n\r\n    # int GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines,\r\n    #               LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage)\r\n    #   lpvBits and lpbmi are both void* (raw pointers to caller-allocated buffers)\r\n    extern 'int GetDIBits(void*, void*, unsigned int, unsigned int, void*, void*, unsigned int)'\r\n\r\n    # BOOL DeleteDC(HDC hdc)\r\n    extern 'int DeleteDC(void*)'\r\n\r\n    # BOOL DeleteObject(HGDIOBJ ho)\r\n    extern 'int DeleteObject(void*)'\r\n\r\n    # --- Raster-operation and mode constants ---\r\n    SRCCOPY        = 0x00CC0020\r\n    HALFTONE       = 4          # SetStretchBltMode mode for high-quality shrinking\r\n    DIB_RGB_COLORS = 0          # GetDIBits color table usage\r\n\r\n    # --- PrintWindow flags ---\r\n    PW_CLIENTONLY          = 0x00000001  # capture client area only (no title bar)\r\n    PW_RENDERFULLCONTENT   = 0x00000002  # Win 8.1+: captures DirectX/DWM content\r\n  end\r\n\r\n  # Build a 40-byte BITMAPINFOHEADER as a packed binary string.\r\n  #\r\n  # The BITMAPINFOHEADER struct layout (40 bytes total):\r\n  #   DWORD  biSize          (4 bytes, unsigned 32-bit LE)   = 40\r\n  #   LONG   biWidth         (4 bytes, signed   32-bit LE)\r\n  #   LONG   biHeight        (4 bytes, signed   32-bit LE)   negative = top-down DIB\r\n  #   WORD   biPlanes        (2 bytes, unsigned 16-bit LE)   = 1\r\n  #   WORD   biBitCount      (2 bytes, unsigned 16-bit LE)   = 24 for RGB\r\n  #   DWORD  biCompression   (4 bytes, unsigned 32-bit LE)   = 0 (BI_RGB)\r\n  #   DWORD  biSizeImage     (4 bytes, unsigned 32-bit LE)\r\n  #   LONG   biXPelsPerMeter (4 bytes, signed   32-bit LE)   = 0\r\n  #   LONG   biYPelsPerMeter (4 bytes, signed   32-bit LE)   = 0\r\n  #   DWORD  biClrUsed       (4 bytes, unsigned 32-bit LE)   = 0\r\n  #   DWORD  biClrImportant  (4 bytes, unsigned 32-bit LE)   = 0\r\n  #\r\n  # Pack template: 'L<' = uint32 LE, 'l<' = int32 LE, 'S<' = uint16 LE\r\n  # Combined: 'L< l< l< S< S< L< L< l< l< L< L<'  (spaces for clarity)\r\n  #\r\n  # Using negative biHeight produces a top-down DIB, which means:\r\n  #  - Row 0 in memory is the top row of the image\r\n  #  - No vertical flip is needed when writing the BMP file\r\n  #  - The BMP file header must also use the negative height to match\r\n  def self.pack_bitmapinfoheader(width, height, image_size)\r\n    [\r\n      40,           # biSize\r\n      width,        # biWidth\r\n      -height,      # biHeight (negative = top-down)\r\n      1,            # biPlanes\r\n      24,           # biBitCount (24-bit RGB)\r\n      0,            # biCompression (BI_RGB = uncompressed)\r\n      image_size,   # biSizeImage\r\n      0,            # biXPelsPerMeter\r\n      0,            # biYPelsPerMeter\r\n      0,            # biClrUsed\r\n      0             # biClrImportant\r\n    ].pack('L<l<l<S<S<L<L<l<l<L<L<')\r\n  end\r\n\r\n  # Build the 14-byte BMP file header (BITMAPFILEHEADER).\r\n  #\r\n  # Layout:\r\n  #   WORD   bfType      = 0x4D42 (\"BM\")\r\n  #   DWORD  bfSize      = total file size in bytes\r\n  #   WORD   bfReserved1 = 0\r\n  #   WORD   bfReserved2 = 0\r\n  #   DWORD  bfOffBits   = offset to pixel data = 14 + 40 = 54\r\n  #\r\n  # Pack template: 'S< L< S< S< L<'\r\n  def self.pack_bmp_file_header(pixel_data_size)\r\n    file_size = 14 + 40 + pixel_data_size\r\n    [\r\n      0x4D42,       # bfType (\"BM\")\r\n      file_size,    # bfSize\r\n      0,            # bfReserved1\r\n      0,            # bfReserved2\r\n      54            # bfOffBits (14-byte file header + 40-byte info header)\r\n    ].pack('S<L<S<S<L<')\r\n  end\r\n\r\n  # Capture the SketchUp viewport as a scaled-down BMP thumbnail and return\r\n  # a Base64-encoded string. Returns nil on failure (non-Windows, HWND not found, etc.).\r\n  #\r\n  # Strategy:\r\n  #   1. StretchBlt from screen DC (fast, works when viewport is visible)\r\n  #   2. If vp[:hwnd] is available, PrintWindow can be used as alternative\r\n  #\r\n  # Parameters:\r\n  #   view     - Sketchup::View instance\r\n  #   thumb_w  - desired thumbnail width  in pixels (default 96)\r\n  #   thumb_h  - desired thumbnail height in pixels (default 60)\r\n  #\r\n  # Returns: Base64-encoded BMP string, or nil on failure.\r\n  def self.capture_viewport(view, thumb_w = 96, thumb_h = 60)\r\n    return nil unless Sketchup.platform == :platform_win\r\n\r\n    vp = WindowUtils.get_viewport_rect_deep(view)\r\n    return nil unless vp\r\n\r\n    src_w = vp[:w]\r\n    src_h = vp[:h]\r\n\r\n    # Get screen DC -- needed for CreateCompatibleBitmap color depth\r\n    screen_dc = GetDC(0)\r\n    return nil if screen_dc.nil? || screen_dc.to_i == 0\r\n\r\n    begin\r\n      # Create a memory DC compatible with the screen\r\n      mem_dc = CreateCompatibleDC(screen_dc)\r\n      return nil if mem_dc.nil? || mem_dc.to_i == 0\r\n\r\n      begin\r\n        # Create a bitmap at the desired thumbnail size\r\n        bmp = CreateCompatibleBitmap(screen_dc, thumb_w, thumb_h)\r\n        return nil if bmp.nil? || bmp.to_i == 0\r\n\r\n        begin\r\n          old = SelectObject(mem_dc, bmp)\r\n          SetStretchBltMode(mem_dc, HALFTONE)\r\n\r\n          # StretchBlt from the screen DC directly into the thumbnail-sized bitmap.\r\n          # This both captures AND scales in a single operation.\r\n          ok = StretchBlt(\r\n            mem_dc, 0, 0, thumb_w, thumb_h,\r\n            screen_dc, vp[:x], vp[:y], src_w, src_h,\r\n            SRCCOPY\r\n          )\r\n          return nil if ok == 0\r\n\r\n          # IMPORTANT: Deselect the bitmap from the DC before calling GetDIBits.\r\n          # Per MSDN: \"The bitmap identified by hbmp must not be selected into\r\n          # a device context when the application calls this function.\"\r\n          SelectObject(mem_dc, old)\r\n          old = nil\r\n\r\n          # Calculate row stride (BMP rows must be padded to 4-byte boundaries)\r\n          stride     = ((thumb_w * 3 + 3) & ~3)\r\n          pixel_size = stride * thumb_h\r\n\r\n          # Pack the BITMAPINFOHEADER into a Fiddle::Pointer buffer.\r\n          # GetDIBits may modify the header (e.g., filling in biSizeImage),\r\n          # so we use a mutable native buffer rather than a Ruby String.\r\n          bmi_bytes = pack_bitmapinfoheader(thumb_w, thumb_h, pixel_size)\r\n          bmi_ptr   = Fiddle::Pointer.malloc(bmi_bytes.bytesize)\r\n          bmi_ptr[0, bmi_bytes.bytesize] = bmi_bytes\r\n\r\n          # Allocate the pixel data buffer\r\n          buf = Fiddle::Pointer.malloc(pixel_size)\r\n\r\n          begin\r\n            # GetDIBits(hdc, hbm, start, cLines, lpvBits, lpbmi, usage)\r\n            # hdc: a DC compatible with the bitmap (mem_dc works)\r\n            # hbm: the bitmap handle (NOT selected into any DC)\r\n            rows = GetDIBits(mem_dc, bmp, 0, thumb_h, buf, bmi_ptr, DIB_RGB_COLORS)\r\n            return nil if rows == 0\r\n\r\n            # Read the raw pixel bytes from the Fiddle::Pointer buffer.\r\n            # ptr[offset, length] returns a Ruby String (binary safe, works since Ruby 2.0).\r\n            pixel_data = buf[0, pixel_size]\r\n\r\n            # Assemble the complete BMP file: file header + info header + pixel data\r\n            file_hdr = pack_bmp_file_header(pixel_size)\r\n            info_hdr = pack_bitmapinfoheader(thumb_w, thumb_h, pixel_size)\r\n\r\n            Base64.strict_encode64(file_hdr + info_hdr + pixel_data)\r\n          ensure\r\n            Fiddle.free(bmi_ptr) if bmi_ptr\r\n            Fiddle.free(buf)     if buf\r\n          end\r\n        ensure\r\n          SelectObject(mem_dc, old) if old\r\n          DeleteObject(bmp)\r\n        end\r\n      ensure\r\n        DeleteDC(mem_dc)\r\n      end\r\n    ensure\r\n      ReleaseDC(0, screen_dc)\r\n    end\r\n  rescue => e\r\n    puts \"ScreenCapture error: #{e.message}\"\r\n    puts e.backtrace.first(5).join(\"\\n\")\r\n    nil\r\n  end\r\nend\r\n\r\nmodule TourPlugin\r\n  class AreaSelectorTool\r\n    def initialize(callback)\r\n      @callback = callback\r\n      @start_x = nil; @start_y = nil; @current_x = nil; @current_y = nil\r\n      @drawing = false\r\n    end\r\n\r\n    def activate\r\n      Sketchup.active_model.active_view.invalidate\r\n      Sketchup.status_text = ScriptUpComunidade::TourVirtual.obter_texto(:status_clicar_arrastar)\r\n    end\r\n\r\n    def onLButtonDown(flags, x, y, view)\r\n      @start_x = x; @start_y = y; @current_x = x; @current_y = y\r\n      @drawing = true\r\n    end\r\n\r\n    def onMouseMove(flags, x, y, view)\r\n      if @drawing\r\n        @current_x = x; @current_y = y\r\n        view.invalidate\r\n      end\r\n    end\r\n\r\n    def onLButtonUp(flags, x, y, view)\r\n      return unless @drawing\r\n      @drawing = false\r\n      x1 = [@start_x, @current_x].min\r\n      y1 = [@start_y, @current_y].min\r\n      x2 = [@start_x, @current_x].max\r\n      y2 = [@start_y, @current_y].max\r\n      width = x2 - x1\r\n      height = y2 - y1\r\n\r\n      if width < 50 || height < 50\r\n        UI.messagebox(ScriptUpComunidade::TourVirtual.obter_texto(:area_pequena))\r\n        Sketchup.active_model.select_tool(nil)\r\n        return\r\n      end\r\n\r\n      @callback.call({ :x => x1, :y => y1, :w => width, :h => height })\r\n      Sketchup.active_model.select_tool(nil) \r\n    end\r\n\r\n    def draw(view)\r\n      return unless @drawing && @start_x && @current_x\r\n      points = [\r\n        Geom::Point3d.new(@start_x, @start_y, 0),\r\n        Geom::Point3d.new(@current_x, @start_y, 0),\r\n        Geom::Point3d.new(@current_x, @current_y, 0),\r\n        Geom::Point3d.new(@start_x, @current_y, 0)\r\n      ]\r\n      view.line_width = 3\r\n      view.drawing_color = 'red'\r\n      view.draw2d(GL_LINE_LOOP, points)\r\n    end\r\n  end\r\n\r\n  class ExportPreviewTool\r\n    def initialize(target_w, target_h)\r\n      @target_w = target_w\r\n      @target_h = target_h\r\n    end\r\n\r\n    def activate\r\n      Sketchup.active_model.active_view.invalidate\r\n    end\r\n\r\n    def deactivate(view)\r\n      view.invalidate\r\n    end\r\n\r\n    def draw(view)\r\n      vw = view.vpwidth\r\n      vh = view.vpheight\r\n      ew = [@target_w, vw].min\r\n      eh = [@target_h, vh].min\r\n      ox = (vw - ew) / 2\r\n      oy = (vh - eh) / 2\r\n\r\n      # Escurecer √°reas fora da grava√ß√£o (letterbox/pillarbox)\r\n      view.drawing_color = Sketchup::Color.new(0, 0, 0, 120)\r\n      if oy > 0\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(0, 0, 0), Geom::Point3d.new(vw, 0, 0),\r\n          Geom::Point3d.new(vw, oy, 0), Geom::Point3d.new(0, oy, 0)\r\n        ])\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(0, oy + eh, 0), Geom::Point3d.new(vw, oy + eh, 0),\r\n          Geom::Point3d.new(vw, vh, 0), Geom::Point3d.new(0, vh, 0)\r\n        ])\r\n      end\r\n      if ox > 0\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(0, oy, 0), Geom::Point3d.new(ox, oy, 0),\r\n          Geom::Point3d.new(ox, oy + eh, 0), Geom::Point3d.new(0, oy + eh, 0)\r\n        ])\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(ox + ew, oy, 0), Geom::Point3d.new(vw, oy, 0),\r\n          Geom::Point3d.new(vw, oy + eh, 0), Geom::Point3d.new(ox + ew, oy + eh, 0)\r\n        ])\r\n      end\r\n\r\n      # Borda branca ao redor da √°rea de grava√ß√£o\r\n      view.line_width = 2\r\n      view.drawing_color = Sketchup::Color.new(255, 255, 255, 200)\r\n      view.draw2d(GL_LINE_LOOP, [\r\n        Geom::Point3d.new(ox, oy, 0), Geom::Point3d.new(ox + ew, oy, 0),\r\n        Geom::Point3d.new(ox + ew, oy + eh, 0), Geom::Point3d.new(ox, oy + eh, 0)\r\n      ])\r\n    end\r\n  end\r\n\r\n  module CameraTimeline\r\n    def self.obter_texto(chave)\r\n      ScriptUpComunidade::TourVirtual.obter_texto(chave)\r\n    end\r\n\r\n    module GlobalKey\r\n      extend Fiddle::Importer\r\n      if Sketchup.platform == :platform_win\r\n        dlload 'user32.dll'\r\n        extern 'short GetAsyncKeyState(int)'\r\n      else\r\n        dlload '/System/Library/Frameworks/ApplicationServices.framework/ApplicationServices'\r\n        extern 'bool CGEventSourceKeyState(int, int)'\r\n      end\r\n\r\n      DEFAULT_HOTKEY = Sketchup.platform == :platform_win ? 0x6B : 69\r\n      @key_code = Sketchup.read_default(\"TourVirtual\", \"Hotkey\", DEFAULT_HOTKEY).to_i\r\n      @ctrl = Sketchup.read_default(\"TourVirtual\", \"HotkeyCtrl\", false)\r\n      @alt = Sketchup.read_default(\"TourVirtual\", \"HotkeyAlt\", false)\r\n      @shift = Sketchup.read_default(\"TourVirtual\", \"HotkeyShift\", false)\r\n\r\n      # Windows virtual key codes for modifiers\r\n      VK_CONTROL = 0x11\r\n      VK_MENU    = 0x12\r\n      VK_SHIFT   = 0x10\r\n      # macOS key codes for modifiers\r\n      MAC_CTRL  = 59\r\n      MAC_SHIFT = 56\r\n      MAC_ALT   = 58\r\n\r\n      def self.set_hotkey(code, ctrl, alt, shift)\r\n        @key_code = code.to_i\r\n        @ctrl = ctrl\r\n        @alt = alt\r\n        @shift = shift\r\n      end\r\n\r\n      def self.key_code; @key_code; end\r\n      def self.ctrl; @ctrl; end\r\n      def self.alt; @alt; end\r\n      def self.shift; @shift; end\r\n\r\n      def self.key_pressed?(code)\r\n        if Sketchup.platform == :platform_win\r\n          GetAsyncKeyState(code) & 0x8000 != 0\r\n        else\r\n          CGEventSourceKeyState(0, code)\r\n        end\r\n      end\r\n\r\n      def self.space_pressed?\r\n        return false unless key_pressed?(@key_code)\r\n        if Sketchup.platform == :platform_win\r\n          return false if @ctrl && !key_pressed?(VK_CONTROL)\r\n          return false if @alt && !key_pressed?(VK_MENU)\r\n          return false if @shift && !key_pressed?(VK_SHIFT)\r\n        else\r\n          return false if @ctrl && !key_pressed?(MAC_CTRL)\r\n          return false if @alt && !key_pressed?(MAC_ALT)\r\n          return false if @shift && !key_pressed?(MAC_SHIFT)\r\n        end\r\n        true\r\n      end\r\n    end\r\n\r\n    def self.start_space_timer\r\n      return if defined?(@space_timer) && @space_timer\r\n      @space_down = false\r\n      @space_timer = UI.start_timer(0.1, true) do\r\n        if GlobalKey.space_pressed?\r\n          unless @space_down\r\n            @space_down = true\r\n            @dialog.execute_script('triggerSpaceFromRuby()')\r\n          end\r\n        else\r\n          @space_down = false\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.stop_space_timer\r\n      if defined?(@space_timer) && @space_timer\r\n        UI.stop_timer(@space_timer)\r\n        @space_timer = nil\r\n      end\r\n    end\r\n\r\n    def self.capture_thumbnail\r\n      view = Sketchup.active_model.active_view\r\n      # Tentar screen capture instant√¢neo via GDI32 (Windows)\r\n      result = ScreenCapture.capture_viewport(view, 96, 60) rescue nil\r\n      return result if result && result.length > 0\r\n      # Fallback: write_image (lento, mas funciona em qualquer plataforma)\r\n      path = File.join(Dir.tmpdir, \"thumb_#{Time.now.to_i}.jpg\")\r\n      view.write_image(path, 96, 60, false, 0.5)\r\n      encoded = Base64.strict_encode64(File.binread(path))\r\n      File.delete(path) if File.exist?(path)\r\n      encoded\r\n    end\r\n\r\n    # --- L√≥gica de Exporta√ß√£o ---\r\n    def self.calcular_rect_gravacao(export_width, export_height)\r\n      view = Sketchup.active_model.active_view\r\n      viewport_global = WindowUtils.get_viewport_rect_deep(view)\r\n\r\n      unless viewport_global\r\n        viewport_global = { :x => 0, :y => 0, :w => view.vpwidth, :h => view.vpheight, :scale => 1.0 }\r\n      end\r\n\r\n      vp_w = viewport_global[:w]\r\n      vp_h = viewport_global[:h]\r\n\r\n      final_w = [export_width.to_i, vp_w].min\r\n      final_h = [export_height.to_i, vp_h].min\r\n\r\n      offset_x = viewport_global[:x] + ((vp_w - final_w) / 2).to_i\r\n      offset_y = viewport_global[:y] + ((vp_h - final_h) / 2).to_i\r\n\r\n      final_w -= 1 if final_w.odd?\r\n      final_h -= 1 if final_h.odd?\r\n\r\n      { :x => offset_x, :y => offset_y, :w => final_w, :h => final_h }\r\n    end\r\n\r\n    def self.iniciar_processo_exportacao(json_data, use_easing, start_index_from_js, export_width, export_height, filename)\r\n      effective_index = start_index_from_js.to_i\r\n\r\n      if effective_index == 0\r\n        @dialog.execute_script(\"currentIndex = 0; updateTime(0); sketchup.goto_camera(JSON.stringify(visoes[0]));\")\r\n        sleep(0.5)\r\n      end\r\n\r\n      rect = calcular_rect_gravacao(export_width, export_height)\r\n      executar_gravacao_ffmpeg(json_data, use_easing, rect, effective_index, filename)\r\n    end\r\n\r\n    def self.iniciar_processo_exportacao_projeto(all_timelines_json, use_easing, active_tl_index, start_vision_index, export_width, export_height, filename)\r\n      timelines = JSON.parse(all_timelines_json, symbolize_names: true)\r\n      rect = calcular_rect_gravacao(export_width, export_height)\r\n\r\n      start_tl = active_tl_index.to_i\r\n      start_vision = start_vision_index.to_i\r\n\r\n      # Calcular dura√ß√£o total a partir do ponto de in√≠cio\r\n      total_time = 0.0\r\n      timelines.each_with_index do |tl, i|\r\n        next if i < start_tl\r\n        next unless tl[:visoes] && tl[:visoes].length >= 2\r\n        sorted = tl[:visoes].sort_by { |v| v[:time] }\r\n        first_v = (i == start_tl && start_vision > 0 && start_vision < sorted.length) ? start_vision : 0\r\n        if first_v < sorted.length - 1\r\n          total_time += sorted.last[:time] - sorted[first_v][:time]\r\n          total_time += 0.5\r\n        end\r\n      end\r\n\r\n      play_cmd = \"startRecordingPlayAll(#{start_tl}, #{start_vision})\"\r\n      executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, play_cmd)\r\n    end\r\n\r\n    def self.executar_gravacao_ffmpeg(json_data, use_easing, rect, start_index, filename)\r\n      camera_keys = JSON.parse(json_data, symbolize_names: true)\r\n      camera_keys.sort_by! { |v| v[:time] }\r\n\r\n      total_time = 0\r\n      if start_index < camera_keys.length - 1\r\n        relevant_keys = camera_keys[start_index..-1]\r\n        relevant_keys.each_cons(2) { |c, n| total_time += (n[:time] - c[:time]).abs }\r\n      end\r\n\r\n      executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, \"triggerSpaceFromRuby()\")\r\n    end\r\n\r\n    def self.executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, play_command)\r\n      folder = UI.select_directory(title: obter_texto(:selecionar_pasta))\r\n      return unless folder\r\n\r\n      output_path = File.join(folder, \"#{filename}.mp4\")\r\n\r\n      is_win = Sketchup.platform == :platform_win\r\n      ffmpeg_path = File.join(PLUGIN_DIR, 'ffmpeg', is_win ? 'ffmpeg.exe' : 'ffmpeg')\r\n\r\n      unless File.exist?(ffmpeg_path)\r\n        UI.messagebox(obter_texto(:ffmpeg_nao_encontrado))\r\n        return\r\n      end\r\n\r\n      duration_padding = 4.0\r\n      recording_duration = total_time + duration_padding\r\n\r\n      input_format = is_win ? 'gdigrab' : 'avfoundation'\r\n      input_source = is_win ? 'desktop' : '1:none'\r\n\r\n      cmd_array = [\r\n        \"\\\"#{ffmpeg_path}\\\"\",\r\n        '-y',\r\n        '-f', input_format,\r\n        '-framerate', '30',\r\n        '-t', recording_duration.to_s\r\n      ]\r\n\r\n      if is_win\r\n        cmd_array.concat([\r\n          '-draw_mouse', '0',\r\n          '-offset_x', rect[:x].to_s,\r\n          '-offset_y', rect[:y].to_s,\r\n          '-video_size', \"#{rect[:w]}x#{rect[:h]}\",\r\n          '-i', input_source\r\n        ])\r\n      else\r\n        cmd_array.concat([\r\n          '-i', input_source,\r\n          '-vf', \"crop=#{rect[:w]}:#{rect[:h]}:#{rect[:x]}:#{rect[:y]}\"\r\n        ])\r\n      end\r\n\r\n      cmd_array.concat([\r\n        '-c:v', 'libx264',\r\n        '-preset', 'ultrafast',\r\n        '-pix_fmt', 'yuv420p',\r\n        \"\\\"#{output_path}\\\"\"\r\n      ])\r\n\r\n      cmd = cmd_array.join(' ')\r\n\r\n      begin\r\n        if is_win\r\n           WIN32OLE.new('WScript.Shell').Run(cmd, 0, false)\r\n        else\r\n           pid = spawn(cmd)\r\n           Process.detach(pid)\r\n        end\r\n      rescue => e\r\n        UI.messagebox(\"#{obter_texto(:erro_gravador)}#{e.message}\")\r\n        return\r\n      end\r\n\r\n      sleep(1.5)\r\n\r\n      @dialog.execute_script(\"showRecordingIndicator()\")\r\n      @dialog.execute_script(play_command)\r\n\r\n      UI.start_timer(recording_duration + 1.0, false) do\r\n        @dialog.execute_script(\"hideRecordingIndicator()\")\r\n        UI.messagebox(\"#{obter_texto(:gravacao_finalizada)}#{output_path}\")\r\n        @dialog.execute_script(\"resetPlayButton(); resetPlayAll();\")\r\n      end\r\n    end\r\n\r\n    def self.start_ui\r\n      current_hotkey = GlobalKey.key_code\r\n      hotkey_ctrl = GlobalKey.ctrl ? 'true' : 'false'\r\n      hotkey_alt = GlobalKey.alt ? 'true' : 'false'\r\n      hotkey_shift = GlobalKey.shift ? 'true' : 'false'\r\n      ffmpeg_path = File.join(PLUGIN_DIR, 'ffmpeg', Sketchup.platform == :platform_win ? 'ffmpeg.exe' : 'ffmpeg')\r\n      \r\n      has_ffmpeg = File.exist?(ffmpeg_path)\r\n\r\n      view = Sketchup.active_model.active_view\r\n      vp_width = view.vpwidth\r\n      vp_height = view.vpheight\r\n\r\n      js_i18n_hash = {}\r\n      IDIOMAS[IDIOMAS.key?(Sketchup.get_locale) ? Sketchup.get_locale : 'en-US'].each { |k, v| js_i18n_hash[k] = v }\r\n      js_i18n_json = js_i18n_hash.to_json\r\n\r\n      html = <<-HTML\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n  <meta charset=\"utf-8\">\r\n  <title>#{obter_texto(:titulo)}</title>\r\n  <style>\r\n    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }\r\n    body {\r\n      font-family: system-ui, -apple-system, 'Segoe UI', sans-serif;\r\n      background: #f5f5f5; color: #333; font-size: 13px;\r\n      padding: 16px; line-height: 1.4;\r\n    }\r\n\r\n    /* Header */\r\n    .header {\r\n      display: flex; align-items: center; gap: 10px;\r\n      padding-bottom: 14px; border-bottom: 2px solid #0066cc;\r\n      margin-bottom: 16px;\r\n    }\r\n    .header svg { flex-shrink: 0; }\r\n    .header h1 { font-size: 17px; font-weight: 700; color: #1a1a1a; }\r\n    .header .subtitle { font-size: 11px; color: #888; font-weight: 400; }\r\n\r\n    /* Cards */\r\n    .card {\r\n      background: #fff; border: 1px solid #e0e0e0; border-radius: 8px;\r\n      box-shadow: 0 1px 3px rgba(0,0,0,0.06); margin-bottom: 12px;\r\n      overflow: hidden;\r\n    }\r\n    .card-header {\r\n      display: flex; align-items: center; justify-content: space-between;\r\n      padding: 10px 14px; background: #fafafa; border-bottom: 1px solid #eee;\r\n      cursor: pointer; user-select: none;\r\n    }\r\n    .card-header h2 { font-size: 13px; font-weight: 600; color: #444; }\r\n    .card-header .toggle-icon { font-size: 11px; color: #999; transition: transform 0.2s; }\r\n    .card-header.collapsed .toggle-icon { transform: rotate(-90deg); }\r\n    .card-body { padding: 14px; }\r\n    .card-body.collapsed { display: none; }\r\n\r\n    /* Timeline */\r\n    .timeline-wrapper { position: relative; padding: 8px 0 20px; }\r\n    .timeline-track {\r\n      position: absolute; top: 20px; left: 6px; right: 6px; height: 4px;\r\n      background: #ddd; border-radius: 2px; z-index: 0;\r\n    }\r\n    #timeline_range {\r\n      -webkit-appearance: none; appearance: none; width: 100%;\r\n      height: 6px; background: transparent; outline: none;\r\n      position: relative; z-index: 2; cursor: pointer;\r\n    }\r\n    #timeline_range::-webkit-slider-runnable-track {\r\n      height: 6px; background: linear-gradient(90deg, #0066cc 0%, #4da6ff 100%);\r\n      border-radius: 3px;\r\n    }\r\n    #timeline_range::-webkit-slider-thumb {\r\n      -webkit-appearance: none; width: 16px; height: 16px;\r\n      background: #0066cc; border: 2px solid #fff; border-radius: 50%;\r\n      margin-top: -5px; cursor: grab; box-shadow: 0 1px 4px rgba(0,0,0,0.2);\r\n    }\r\n    #timeline_range::-webkit-slider-thumb:active { cursor: grabbing; transform: scale(1.15); }\r\n    #markers_layer {\r\n      position: absolute; top: 0; left: 0; width: 100%; height: 40px;\r\n      pointer-events: none; z-index: 3;\r\n    }\r\n    .marker {\r\n      position: absolute; top: 26px; width: 14px; height: 14px;\r\n      background: #0066cc; border-radius: 50%; border: 2px solid #fff;\r\n      transform: translateX(-50%); pointer-events: auto; cursor: pointer;\r\n      box-shadow: 0 1px 3px rgba(0,0,0,0.15); transition: transform 0.15s, background 0.15s;\r\n    }\r\n    .marker:hover { transform: translateX(-50%) scale(1.25); }\r\n    .marker.anchor { background: #dc3545; }\r\n    .marker .marker-tooltip {\r\n      position: absolute; bottom: 18px; left: 50%; transform: translateX(-50%);\r\n      background: #333; color: #fff; font-size: 10px; padding: 2px 6px;\r\n      border-radius: 3px; white-space: nowrap; opacity: 0;\r\n      pointer-events: none; transition: opacity 0.15s;\r\n    }\r\n    .marker:hover .marker-tooltip { opacity: 1; }\r\n    .time-row {\r\n      display: flex; align-items: center; justify-content: space-between;\r\n      margin-top: 8px; gap: 12px;\r\n    }\r\n    .time-display { font-size: 20px; font-weight: 700; color: #0066cc; font-variant-numeric: tabular-nums; }\r\n    .time-display small { font-size: 12px; color: #888; font-weight: 400; }\r\n    .time-input-group { display: flex; align-items: center; gap: 6px; }\r\n    .time-input-group label { font-size: 11px; color: #666; }\r\n\r\n    /* Buttons */\r\n    .btn {\r\n      display: inline-flex; align-items: center; justify-content: center; gap: 6px;\r\n      padding: 7px 14px; border: 1px solid transparent; border-radius: 6px;\r\n      font-size: 12px; font-weight: 500; cursor: pointer;\r\n      transition: all 0.15s; outline: none; font-family: inherit;\r\n    }\r\n    .btn:active { transform: scale(0.97); }\r\n    .btn-primary { background: #0066cc; color: #fff; }\r\n    .btn-primary:hover { background: #0052a3; }\r\n    .btn-success { background: #28a745; color: #fff; }\r\n    .btn-success:hover { background: #218838; }\r\n    .btn-danger { background: #dc3545; color: #fff; }\r\n    .btn-danger:hover { background: #c82333; }\r\n    .btn-outline { background: transparent; border: 1px solid #ccc; color: #555; }\r\n    .btn-outline:hover { background: #f0f0f0; border-color: #aaa; }\r\n    .btn-sm { padding: 4px 10px; font-size: 11px; }\r\n    .btn-record { background: #dc3545; color: #fff; padding: 10px 20px; font-size: 13px; font-weight: 600; }\r\n    .btn-record:hover { background: #c82333; }\r\n    .btn-record:disabled { background: #ccc; color: #888; cursor: not-allowed; }\r\n\r\n    .btn-group { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }\r\n\r\n    /* Checkboxes */\r\n    .check-group { display: flex; align-items: center; gap: 16px; margin-top: 10px; }\r\n    .check-item { display: flex; align-items: center; gap: 5px; }\r\n    .check-item input[type=\"checkbox\"] {\r\n      width: 15px; height: 15px; accent-color: #0066cc; cursor: pointer;\r\n    }\r\n    .check-item label { font-size: 12px; color: #555; cursor: pointer; }\r\n\r\n    /* Hotkey */\r\n    .hotkey-editor {\r\n      display: none; align-items: center; gap: 6px;\r\n      background: #f9f9f9; padding: 6px 10px; border-radius: 6px; border: 1px solid #ddd;\r\n    }\r\n    .hotkey-editor.visible { display: inline-flex; }\r\n    .hotkey-editor input {\r\n      width: 100px; padding: 4px 8px; border: 1px solid #ccc;\r\n      border-radius: 4px; font-size: 12px; font-family: monospace;\r\n      outline: none;\r\n    }\r\n    .hotkey-editor input:focus { border-color: #0066cc; }\r\n\r\n    /* Vision List */\r\n    .vision-list { max-height: 350px; overflow-y: auto; }\r\n    .vision-list::-webkit-scrollbar { width: 6px; }\r\n    .vision-list::-webkit-scrollbar-track { background: #f0f0f0; border-radius: 3px; }\r\n    .vision-list::-webkit-scrollbar-thumb { background: #ccc; border-radius: 3px; }\r\n    .vision-list::-webkit-scrollbar-thumb:hover { background: #aaa; }\r\n    .vision-item {\r\n      display: flex; align-items: center; gap: 10px; padding: 8px 10px;\r\n      border-bottom: 1px solid #f0f0f0; cursor: pointer;\r\n      transition: background 0.12s;\r\n    }\r\n    .vision-item:hover { background: #f7faff; }\r\n    .vision-item:last-child { border-bottom: none; }\r\n    .vision-item .vision-num {\r\n      font-size: 11px; font-weight: 700; color: #999; width: 20px;\r\n      text-align: center; flex-shrink: 0;\r\n    }\r\n    .vision-item img {\r\n      width: 72px; height: 45px; object-fit: cover; border-radius: 4px;\r\n      border: 1px solid #ddd; flex-shrink: 0;\r\n    }\r\n    .vision-item img.thumb-placeholder {\r\n      background: linear-gradient(135deg, #e0e0e0 0%, #c0c0c0 100%);\r\n      animation: pulse-placeholder 1s ease-in-out infinite alternate;\r\n    }\r\n    @keyframes pulse-placeholder {\r\n      from { opacity: 0.6; }\r\n      to { opacity: 1.0; }\r\n    }\r\n    .vision-item .vision-info { flex: 1; min-width: 0; }\r\n    .vision-item .vision-time-input {\r\n      width: 58px; padding: 3px 6px; border: 1px solid #ddd; border-radius: 4px;\r\n      font-size: 12px; text-align: center; outline: none; font-family: inherit;\r\n    }\r\n    .vision-item .vision-time-input:focus { border-color: #0066cc; }\r\n    .vision-item .vision-time-input:disabled { background: #f5f5f5; color: #999; }\r\n    .vision-actions { display: flex; align-items: center; gap: 6px; flex-shrink: 0; }\r\n    .anchor-toggle {\r\n      width: 26px; height: 26px; border-radius: 50%; border: 2px solid #ddd;\r\n      background: transparent; cursor: pointer; display: flex;\r\n      align-items: center; justify-content: center; transition: all 0.15s;\r\n      font-size: 12px; color: #ccc;\r\n    }\r\n    .anchor-toggle:hover { border-color: #dc3545; color: #dc3545; }\r\n    .anchor-toggle.active { background: #dc3545; border-color: #dc3545; color: #fff; }\r\n    .delete-btn {\r\n      width: 26px; height: 26px; border-radius: 50%; border: 1px solid #eee;\r\n      background: transparent; cursor: pointer; display: flex;\r\n      align-items: center; justify-content: center; transition: all 0.15s;\r\n      font-size: 14px; color: #ccc;\r\n    }\r\n    .delete-btn:hover { background: #fee; border-color: #dc3545; color: #dc3545; }\r\n    .empty-state {\r\n      text-align: center; padding: 30px 16px; color: #aaa;\r\n    }\r\n    .empty-state svg { margin-bottom: 8px; opacity: 0.4; }\r\n    .empty-state p { font-size: 12px; }\r\n\r\n    /* Export Section */\r\n    .preset-select {\r\n      width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px;\r\n      font-size: 12px; font-family: inherit; outline: none; background: #fff;\r\n      cursor: pointer; color: #333;\r\n    }\r\n    .preset-select:focus { border-color: #0066cc; }\r\n    .preset-preview {\r\n      display: flex; align-items: center; justify-content: center;\r\n      padding: 8px; margin-top: 8px; background: #f7faff;\r\n      border: 1px dashed #b3d4fc; border-radius: 6px;\r\n      font-size: 12px; color: #0066cc; font-weight: 600;\r\n    }\r\n    .custom-dims {\r\n      display: none; gap: 8px; align-items: center; margin-top: 8px;\r\n    }\r\n    .custom-dims.visible { display: flex; }\r\n    .custom-dims input {\r\n      width: 80px; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px;\r\n      font-size: 12px; text-align: center; outline: none; font-family: inherit;\r\n    }\r\n    .custom-dims input:focus { border-color: #0066cc; }\r\n    .custom-dims span { color: #999; font-weight: 600; }\r\n\r\n    /* Recording indicator */\r\n    .recording-bar {\r\n      display: none; align-items: center; gap: 8px; padding: 10px 14px;\r\n      background: #fff5f5; border: 1px solid #f5c6cb; border-radius: 6px;\r\n      margin-top: 10px;\r\n    }\r\n    .recording-bar.active { display: flex; }\r\n    .recording-dot {\r\n      width: 10px; height: 10px; background: #dc3545; border-radius: 50%;\r\n      animation: pulse 1s infinite;\r\n    }\r\n    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }\r\n    .recording-bar span { font-size: 12px; color: #dc3545; font-weight: 600; }\r\n\r\n    /* Playing overlay */\r\n    body.playing .card { opacity: 0.6; pointer-events: none; }\r\n    body.playing .card.playback-card { opacity: 1; pointer-events: auto; }\r\n    body.playing .card.playback-card .btn:not(#play_button):not(#play_all_button) { pointer-events: none; opacity: 0.4; }\r\n    body.playing #play_button, body.playing #play_all_button { pointer-events: auto !important; opacity: 1 !important; }\r\n\r\n    /* Input base */\r\n    input[type=\"number\"] {\r\n      -moz-appearance: textfield;\r\n    }\r\n    input[type=\"number\"]::-webkit-inner-spin-button {\r\n      -webkit-appearance: none;\r\n    }\r\n\r\n    /* Draggable markers */\r\n    .marker { cursor: grab; }\r\n    .marker.dragging {\r\n      transform: translateX(-50%) scale(1.3);\r\n      z-index: 20;\r\n      cursor: grabbing;\r\n    }\r\n    .marker.no-drag { cursor: default; }\r\n\r\n    /* Saved timelines list */\r\n    .saved-timelines-list { margin-top: 10px; }\r\n    .saved-timelines-list:empty { display: none; }\r\n    .tl-item {\r\n      display: flex; align-items: center; gap: 8px;\r\n      padding: 6px 10px; border-bottom: 1px solid #f0f0f0;\r\n      cursor: pointer; transition: background 0.12s; font-size: 12px;\r\n    }\r\n    .tl-item:hover { background: #f7faff; }\r\n    .tl-item:last-child { border-bottom: none; }\r\n    .tl-item .tl-indicator {\r\n      width: 8px; height: 8px; border-radius: 50%;\r\n      background: #ccc; flex-shrink: 0;\r\n    }\r\n    .tl-item.active .tl-indicator { background: #0066cc; }\r\n    .tl-item .tl-name { flex: 1; font-weight: 500; color: #333; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }\r\n    .tl-item .tl-count { color: #999; font-size: 11px; flex-shrink: 0; }\r\n    .tl-item .tl-delete {\r\n      width: 20px; height: 20px; border-radius: 50%; border: 1px solid #eee;\r\n      background: transparent; cursor: pointer; display: flex;\r\n      align-items: center; justify-content: center; font-size: 12px; color: #ccc;\r\n      flex-shrink: 0; transition: all 0.15s;\r\n    }\r\n    .tl-item .tl-delete:hover { background: #fee; border-color: #dc3545; color: #dc3545; }\r\n\r\n    /* Drag-and-drop for timeline reordering */\r\n    .tl-drag-handle {\r\n      cursor: grab; flex-shrink: 0; color: #ccc; font-size: 14px;\r\n      padding: 0 4px; user-select: none;\r\n    }\r\n    .tl-drag-handle:active { cursor: grabbing; }\r\n    .tl-item.dragging { opacity: 0.4; }\r\n    .tl-item.drag-over-top { border-top: 2px solid #0066cc; }\r\n    .tl-item.drag-over-bottom { border-bottom: 2px solid #0066cc; }\r\n\r\n    /* Viewport info */\r\n    .viewport-info {\r\n      font-size: 11px; color: #666; margin-bottom: 10px;\r\n      padding: 6px 10px; background: #f9f9f9; border-radius: 4px; border: 1px solid #eee;\r\n    }\r\n\r\n    /* Misc */\r\n    .hidden { display: none !important; }\r\n    .mt-8 { margin-top: 8px; }\r\n  </style>\r\n</head>\r\n<body>\r\n\r\n<!-- Header -->\r\n<div class=\"header\">\r\n  <svg width=\"28\" height=\"28\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"#0066cc\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    <path d=\"M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z\"/>\r\n    <circle cx=\"12\" cy=\"13\" r=\"4\"/>\r\n  </svg>\r\n  <div>\r\n    <h1>#{obter_texto(:titulo)}</h1>\r\n    <span class=\"subtitle\">#{obter_texto(:subtitulo)}</span>\r\n  </div>\r\n</div>\r\n\r\n<!-- Timeline Card -->\r\n<div class=\"card\">\r\n  <div class=\"card-body\">\r\n    <div class=\"timeline-wrapper\">\r\n      <div class=\"timeline-track\"></div>\r\n      <input type=\"range\" min=\"0\" max=\"60\" step=\"0.1\" value=\"0\" id=\"timeline_range\" oninput=\"updateTime(this.value)\">\r\n      <div id=\"markers_layer\"></div>\r\n    </div>\r\n    <div class=\"time-row\">\r\n      <div class=\"time-display\"><span id=\"current_time\">0.0</span><small>s</small></div>\r\n      <div class=\"time-input-group\">\r\n        <label>#{obter_texto(:total)}</label>\r\n        <input id=\"max_time\" type=\"number\" step=\"1\" value=\"60\" min=\"1\" onchange=\"atualizarTempoTotal()\"\r\n          style=\"width:65px; padding:4px 8px; border:1px solid #ddd; border-radius:4px; font-size:12px; text-align:center; outline:none; font-family:inherit;\">\r\n        <small style=\"color:#888;\">s</small>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Playback Controls Card -->\r\n<div class=\"card playback-card\">\r\n  <div class=\"card-body\">\r\n    <div class=\"btn-group\">\r\n      <button class=\"btn btn-primary\" onclick=\"addVision()\">\r\n        <svg width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2.5\"><line x1=\"12\" y1=\"5\" x2=\"12\" y2=\"19\"/><line x1=\"5\" y1=\"12\" x2=\"19\" y2=\"12\"/></svg>\r\n        #{obter_texto(:visao)}\r\n      </button>\r\n      <button id=\"play_button\" class=\"btn btn-success\" onclick=\"togglePlay()\">&#9654; #{obter_texto(:play)}</button>\r\n      <button id=\"play_all_button\" class=\"btn btn-outline btn-sm hidden\" onclick=\"togglePlayAll()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><polygon points=\"5 3 19 12 5 21 5 3\"/><line x1=\"19\" y1=\"3\" x2=\"19\" y2=\"21\"/></svg>\r\n        #{obter_texto(:play_all)}\r\n      </button>\r\n      <button class=\"btn btn-outline btn-sm\" onclick=\"mostrarCampoAtalho()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><rect x=\"2\" y=\"4\" width=\"20\" height=\"16\" rx=\"2\"/><line x1=\"6\" y1=\"8\" x2=\"6\" y2=\"8\"/><line x1=\"10\" y1=\"8\" x2=\"10\" y2=\"8\"/><line x1=\"14\" y1=\"8\" x2=\"14\" y2=\"8\"/><line x1=\"18\" y1=\"8\" x2=\"18\" y2=\"8\"/><line x1=\"8\" y1=\"16\" x2=\"16\" y2=\"16\"/></svg>\r\n        #{obter_texto(:atalho)}\r\n      </button>\r\n      <span id=\"hotkey_edit\" class=\"hotkey-editor\">\r\n        <input id=\"hotkey_input\" type=\"text\" placeholder=\"#{obter_texto(:pressione)}\" onkeydown=\"capturarAtalhoInput(event)\">\r\n        <button class=\"btn btn-primary btn-sm\" onclick=\"confirmarAtalho()\">#{obter_texto(:ok)}</button>\r\n      </span>\r\n    </div>\r\n    <div class=\"check-group\">\r\n      <div class=\"check-item\">\r\n        <input type=\"checkbox\" id=\"loop_checkbox\">\r\n        <label for=\"loop_checkbox\">#{obter_texto(:loop)}</label>\r\n      </div>\r\n      <div class=\"check-item\">\r\n        <input type=\"checkbox\" id=\"easing_checkbox\">\r\n        <label for=\"easing_checkbox\">#{obter_texto(:easing)}</label>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Visions Card -->\r\n<div class=\"card\">\r\n  <div class=\"card-header\" onclick=\"toggleSection('visions')\">\r\n    <h2>#{obter_texto(:visoes_salvas)} <span id=\"vision_count\" style=\"color:#999; font-weight:400;\"></span></h2>\r\n    <span class=\"toggle-icon\" id=\"visions_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body\" id=\"visions_body\">\r\n    <div class=\"vision-list\" id=\"lista_visoes\"></div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Gerenciar Time Line Card -->\r\n<div class=\"card\">\r\n  <div class=\"card-header\" onclick=\"toggleSection('timeline_mgr')\">\r\n    <h2>#{obter_texto(:gerenciar_timeline)}</h2>\r\n    <span class=\"toggle-icon\" id=\"timeline_mgr_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body\" id=\"timeline_mgr_body\">\r\n    <div class=\"btn-group\">\r\n      <button class=\"btn btn-outline\" onclick=\"novaTimeline()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z\"/><polyline points=\"14 2 14 8 20 8\"/><line x1=\"12\" y1=\"18\" x2=\"12\" y2=\"12\"/><line x1=\"9\" y1=\"15\" x2=\"15\" y2=\"15\"/></svg>\r\n        #{obter_texto(:nova)}\r\n      </button>\r\n      <button class=\"btn btn-outline\" onclick=\"exportarTimeline()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\"/><polyline points=\"7 10 12 15 17 10\"/><line x1=\"12\" y1=\"15\" x2=\"12\" y2=\"3\"/></svg>\r\n        #{obter_texto(:exportar_atual)}\r\n      </button>\r\n      <button class=\"btn btn-outline\" onclick=\"exportarProjeto()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z\"/><polyline points=\"9 14 12 17 15 14\"/><line x1=\"12\" y1=\"17\" x2=\"12\" y2=\"10\"/></svg>\r\n        #{obter_texto(:exportar_projeto)}\r\n      </button>\r\n      <input type=\"file\" id=\"import_file\" class=\"hidden\" accept=\".json\" onchange=\"importarTimeline(this)\">\r\n      <button class=\"btn btn-outline\" onclick=\"document.getElementById('import_file').click()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\"/><polyline points=\"17 8 12 3 7 8\"/><line x1=\"12\" y1=\"3\" x2=\"12\" y2=\"15\"/></svg>\r\n        #{obter_texto(:importar)}\r\n      </button>\r\n    </div>\r\n    <div id=\"saved_timelines_list\" class=\"saved-timelines-list\"></div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Exportar V√≠deo Card (colapsado por padr√£o) -->\r\n<div class=\"card\">\r\n  <div class=\"card-header collapsed\" onclick=\"toggleSection('export')\">\r\n    <h2>#{obter_texto(:exportar_video)}</h2>\r\n    <span class=\"toggle-icon\" id=\"export_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body collapsed\" id=\"export_body\">\r\n    <div id=\"ffmpeg_section\" class=\"#{has_ffmpeg ? '' : 'hidden'}\">\r\n      <div class=\"viewport-info\">\r\n        #{obter_texto(:viewport_atual)} <strong>#{vp_width} x #{vp_height} px</strong>\r\n      </div>\r\n\r\n      <select id=\"preset_select\" class=\"preset-select\" onchange=\"onPresetChange()\">\r\n        <option value=\"\" disabled selected>#{obter_texto(:selecione_formato)}</option>\r\n      </select>\r\n\r\n      <div class=\"custom-dims\" id=\"custom_dims\">\r\n        <input type=\"number\" id=\"custom_w\" min=\"50\" placeholder=\"#{obter_texto(:largura)}\" value=\"1280\">\r\n        <span>x</span>\r\n        <input type=\"number\" id=\"custom_h\" min=\"50\" placeholder=\"#{obter_texto(:altura)}\" value=\"720\">\r\n        <small style=\"color:#888;\">px</small>\r\n      </div>\r\n\r\n      <div class=\"preset-preview\" id=\"preset_preview\" style=\"display:none;\"></div>\r\n\r\n      <div class=\"check-group\" style=\"margin-top:12px; flex-direction:column; align-items:flex-start; gap:8px;\">\r\n        <div class=\"check-item\">\r\n          <input type=\"checkbox\" id=\"rec_projeto\">\r\n          <label for=\"rec_projeto\">#{obter_texto(:gravar_projeto)}</label>\r\n        </div>\r\n        <div class=\"check-item\">\r\n          <input type=\"checkbox\" id=\"rec_inicio\" checked>\r\n          <label for=\"rec_inicio\">#{obter_texto(:iniciar_quadro1)}</label>\r\n        </div>\r\n      </div>\r\n\r\n      <button class=\"btn btn-record mt-8\" id=\"btn_record\" onclick=\"iniciarGravacao()\" disabled style=\"width:100%; margin-top:12px;\">\r\n        <svg width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><circle cx=\"12\" cy=\"12\" r=\"4\" fill=\"currentColor\"/></svg>\r\n        #{obter_texto(:iniciar_gravacao)}\r\n      </button>\r\n\r\n      <div class=\"recording-bar\" id=\"recording_bar\">\r\n        <div class=\"recording-dot\"></div>\r\n        <span>#{obter_texto(:gravando)}</span>\r\n      </div>\r\n    </div>\r\n\r\n    <div id=\"ffmpeg_install\" class=\"#{has_ffmpeg ? 'hidden' : ''}\" style=\"text-align:center; padding:12px 0;\">\r\n      <p style=\"color:#888; font-size:12px; margin-bottom:10px;\">#{obter_texto(:ffmpeg_necessario)}</p>\r\n      <button class=\"btn btn-primary\" onclick=\"instalarExportacao()\">#{obter_texto(:instalar_ffmpeg)}</button>\r\n    </div>\r\n\r\n    <!-- Modal de nome do arquivo -->\r\n    <div id=\"filename_modal\" style=\"display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.4);z-index:100;align-items:center;justify-content:center;\">\r\n      <div style=\"background:#fff;border-radius:10px;padding:24px;width:320px;box-shadow:0 8px 30px rgba(0,0,0,0.2);\">\r\n        <h3 style=\"font-size:14px;font-weight:600;color:#333;margin-bottom:12px;\">#{obter_texto(:nome_arquivo)}</h3>\r\n        <input id=\"filename_input\" type=\"text\" value=\"tour_final\" style=\"width:100%;padding:8px 12px;border:1px solid #ddd;border-radius:6px;font-size:13px;font-family:inherit;outline:none;margin-bottom:6px;\">\r\n        <small style=\"color:#888;\">#{obter_texto(:extensao_mp4)}</small>\r\n        <div style=\"display:flex;gap:8px;margin-top:16px;justify-content:flex-end;\">\r\n          <button class=\"btn btn-outline btn-sm\" onclick=\"fecharModalFilename()\">#{obter_texto(:cancelar)}</button>\r\n          <button class=\"btn btn-primary btn-sm\" onclick=\"confirmarFilename()\">#{obter_texto(:salvar)}</button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<script>\r\n    const I18N = #{js_i18n_json};\r\n    let visoes = [], playing = false, currentIndex = 0;\r\n    let hotkey = { keyCode: #{current_hotkey}, ctrl: #{hotkey_ctrl}, alt: #{hotkey_alt}, shift: #{hotkey_shift} };\r\n    let capturingHotkey = false, pendingHotkey = null;\r\n    let savedTimelines = [];\r\n    let activeTimelineIndex = -1;\r\n    let playingAll = false, playAllQueue = [], playAllCurrentIdx = 0;\r\n    var viewportW = #{vp_width}, viewportH = #{vp_height};\r\n\r\n    if (window.sketchup) { window.sketchup.set_hotkey(hotkey.keyCode, hotkey.ctrl, hotkey.alt, hotkey.shift); }\r\n\r\n    /* --- Export Formats (aspect ratios) --- */\r\n    const EXPORT_FORMATS = [\r\n      { label: '16:9 ' + I18N.paisagem, ratio: [16, 9] },\r\n      { label: '9:16 ' + I18N.retrato, ratio: [9, 16] },\r\n      { label: '1:1 ' + I18N.quadrado, ratio: [1, 1] },\r\n      { label: '4:3 ' + I18N.classico, ratio: [4, 3] },\r\n      { label: '21:9 ' + I18N.ultra_wide, ratio: [21, 9] },\r\n      { label: I18N.viewport_inteira, ratio: null },\r\n      { label: I18N.personalizado, ratio: null, custom: true }\r\n    ];\r\n\r\n    function calcEffectiveDims(ratioW, ratioH, vpW, vpH) {\r\n      const scaleW = vpW / ratioW;\r\n      const scaleH = vpH / ratioH;\r\n      const scale = Math.min(scaleW, scaleH);\r\n      let w = Math.floor(ratioW * scale);\r\n      let h = Math.floor(ratioH * scale);\r\n      w = w % 2 === 0 ? w : w - 1;\r\n      h = h % 2 === 0 ? h : h - 1;\r\n      return { w: w, h: h };\r\n    }\r\n\r\n    function populatePresets() {\r\n      const sel = document.getElementById(\"preset_select\");\r\n      sel.innerHTML = '<option value=\"\" disabled selected>' + I18N.selecione_formato + '</option>';\r\n      EXPORT_FORMATS.forEach((fmt, i) => {\r\n        const opt = document.createElement(\"option\");\r\n        opt.value = i.toString();\r\n        if (fmt.custom) {\r\n          opt.textContent = fmt.label;\r\n        } else if (fmt.ratio) {\r\n          const dims = calcEffectiveDims(fmt.ratio[0], fmt.ratio[1], viewportW, viewportH);\r\n          opt.textContent = fmt.label + \" (\" + dims.w + \" x \" + dims.h + \" px)\";\r\n        } else {\r\n          let w = viewportW % 2 === 0 ? viewportW : viewportW - 1;\r\n          let h = viewportH % 2 === 0 ? viewportH : viewportH - 1;\r\n          opt.textContent = fmt.label + \" (\" + w + \" x \" + h + \" px)\";\r\n        }\r\n        sel.appendChild(opt);\r\n      });\r\n    }\r\n\r\n    /* --- Section Toggle --- */\r\n    function toggleSection(name) {\r\n      const body = document.getElementById(name + '_body');\r\n      const icon = document.getElementById(name + '_toggle');\r\n      const header = icon.parentElement;\r\n      const wasCollapsed = body.classList.contains('collapsed');\r\n      if (wasCollapsed) {\r\n        body.classList.remove('collapsed');\r\n        header.classList.remove('collapsed');\r\n      } else {\r\n        body.classList.add('collapsed');\r\n        header.classList.add('collapsed');\r\n      }\r\n      /* Hide viewport preview when closing export card */\r\n      if (name === 'export' && !wasCollapsed) {\r\n        if (window.sketchup) window.sketchup.hide_export_preview();\r\n      }\r\n    }\r\n\r\n    /* --- Timeline --- */\r\n    function updateTime(val) {\r\n      document.getElementById(\"current_time\").innerText = parseFloat(val).toFixed(1);\r\n    }\r\n\r\n    function atualizarTempoTotal() {\r\n      const novoMax = parseFloat(document.getElementById(\"max_time\").value);\r\n      if (isNaN(novoMax) || novoMax <= 0) return;\r\n      document.getElementById(\"timeline_range\").max = novoMax;\r\n      visoes.forEach(v => { if (v.time > novoMax) v.time = novoMax - 0.1; });\r\n      renderMarkers();\r\n    }\r\n\r\n    /* --- Visions --- */\r\n    function addVision() {\r\n      if (savedTimelines.length === 0 && visoes.length === 0) {\r\n        var name = prompt(I18N.nome_timeline, \"Time Line 1\");\r\n        if (!name) return;\r\n        savedTimelines.push({ name: name, visoes: [], maxTime: 60 });\r\n        activeTimelineIndex = 0;\r\n        renderSavedTimelines();\r\n      }\r\n      const time = parseFloat(document.getElementById(\"timeline_range\").value);\r\n      sketchup.capture_camera(time);\r\n    }\r\n\r\n    function captureVisionFromRuby(camJson) {\r\n      const obj = JSON.parse(camJson);\r\n      obj.walk = false; obj.anchor = false;\r\n      visoes = visoes.filter(v => v.time !== obj.time);\r\n      visoes.push(obj);\r\n      visoes.sort((a, b) => a.time - b.time);\r\n      visoes[0].time = 0.0;\r\n      syncActiveTimeline();\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    /* --- Draggable markers --- */\r\n    function setupMarkerDrag(marker, visionIndex, slider, maxTime) {\r\n      if (visionIndex === 0) {\r\n        marker.classList.add(\"no-drag\");\r\n        return;\r\n      }\r\n      marker.addEventListener(\"mousedown\", function(e) {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        marker.classList.add(\"dragging\");\r\n        const sliderPadding = 8;\r\n\r\n        function onMove(ev) {\r\n          const sliderRect = slider.getBoundingClientRect();\r\n          const usableWidth = sliderRect.width - sliderPadding * 2;\r\n          const relativeX = Math.max(0, Math.min(ev.clientX - sliderRect.left - sliderPadding, usableWidth));\r\n          const newTime = parseFloat(((relativeX / usableWidth) * maxTime).toFixed(1));\r\n          marker.style.left = (relativeX + sliderPadding) + \"px\";\r\n          const tooltip = marker.querySelector(\".marker-tooltip\");\r\n          if (tooltip) tooltip.textContent = newTime.toFixed(1) + \"s\";\r\n        }\r\n\r\n        function onUp(ev) {\r\n          marker.classList.remove(\"dragging\");\r\n          document.removeEventListener(\"mousemove\", onMove);\r\n          document.removeEventListener(\"mouseup\", onUp);\r\n          const sliderRect = slider.getBoundingClientRect();\r\n          const usableWidth = sliderRect.width - sliderPadding * 2;\r\n          const relativeX = Math.max(0, Math.min(ev.clientX - sliderRect.left - sliderPadding, usableWidth));\r\n          const newTime = parseFloat(((relativeX / usableWidth) * maxTime).toFixed(1));\r\n          visoes[visionIndex].time = Math.max(0.1, newTime);\r\n          visoes.sort((a, b) => a.time - b.time);\r\n          if (visoes.length > 0) visoes[0].time = 0.0;\r\n          renderMarkers();\r\n        }\r\n\r\n        document.addEventListener(\"mousemove\", onMove);\r\n        document.addEventListener(\"mouseup\", onUp);\r\n      });\r\n    }\r\n\r\n    function syncActiveTimeline() {\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n    }\r\n\r\n    function renderMarkers() {\r\n      const layer = document.getElementById(\"markers_layer\");\r\n      const lista = document.getElementById(\"lista_visoes\");\r\n      const slider = document.getElementById(\"timeline_range\");\r\n      const max = parseFloat(slider.max);\r\n      const width = slider.offsetWidth;\r\n      const countEl = document.getElementById(\"vision_count\");\r\n\r\n      layer.innerHTML = \"\"; lista.innerHTML = \"\";\r\n      countEl.textContent = visoes.length > 0 ? \"(\" + visoes.length + \")\" : \"\";\r\n\r\n      if (visoes.length === 0) {\r\n        lista.innerHTML = '<div class=\"empty-state\">' +\r\n          '<svg width=\"36\" height=\"36\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"#ccc\" stroke-width=\"1.5\"><path d=\"M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z\"/><circle cx=\"12\" cy=\"13\" r=\"4\"/></svg>' +\r\n          '<p>' + I18N.nenhuma_visao + '<br>' + I18N.dica_visao + '</p></div>';\r\n        return;\r\n      }\r\n\r\n      visoes.forEach((v, i) => {\r\n        /* Marker on timeline */\r\n        const percent = max > 0 ? v.time / max : 0;\r\n        const marker = document.createElement(\"div\");\r\n        marker.className = \"marker\" + (v.anchor ? \" anchor\" : \"\");\r\n        const sliderPadding = 8;\r\n        const usableWidth = width - sliderPadding * 2;\r\n        marker.style.left = (percent * usableWidth + sliderPadding) + \"px\";\r\n        const tooltip = document.createElement(\"span\");\r\n        tooltip.className = \"marker-tooltip\";\r\n        tooltip.textContent = v.time.toFixed(1) + \"s\";\r\n        marker.appendChild(tooltip);\r\n        marker.onclick = () => {\r\n          slider.value = v.time; updateTime(v.time); currentIndex = i;\r\n          resetPlayButton(); sketchup.goto_camera(JSON.stringify(v));\r\n        };\r\n        /* Draggable */\r\n        setupMarkerDrag(marker, i, slider, max);\r\n        layer.appendChild(marker);\r\n\r\n        /* Vision list item */\r\n        const item = document.createElement(\"div\");\r\n        item.className = \"vision-item\";\r\n        item.onclick = () => {\r\n          slider.value = v.time; updateTime(v.time); currentIndex = i;\r\n          resetPlayButton(); sketchup.goto_camera(JSON.stringify(v));\r\n        };\r\n\r\n        const num = document.createElement(\"span\");\r\n        num.className = \"vision-num\";\r\n        num.textContent = (i + 1);\r\n\r\n        const img = document.createElement(\"img\");\r\n        if (v.thumb && v.thumb.length > 0) {\r\n          const mime = v.thumb.startsWith(\"/9j/\") ? \"image/jpeg\" : \"image/bmp\";\r\n          img.src = \"data:\" + mime + \";base64,\" + v.thumb;\r\n        } else {\r\n          img.src = \"\";\r\n          img.className = \"thumb-placeholder\";\r\n        }\r\n\r\n        const info = document.createElement(\"div\");\r\n        info.className = \"vision-info\";\r\n        const timeInput = document.createElement(\"input\");\r\n        timeInput.type = \"number\"; timeInput.step = \"0.1\";\r\n        timeInput.value = v.time.toFixed(1);\r\n        timeInput.className = \"vision-time-input\";\r\n        timeInput.disabled = (i === 0);\r\n        timeInput.onclick = (e) => e.stopPropagation();\r\n        timeInput.onchange = () => {\r\n          v.time = parseFloat(timeInput.value);\r\n          visoes.sort((a, b) => a.time - b.time);\r\n          renderMarkers();\r\n        };\r\n        info.appendChild(timeInput);\r\n\r\n        const actions = document.createElement(\"div\");\r\n        actions.className = \"vision-actions\";\r\n\r\n        const anchorBtn = document.createElement(\"button\");\r\n        anchorBtn.className = \"anchor-toggle\" + (v.anchor ? \" active\" : \"\");\r\n        anchorBtn.innerHTML = \"&#9875;\";\r\n        anchorBtn.title = I18N.ancora;\r\n        anchorBtn.onclick = (e) => {\r\n          e.stopPropagation();\r\n          v.anchor = !v.anchor;\r\n          renderMarkers();\r\n        };\r\n        actions.appendChild(anchorBtn);\r\n\r\n        const delBtn = document.createElement(\"button\");\r\n        delBtn.className = \"delete-btn\";\r\n        delBtn.innerHTML = \"&times;\";\r\n        delBtn.title = I18N.excluir;\r\n        delBtn.onclick = (e) => {\r\n          e.stopPropagation();\r\n          visoes.splice(i, 1);\r\n          if (visoes.length > 0) visoes[0].time = 0.0;\r\n          syncActiveTimeline();\r\n          renderMarkers();\r\n          renderSavedTimelines();\r\n        };\r\n        actions.appendChild(delBtn);\r\n\r\n        item.appendChild(num);\r\n        item.appendChild(img);\r\n        item.appendChild(info);\r\n        item.appendChild(actions);\r\n        lista.appendChild(item);\r\n      });\r\n    }\r\n\r\n    /* --- Playback --- */\r\n    function togglePlay() {\r\n      if (!playing) {\r\n        if (visoes.length < 2) return alert(I18N.min_duas_visoes);\r\n        if (currentIndex >= visoes.length - 1) currentIndex = 0;\r\n        playing = true;\r\n        document.body.classList.add(\"playing\");\r\n        document.getElementById(\"play_button\").innerHTML = \"&#9724; \" + I18N.stop;\r\n        document.getElementById(\"play_button\").className = \"btn btn-danger\";\r\n        sketchup.play_tour(JSON.stringify(visoes), document.getElementById(\"loop_checkbox\").checked, false, document.getElementById(\"easing_checkbox\").checked, currentIndex);\r\n      } else {\r\n        resetPlayButton();\r\n        sketchup.stop_tour();\r\n      }\r\n    }\r\n\r\n    function resetPlayButton() {\r\n      playing = false;\r\n      document.body.classList.remove(\"playing\");\r\n      document.getElementById(\"play_button\").innerHTML = \"&#9654; \" + I18N.play;\r\n      document.getElementById(\"play_button\").className = \"btn btn-success\";\r\n    }\r\n\r\n    function togglePlayAll() {\r\n      if (playingAll) {\r\n        resetPlayAll();\r\n        sketchup.stop_tour();\r\n        return;\r\n      }\r\n      if (savedTimelines.length < 2) return;\r\n      /* Save current timeline state */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n      /* Build queue of timelines with 2+ visions */\r\n      playAllQueue = savedTimelines.map(function(tl, i) { return i; }).filter(function(i) { return savedTimelines[i].visoes.length >= 2; });\r\n      if (playAllQueue.length < 1) { alert(I18N.sem_tl_2mais); return; }\r\n      playingAll = true;\r\n      playAllCurrentIdx = 0;\r\n      document.body.classList.add(\"playing\");\r\n      document.getElementById(\"play_all_button\").innerHTML = \"&#9724; \" + I18N.stop_all;\r\n      document.getElementById(\"play_all_button\").className = \"btn btn-danger btn-sm\";\r\n      playTimelineAtQueueIndex(0);\r\n    }\r\n\r\n    function playTimelineAtQueueIndex(qIdx) {\r\n      var tlIdx = playAllQueue[qIdx];\r\n      var tl = savedTimelines[tlIdx];\r\n      visoes = JSON.parse(JSON.stringify(tl.visoes));\r\n      document.getElementById(\"max_time\").value = tl.maxTime;\r\n      document.getElementById(\"timeline_range\").max = tl.maxTime;\r\n      activeTimelineIndex = tlIdx;\r\n      currentIndex = 0;\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n      sketchup.play_tour(\r\n        JSON.stringify(visoes),\r\n        false,\r\n        false,\r\n        document.getElementById(\"easing_checkbox\").checked,\r\n        0\r\n      );\r\n    }\r\n\r\n    function resetPlayAll() {\r\n      playingAll = false;\r\n      playAllQueue = [];\r\n      playAllCurrentIdx = 0;\r\n      document.body.classList.remove(\"playing\");\r\n      var btn = document.getElementById(\"play_all_button\");\r\n      btn.innerHTML = '<svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><polygon points=\"5 3 19 12 5 21 5 3\"/><line x1=\"19\" y1=\"3\" x2=\"19\" y2=\"21\"/></svg> ' + I18N.play_all;\r\n      btn.className = \"btn btn-outline btn-sm\";\r\n      playing = false;\r\n      document.getElementById(\"play_button\").innerHTML = \"&#9654; \" + I18N.play;\r\n      document.getElementById(\"play_button\").className = \"btn btn-success\";\r\n    }\r\n\r\n    function startRecordingPlayAll(startTlIdx, startVisionIdx) {\r\n      syncActiveTimeline();\r\n      /* Montar fila de timelines com 2+ vis√µes, a partir de startTlIdx */\r\n      playAllQueue = [];\r\n      for (var i = startTlIdx; i < savedTimelines.length; i++) {\r\n        if (savedTimelines[i].visoes.length >= 2) playAllQueue.push(i);\r\n      }\r\n      if (playAllQueue.length === 0) return;\r\n\r\n      playingAll = true;\r\n      playAllCurrentIdx = 0;\r\n      playing = true;\r\n      document.body.classList.add(\"playing\");\r\n      document.getElementById(\"play_button\").innerHTML = \"&#9724; \" + I18N.stop;\r\n      document.getElementById(\"play_button\").className = \"btn btn-danger\";\r\n\r\n      /* Carregar a primeira timeline da fila */\r\n      var firstTlIdx = playAllQueue[0];\r\n      var tl = savedTimelines[firstTlIdx];\r\n      visoes = JSON.parse(JSON.stringify(tl.visoes));\r\n      document.getElementById(\"max_time\").value = tl.maxTime;\r\n      document.getElementById(\"timeline_range\").max = tl.maxTime;\r\n      activeTimelineIndex = firstTlIdx;\r\n      currentIndex = startVisionIdx;\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n\r\n      sketchup.play_tour(\r\n        JSON.stringify(visoes),\r\n        false,\r\n        false,\r\n        document.getElementById(\"easing_checkbox\").checked,\r\n        startVisionIdx\r\n      );\r\n    }\r\n\r\n    function updatePlayAllButton() {\r\n      var btn = document.getElementById(\"play_all_button\");\r\n      if (savedTimelines.length > 1) {\r\n        btn.classList.remove(\"hidden\");\r\n      } else {\r\n        btn.classList.add(\"hidden\");\r\n      }\r\n    }\r\n\r\n    function pauseAtIndex(idx) {\r\n      currentIndex = idx;\r\n      if (playingAll) {\r\n        playAllCurrentIdx++;\r\n        if (playAllCurrentIdx < playAllQueue.length) {\r\n          playTimelineAtQueueIndex(playAllCurrentIdx);\r\n          return;\r\n        } else {\r\n          resetPlayAll();\r\n          return;\r\n        }\r\n      }\r\n      resetPlayButton();\r\n    }\r\n    function triggerSpaceFromRuby() { togglePlay(); }\r\n    function updatePlayhead(time) {\r\n      var slider = document.getElementById(\"timeline_range\");\r\n      slider.value = time;\r\n      document.getElementById(\"current_time\").innerText = parseFloat(time).toFixed(1);\r\n    }\r\n\r\n    /* --- Timeline Management --- */\r\n    function exportarTimeline() {\r\n      if (visoes.length === 0) { alert(I18N.sem_visoes_exportar); return; }\r\n      var tlName = (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length)\r\n        ? savedTimelines[activeTimelineIndex].name : \"Time Line\";\r\n      /* Download JSON */\r\n      var dataStr = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(visoes, null, 2));\r\n      var a = document.createElement(\"a\");\r\n      a.setAttribute(\"href\", dataStr);\r\n      a.setAttribute(\"download\", tlName.replace(/[^a-zA-Z0-9_-]/g, \"_\") + \".json\");\r\n      document.body.appendChild(a); a.click(); a.remove();\r\n      /* Salvar na lista */\r\n      saveCurrentToTimelines(tlName);\r\n    }\r\n\r\n    function exportarProjeto() {\r\n      syncActiveTimeline();\r\n      if (savedTimelines.length === 0) { alert(I18N.sem_tl_exportar); return; }\r\n      var projeto = { type: \"tour_virtual_project\", timelines: savedTimelines };\r\n      var dataStr = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(projeto, null, 2));\r\n      var a = document.createElement(\"a\");\r\n      a.setAttribute(\"href\", dataStr);\r\n      a.setAttribute(\"download\", \"projeto_tour_virtual.json\");\r\n      document.body.appendChild(a); a.click(); a.remove();\r\n    }\r\n\r\n    function saveCurrentToTimelines(name) {\r\n      var maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      var entry = { name: name, visoes: JSON.parse(JSON.stringify(visoes)), maxTime: maxTime };\r\n      /* Atualizar existente se ativo, sen√£o adicionar novo */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex] = entry;\r\n      } else {\r\n        savedTimelines.push(entry);\r\n        activeTimelineIndex = savedTimelines.length - 1;\r\n      }\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    function importarTimeline(input) {\r\n      var file = input.files[0];\r\n      if (!file) return;\r\n      var reader = new FileReader();\r\n      reader.onload = function(e) {\r\n        try {\r\n          var imported = JSON.parse(e.target.result);\r\n          /* Detectar se √© um projeto completo */\r\n          if (imported && imported.type === \"tour_virtual_project\" && Array.isArray(imported.timelines)) {\r\n            syncActiveTimeline();\r\n            imported.timelines.forEach(function(tl) {\r\n              if (tl.visoes) {\r\n                tl.visoes.sort(function(a, b) { return a.time - b.time; });\r\n                if (tl.visoes.length > 0) tl.visoes[0].time = 0.0;\r\n              }\r\n              savedTimelines.push({ name: tl.name || I18N.importada, visoes: tl.visoes || [], maxTime: tl.maxTime || 60 });\r\n            });\r\n            if (savedTimelines.length > 0 && activeTimelineIndex < 0) {\r\n              activeTimelineIndex = 0;\r\n              var first = savedTimelines[0];\r\n              visoes = JSON.parse(JSON.stringify(first.visoes));\r\n              document.getElementById(\"max_time\").value = first.maxTime;\r\n              document.getElementById(\"timeline_range\").max = first.maxTime;\r\n              renderMarkers();\r\n            }\r\n            renderSavedTimelines();\r\n            return;\r\n          }\r\n          /* Time Line √∫nica */\r\n          if (!Array.isArray(imported)) throw I18N.formato_invalido;\r\n          imported.sort(function(a, b) { return a.time - b.time; });\r\n          if (imported.length > 0) imported[0].time = 0.0;\r\n          var maxTime = imported.length > 0 ? Math.ceil(imported[imported.length - 1].time + 1) : 60;\r\n          var name = file.name.replace(/\\\\.json$/i, \"\");\r\n          savedTimelines.push({ name: name, visoes: imported, maxTime: maxTime });\r\n          renderSavedTimelines();\r\n        } catch (err) { alert(I18N.erro_importar + err); }\r\n      };\r\n      reader.readAsText(file);\r\n      input.value = \"\";\r\n    }\r\n\r\n    function switchTimeline(index) {\r\n      if (index === activeTimelineIndex) return;\r\n      /* Save current state if there's an active timeline */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n      /* Load selected timeline */\r\n      const tl = savedTimelines[index];\r\n      visoes = JSON.parse(JSON.stringify(tl.visoes));\r\n      document.getElementById(\"max_time\").value = tl.maxTime;\r\n      document.getElementById(\"timeline_range\").max = tl.maxTime;\r\n      activeTimelineIndex = index;\r\n      currentIndex = 0;\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    function deleteTimeline(index) {\r\n      if (index === activeTimelineIndex) return;\r\n      savedTimelines.splice(index, 1);\r\n      if (activeTimelineIndex > index) activeTimelineIndex--;\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    function renderSavedTimelines() {\r\n      var container = document.getElementById(\"saved_timelines_list\");\r\n      container.innerHTML = \"\";\r\n      if (savedTimelines.length === 0) { updatePlayAllButton(); return; }\r\n      var dragSrcIndex = null;\r\n\r\n      savedTimelines.forEach(function(tl, i) {\r\n        var item = document.createElement(\"div\");\r\n        item.className = \"tl-item\" + (i === activeTimelineIndex ? \" active\" : \"\");\r\n        item.draggable = true;\r\n        item.dataset.index = i;\r\n\r\n        /* Drag handle */\r\n        var handle = document.createElement(\"span\");\r\n        handle.className = \"tl-drag-handle\";\r\n        handle.innerHTML = \"&#9776;\";\r\n        item.appendChild(handle);\r\n\r\n        /* Drag events */\r\n        item.addEventListener(\"dragstart\", function(e) {\r\n          dragSrcIndex = i;\r\n          item.classList.add(\"dragging\");\r\n          e.dataTransfer.effectAllowed = \"move\";\r\n        });\r\n        item.addEventListener(\"dragover\", function(e) {\r\n          e.preventDefault();\r\n          e.dataTransfer.dropEffect = \"move\";\r\n          var rect = item.getBoundingClientRect();\r\n          var midY = rect.top + rect.height / 2;\r\n          item.classList.remove(\"drag-over-top\", \"drag-over-bottom\");\r\n          item.classList.add(e.clientY < midY ? \"drag-over-top\" : \"drag-over-bottom\");\r\n        });\r\n        item.addEventListener(\"dragleave\", function() {\r\n          item.classList.remove(\"drag-over-top\", \"drag-over-bottom\");\r\n        });\r\n        item.addEventListener(\"drop\", function(e) {\r\n          e.preventDefault();\r\n          item.classList.remove(\"drag-over-top\", \"drag-over-bottom\");\r\n          if (dragSrcIndex === null || dragSrcIndex === i) return;\r\n          var rect = item.getBoundingClientRect();\r\n          var midY = rect.top + rect.height / 2;\r\n          var targetIndex = e.clientY < midY ? i : i + 1;\r\n          if (dragSrcIndex < targetIndex) targetIndex--;\r\n          var moved = savedTimelines.splice(dragSrcIndex, 1)[0];\r\n          savedTimelines.splice(targetIndex, 0, moved);\r\n          if (activeTimelineIndex === dragSrcIndex) {\r\n            activeTimelineIndex = targetIndex;\r\n          } else if (dragSrcIndex < activeTimelineIndex && targetIndex >= activeTimelineIndex) {\r\n            activeTimelineIndex--;\r\n          } else if (dragSrcIndex > activeTimelineIndex && targetIndex <= activeTimelineIndex) {\r\n            activeTimelineIndex++;\r\n          }\r\n          renderSavedTimelines();\r\n        });\r\n        item.addEventListener(\"dragend\", function() {\r\n          item.classList.remove(\"dragging\");\r\n          dragSrcIndex = null;\r\n        });\r\n\r\n        item.onclick = function() { switchTimeline(i); };\r\n\r\n        var indicator = document.createElement(\"span\");\r\n        indicator.className = \"tl-indicator\";\r\n        item.appendChild(indicator);\r\n\r\n        var nameEl = document.createElement(\"span\");\r\n        nameEl.className = \"tl-name\";\r\n        nameEl.textContent = tl.name;\r\n        item.appendChild(nameEl);\r\n\r\n        var count = document.createElement(\"span\");\r\n        count.className = \"tl-count\";\r\n        count.textContent = tl.visoes.length + \" \" + I18N.visoes;\r\n        item.appendChild(count);\r\n\r\n        if (i !== activeTimelineIndex) {\r\n          var del = document.createElement(\"button\");\r\n          del.className = \"tl-delete\";\r\n          del.innerHTML = \"&times;\";\r\n          del.title = I18N.excluir;\r\n          del.onclick = function(e) { e.stopPropagation(); deleteTimeline(i); };\r\n          item.appendChild(del);\r\n        }\r\n\r\n        container.appendChild(item);\r\n      });\r\n\r\n      updatePlayAllButton();\r\n    }\r\n\r\n    function novaTimeline() {\r\n      var name = prompt(I18N.nova_timeline, \"Time Line \" + (savedTimelines.length + 1));\r\n      if (!name) return;\r\n      /* Salvar timeline atual na lista se pertencer a uma timeline salva */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n      /* Criar nova timeline vazia e adicion√°-la √† lista */\r\n      savedTimelines.push({ name: name, visoes: [], maxTime: 60 });\r\n      activeTimelineIndex = savedTimelines.length - 1;\r\n      /* Limpar estado */\r\n      visoes = [];\r\n      currentIndex = 0;\r\n      document.getElementById(\"max_time\").value = 60;\r\n      document.getElementById(\"timeline_range\").max = 60;\r\n      document.getElementById(\"timeline_range\").value = 0;\r\n      updateTime(0);\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    /* --- Video Export with Proportional Presets --- */\r\n    function onPresetChange() {\r\n      const sel = document.getElementById(\"preset_select\");\r\n      const preview = document.getElementById(\"preset_preview\");\r\n      const customDims = document.getElementById(\"custom_dims\");\r\n      const btnRecord = document.getElementById(\"btn_record\");\r\n      const idx = parseInt(sel.value);\r\n\r\n      if (isNaN(idx)) {\r\n        customDims.classList.remove(\"visible\");\r\n        preview.style.display = \"none\";\r\n        btnRecord.disabled = true;\r\n        if (window.sketchup) window.sketchup.hide_export_preview();\r\n        return;\r\n      }\r\n\r\n      const fmt = EXPORT_FORMATS[idx];\r\n      btnRecord.disabled = false;\r\n\r\n      if (fmt.custom) {\r\n        customDims.classList.add(\"visible\");\r\n        preview.style.display = \"none\";\r\n        if (window.sketchup) window.sketchup.hide_export_preview();\r\n      } else {\r\n        customDims.classList.remove(\"visible\");\r\n        let dims;\r\n        if (fmt.ratio) {\r\n          dims = calcEffectiveDims(fmt.ratio[0], fmt.ratio[1], viewportW, viewportH);\r\n        } else {\r\n          dims = { w: viewportW % 2 === 0 ? viewportW : viewportW - 1, h: viewportH % 2 === 0 ? viewportH : viewportH - 1 };\r\n        }\r\n        preview.textContent = I18N.area_gravacao + dims.w + \" x \" + dims.h + \" px\";\r\n        preview.style.display = \"flex\";\r\n        /* Show preview overlay in viewport */\r\n        if (window.sketchup) window.sketchup.show_export_preview(dims.w, dims.h);\r\n      }\r\n    }\r\n\r\n    function getExportDimensions() {\r\n      const sel = document.getElementById(\"preset_select\");\r\n      const idx = parseInt(sel.value);\r\n      if (isNaN(idx)) return null;\r\n      const fmt = EXPORT_FORMATS[idx];\r\n      if (fmt.custom) {\r\n        return {\r\n          w: parseInt(document.getElementById(\"custom_w\").value) || 1280,\r\n          h: parseInt(document.getElementById(\"custom_h\").value) || 720\r\n        };\r\n      }\r\n      if (fmt.ratio) {\r\n        return calcEffectiveDims(fmt.ratio[0], fmt.ratio[1], viewportW, viewportH);\r\n      }\r\n      return { w: viewportW % 2 === 0 ? viewportW : viewportW - 1, h: viewportH % 2 === 0 ? viewportH : viewportH - 1 };\r\n    }\r\n\r\n    function iniciarGravacao() {\r\n      var gravarProjeto = document.getElementById(\"rec_projeto\").checked;\r\n      var desdeInicio = document.getElementById(\"rec_inicio\").checked;\r\n\r\n      if (gravarProjeto) {\r\n        syncActiveTimeline();\r\n        var temVisoes = savedTimelines.some(function(tl) { return tl.visoes.length >= 2; });\r\n        if (!temVisoes) { alert(I18N.sem_tl_min_duas); return; }\r\n      } else {\r\n        if (visoes.length < 2) { alert(I18N.min_duas_visoes); return; }\r\n      }\r\n      var dims = getExportDimensions();\r\n      if (!dims || dims.w < 50 || dims.h < 50) { alert(I18N.dims_invalidas); return; }\r\n\r\n      /* Mostrar modal de nome */\r\n      document.getElementById(\"filename_input\").value = gravarProjeto ? \"projeto_tour\" : \"tour_final\";\r\n      document.getElementById(\"filename_modal\").style.display = \"flex\";\r\n      document.getElementById(\"filename_input\").focus();\r\n      document.getElementById(\"filename_input\").select();\r\n    }\r\n\r\n    function fecharModalFilename() {\r\n      document.getElementById(\"filename_modal\").style.display = \"none\";\r\n    }\r\n\r\n    function confirmarFilename() {\r\n      var nome = document.getElementById(\"filename_input\").value.trim();\r\n      if (!nome) { alert(I18N.digite_nome); return; }\r\n      document.getElementById(\"filename_modal\").style.display = \"none\";\r\n\r\n      var gravarProjeto = document.getElementById(\"rec_projeto\").checked;\r\n      var desdeInicio = document.getElementById(\"rec_inicio\").checked;\r\n      var dims = getExportDimensions();\r\n      var startIdx = desdeInicio ? 0 : currentIndex;\r\n\r\n      if (window.sketchup) window.sketchup.hide_export_preview();\r\n\r\n      if (gravarProjeto) {\r\n        syncActiveTimeline();\r\n        var allTimelines = JSON.stringify(savedTimelines);\r\n        var startTl = desdeInicio ? 0 : activeTimelineIndex;\r\n        var startVision = desdeInicio ? 0 : currentIndex;\r\n        if (window.sketchup) {\r\n          window.sketchup.start_export_project(\r\n            allTimelines,\r\n            document.getElementById(\"easing_checkbox\").checked,\r\n            startTl,\r\n            startVision,\r\n            dims.w,\r\n            dims.h,\r\n            nome\r\n          );\r\n        }\r\n      } else {\r\n        if (window.sketchup) {\r\n          window.sketchup.start_export_process(\r\n            JSON.stringify(visoes),\r\n            document.getElementById(\"easing_checkbox\").checked,\r\n            startIdx,\r\n            dims.w,\r\n            dims.h,\r\n            nome\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    function showRecordingIndicator() {\r\n      document.getElementById(\"recording_bar\").classList.add(\"active\");\r\n    }\r\n    function hideRecordingIndicator() {\r\n      document.getElementById(\"recording_bar\").classList.remove(\"active\");\r\n    }\r\n\r\n    function instalarExportacao() {\r\n      if (window.sketchup) { window.sketchup.install_ffmpeg(); }\r\n    }\r\n\r\n    /* --- Hotkey --- */\r\n    function mostrarCampoAtalho() {\r\n      capturingHotkey = true; pendingHotkey = null;\r\n      document.getElementById(\"hotkey_input\").value = \"\";\r\n      document.getElementById(\"hotkey_edit\").classList.add(\"visible\");\r\n      document.getElementById(\"hotkey_input\").focus();\r\n    }\r\n    function capturarAtalhoInput(e) {\r\n      e.preventDefault();\r\n      /* Ignorar teclas modificadoras sozinhas */\r\n      if ([16, 17, 18, 91, 93].includes(e.keyCode)) return;\r\n      pendingHotkey = {\r\n        keyCode: e.keyCode,\r\n        ctrl: e.ctrlKey,\r\n        alt: e.altKey,\r\n        shift: e.shiftKey\r\n      };\r\n      /* Montar label legivel */\r\n      var parts = [];\r\n      if (e.ctrlKey) parts.push(\"Ctrl\");\r\n      if (e.altKey) parts.push(\"Alt\");\r\n      if (e.shiftKey) parts.push(\"Shift\");\r\n      parts.push(e.code.replace(\"Key\", \"\").replace(\"Digit\", \"\"));\r\n      document.getElementById(\"hotkey_input\").value = parts.join(\" + \");\r\n    }\r\n    function confirmarAtalho() {\r\n      if (pendingHotkey !== null) {\r\n        hotkey = pendingHotkey;\r\n        if (window.sketchup) {\r\n          window.sketchup.set_hotkey(hotkey.keyCode, hotkey.ctrl, hotkey.alt, hotkey.shift);\r\n        }\r\n      }\r\n      capturingHotkey = false;\r\n      document.getElementById(\"hotkey_edit\").classList.remove(\"visible\");\r\n    }\r\n\r\n    /* --- Global bindings --- */\r\n    window.captureVisionFromRuby = captureVisionFromRuby;\r\n    window.resetPlayButton = resetPlayButton;\r\n    window.pauseAtIndex = pauseAtIndex;\r\n    window.triggerSpaceFromRuby = triggerSpaceFromRuby;\r\n    window.showRecordingIndicator = showRecordingIndicator;\r\n    window.hideRecordingIndicator = hideRecordingIndicator;\r\n    window.updatePlayhead = updatePlayhead;\r\n    window.resetPlayAll = resetPlayAll;\r\n    window.startRecordingPlayAll = startRecordingPlayAll;\r\n    window.addEventListener(\"resize\", () => { renderMarkers(); });\r\n\r\n    document.addEventListener(\"keydown\", (e) => {\r\n      if (!capturingHotkey &&\r\n          e.keyCode === hotkey.keyCode &&\r\n          e.ctrlKey === hotkey.ctrl &&\r\n          e.altKey === hotkey.alt &&\r\n          e.shiftKey === hotkey.shift &&\r\n          ![\"INPUT\", \"TEXTAREA\"].includes(e.target.tagName)) {\r\n        e.preventDefault(); togglePlay();\r\n      }\r\n    });\r\n\r\n    /* Init */\r\n    populatePresets();\r\n    renderMarkers();\r\n</script>\r\n</body>\r\n</html>\r\nHTML\r\n\r\n      @dialog ||= UI::HtmlDialog.new({\r\n        :dialog_title => obter_texto(:titulo_dialogo),\r\n        :preferences_key => \"com.example.tour\",\r\n        :scrollable => true,\r\n        :resizable => true,\r\n        :width => 430,\r\n        :height => 790,\r\n        :style => UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n\r\n      @dialog.set_html(html)\r\n      start_space_timer\r\n\r\n      @dialog.add_action_callback(\"set_hotkey\") do |_, key_code, ctrl, alt, shift|\r\n        GlobalKey.set_hotkey(key_code.to_i, ctrl, alt, shift)\r\n        Sketchup.write_default(\"TourVirtual\", \"Hotkey\", key_code.to_i)\r\n        Sketchup.write_default(\"TourVirtual\", \"HotkeyCtrl\", ctrl ? true : false)\r\n        Sketchup.write_default(\"TourVirtual\", \"HotkeyAlt\", alt ? true : false)\r\n        Sketchup.write_default(\"TourVirtual\", \"HotkeyShift\", shift ? true : false)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"capture_camera\") do |_, time_code|\r\n        cam = Sketchup.active_model.active_view.camera\r\n        thumb = capture_thumbnail\r\n        camera_data = {\r\n          time: time_code.to_f,\r\n          eye: cam.eye.to_a,\r\n          target: cam.target.to_a,\r\n          up: cam.up.to_a,\r\n          fov: cam.fov,\r\n          perspective: cam.perspective?,\r\n          thumb: thumb,\r\n          anchor: false\r\n        }\r\n        json_str = camera_data.to_json.gsub('\"', '\\\"')\r\n        @dialog.execute_script(\"captureVisionFromRuby(\\\"#{json_str}\\\")\")\r\n      end\r\n\r\n      @dialog.add_action_callback(\"goto_camera\") do |_, cam_json|\r\n        cam_data = JSON.parse(cam_json, symbolize_names: true)\r\n        cam = Sketchup::Camera.new(cam_data[:eye], cam_data[:target], cam_data[:up], cam_data[:perspective])\r\n        cam.fov = cam_data[:fov]\r\n        Sketchup.active_model.active_view.camera = cam\r\n      end\r\n\r\n      @dialog.add_action_callback(\"play_tour\") do |_, json_data, loop_enabled, inverse_mode, use_easing, start_index|\r\n        @camera_keys = JSON.parse(json_data, symbolize_names: true)\r\n        view = Sketchup.active_model.active_view\r\n        return if @camera_keys.length < 2\r\n        @camera_keys.sort_by! { |v| v[:time] }\r\n        @index = start_index.to_i\r\n        @direction = 1\r\n        @ping_pong = loop_enabled && inverse_mode\r\n\r\n        define_singleton_method(:ease_in_out_quad) do |t|\r\n          t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t\r\n        end\r\n\r\n        define_singleton_method(:catmull_rom) do |p0, p1, p2, p3, t|\r\n          t2 = t * t\r\n          t3 = t2 * t\r\n          [\r\n            0.5 * ((2 * p1[0]) + (-p0[0] + p2[0]) * t + (2*p0[0] - 5*p1[0] + 4*p2[0] - p3[0]) * t2 + (-p0[0] + 3*p1[0] - 3*p2[0] + p3[0]) * t3),\r\n            0.5 * ((2 * p1[1]) + (-p0[1] + p2[1]) * t + (2*p0[1] - 5*p1[1] + 4*p2[1] - p3[1]) * t2 + (-p0[1] + 3*p1[1] - 3*p2[1] + p3[1]) * t3),\r\n            0.5 * ((2 * p1[2]) + (-p0[2] + p2[2]) * t + (2*p0[2] - 5*p1[2] + 4*p2[2] - p3[2]) * t2 + (-p0[2] + 3*p1[2] - 3*p2[2] + p3[2]) * t3)\r\n          ]\r\n        end\r\n\r\n        define_singleton_method(:catmull_rom_1d) do |p0, p1, p2, p3, t|\r\n          t2 = t * t\r\n          t3 = t2 * t\r\n          0.5 * ((2 * p1) + (-p0 + p2) * t + (2*p0 - 5*p1 + 4*p2 - p3) * t2 + (-p0 + 3*p1 - 3*p2 + p3) * t3)\r\n        end\r\n\r\n        define_singleton_method(:play_transition) do\r\n          current = @camera_keys[@index]\r\n          next_index = @index + @direction\r\n\r\n          if next_index >= @camera_keys.size || next_index < 0\r\n            if loop_enabled\r\n               @index = 0\r\n               UI.start_timer(0.01) { play_transition }\r\n               return\r\n            else\r\n              @dialog.execute_script(\"pauseAtIndex(0)\")\r\n              return\r\n            end\r\n          end\r\n\r\n          next_cam = @camera_keys[next_index]\r\n          duration = (next_cam[:time] - current[:time]).abs\r\n          t_start = Time.now\r\n\r\n          p0 = @camera_keys[[@index - 1, 0].max]\r\n          p1 = current\r\n          p2 = next_cam\r\n          p3 = @camera_keys[[@index + 2, @camera_keys.size - 1].min]\r\n\r\n          @walk_shake = {\r\n            z_phase: rand * Math::PI * 2, x_phase: rand * Math::PI * 2,\r\n            z_amp: 0.8 + rand * 0.4, x_amp: 0.3 + rand * 0.4\r\n          }\r\n          playhead_counter = 0\r\n\r\n          @timer_id = UI.start_timer(0.03, true) do\r\n            t_elapsed = Time.now - t_start\r\n            t = duration.zero? ? 1.0 : [t_elapsed / duration, 1.0].min\r\n            t = use_easing ? ease_in_out_quad(t) : t\r\n\r\n            # Atualizar playhead na timeline (~a cada 0.09s)\r\n            playhead_counter += 1\r\n            if playhead_counter % 3 == 0\r\n              interpolated_time = current[:time] + t * (next_cam[:time] - current[:time])\r\n              @dialog.execute_script(\"updatePlayhead(#{interpolated_time.round(1)})\")\r\n            end\r\n\r\n            eye    = catmull_rom(p0[:eye],    p1[:eye],    p2[:eye],    p3[:eye],    t)\r\n            target = catmull_rom(p0[:target], p1[:target], p2[:target], p3[:target], t)\r\n            up     = catmull_rom(p0[:up],     p1[:up],     p2[:up],     p3[:up],     t)\r\n\r\n            # Interpola√ß√£o Catmull-Rom para o FOV: suavidade total acompanhando a curva da c√¢mera\r\n            fov = catmull_rom_1d(p0[:fov], p1[:fov], p2[:fov], p3[:fov], t)\r\n\r\n            if current[:walk]\r\n              eye[2] += Math.sin(t * Math::PI * 6 + @walk_shake[:z_phase]) * @walk_shake[:z_amp]\r\n              eye[0] += Math.sin(t * Math::PI * 3 + @walk_shake[:x_phase]) * @walk_shake[:x_amp]\r\n            end\r\n\r\n            cam = Sketchup::Camera.new(eye, target, up, current[:perspective])\r\n            cam.fov = fov\r\n            view.camera = cam\r\n            view.refresh\r\n\r\n            if t >= 1.0\r\n              UI.stop_timer(@timer_id)\r\n              @index = next_index\r\n              if @camera_keys[@index][:anchor] && @index > 0\r\n                @dialog.execute_script(\"pauseAtIndex(#{@index})\")\r\n              else\r\n                play_transition\r\n              end\r\n            end\r\n          end\r\n        end\r\n\r\n        play_transition\r\n      end\r\n\r\n      # Callback de exporta√ß√£o com presets de resolu√ß√£o\r\n      @dialog.add_action_callback(\"start_export_process\") do |_, json_data, use_easing, start_index, width, height, filename|\r\n        iniciar_processo_exportacao(json_data, use_easing, start_index, width.to_i, height.to_i, filename.to_s)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"start_export_project\") do |_, all_timelines_json, use_easing, active_tl_index, start_vision_index, width, height, filename|\r\n        iniciar_processo_exportacao_projeto(all_timelines_json, use_easing, active_tl_index.to_i, start_vision_index.to_i, width.to_i, height.to_i, filename.to_s)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"install_ffmpeg\") do |_|\r\n        eval(FFMPEG_INSTALL_SCRIPT, TOPLEVEL_BINDING)\r\n        UI.messagebox(obter_texto(:ffmpeg_instalado))\r\n      end\r\n\r\n      @dialog.add_action_callback(\"stop_tour\") do |_|\r\n        UI.stop_timer(@timer_id) if @timer_id\r\n        @dialog.execute_script(\"resetPlayButton()\")\r\n      end\r\n\r\n      @dialog.add_action_callback(\"show_export_preview\") do |_, width, height|\r\n        @preview_tool = ExportPreviewTool.new(width.to_i, height.to_i)\r\n        Sketchup.active_model.select_tool(@preview_tool)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"hide_export_preview\") do |_|\r\n        Sketchup.active_model.select_tool(nil)\r\n        @preview_tool = nil\r\n      end\r\n\r\n      @dialog.set_on_closed {\r\n        UI.stop_timer(@timer_id) if defined?(@timer_id) && @timer_id\r\n        stop_space_timer\r\n        if @preview_tool\r\n          Sketchup.active_model.select_tool(nil)\r\n          @preview_tool = nil\r\n        end\r\n      }\r\n\r\n      @dialog.show\r\n    end\r\n  end\r\nend\r\n\r\ndef self.executar\r\n  TourPlugin::CameraTimeline.start_ui\r\nend\r\n\r\nend # module TourVirtual\r\nend # module ScriptUpComunidade\r\n\r\nScriptUpComunidade::TourVirtual.executar"
    },
    "enabled": false,
    "execute": true
  }
]