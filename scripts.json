[
  {
    "id": "suavizar-segmentos-curvos-tcbdn",
    "title": {
      "pt": "Suavizar Segmentos Curvos",
      "en": "Suavizar Segmentos Curvos",
      "es": "Suavizar Segmentos Curvos"
    },
    "author": "Fábio Coutinho",
    "version": "0.5",
    "description": {
      "pt": "Adiciona segmentos em sequência de arestas (curva) para tornar mais suave.",
      "en": "Adiciona segmentos em sequência de arestas (curva) para tornar mais suave.",
      "es": "Adiciona segmentos em sequência de arestas (curva) para tornar mais suave."
    },
    "keywords": {
      "pt": [
        "suaviza curva"
      ],
      "en": [
        "suaviza curva"
      ],
      "es": [
        "suaviza curva"
      ]
    },
    "code": {
      "pt": "require 'sketchup.rb'\r\n\r\nclass SmoothPolyTool\r\n  \r\n  def initialize\r\n    @model = Sketchup.active_model\r\n    @selection = @model.selection\r\n    @view = @model.active_view\r\n    \r\n    @density_multiplier = 1\r\n    @is_loop = false \r\n    \r\n    # Coleta dados iniciais\r\n    @ordered_vertices = get_ordered_vertices(@selection)\r\n    \r\n    if @ordered_vertices.length < 2\r\n      UI.messagebox(\"Selecione uma sequência de arestas conectadas primeiro.\")\r\n      @model.select_tool(nil)\r\n      return\r\n    end\r\n\r\n    @original_segment_count = @is_loop ? @ordered_vertices.length : @ordered_vertices.length - 1\r\n    calculate_distribution_metrics\r\n\r\n    @spline_points = []\r\n    calculate_spline\r\n    \r\n    create_dialog\r\n  end\r\n\r\n  def activate\r\n    @view.invalidate\r\n    update_status\r\n  end\r\n\r\n  # Chamado quando a ferramenta é desativada (ex: usuário trocou de ferramenta ou fechou a janela)\r\n  def deactivate(view)\r\n    # Fecha a janela se ela ainda estiver aberta\r\n    if @dialog && @dialog.visible?\r\n      @dialog.close \r\n    end\r\n    @view.invalidate\r\n  end\r\n\r\n  def draw(view)\r\n    # 1. Caminho Laranja\r\n    if @spline_points && @spline_points.size > 1\r\n      view.line_width = 3\r\n      view.line_stipple = \"\" \r\n      view.drawing_color = \"orange\"\r\n      mode = @is_loop ? GL_LINE_LOOP : GL_LINE_STRIP\r\n      view.draw(mode, @spline_points)\r\n    end\r\n\r\n    # 2. Nós Vermelhos\r\n    if @spline_points && !@spline_points.empty?\r\n      if view.respond_to?(:draw_points)\r\n        view.draw_points(@spline_points, 8, 2, \"red\") \r\n      else\r\n        view.drawing_color = \"red\"\r\n        view.point_size = 8 if view.respond_to?(:point_size=)\r\n        view.draw(GL_POINTS, @spline_points)\r\n      end\r\n    end\r\n  end\r\n\r\n  # --- UI ---\r\n  def create_dialog\r\n    if defined?(UI::HtmlDialog)\r\n      @dialog = UI::HtmlDialog.new({\r\n        :dialog_title => \"Suavizar (Loop & Adaptativo)\",\r\n        :preferences_key => \"com.example.smooth_poly_final\",\r\n        :scrollable => false,\r\n        :resizable => false,\r\n        :width => 320,\r\n        :height => 260, \r\n        :style => UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n      \r\n      # --- CORREÇÃO AQUI: Detecta o fechamento da janela (botão X) ---\r\n      @dialog.set_on_closed {\r\n        # Força a saída da ferramenta selecionando 'nil' (Select Tool)\r\n        Sketchup.active_model.select_tool(nil)\r\n      }\r\n      # ---------------------------------------------------------------\r\n      \r\n    else\r\n      @dialog = UI::WebDialog.new(\"Suavizar\", false, \"SmoothPolyFinal\", 320, 260, 100, 100, true)\r\n      # WebDialog antigo não tem um set_on_closed confiável igual ao HtmlDialog,\r\n      # mas para versões modernas (2017+) o bloco acima resolve.\r\n    end\r\n\r\n    html_content = %{\r\n      <!DOCTYPE html>\r\n      <html>\r\n      <head>\r\n        <style>\r\n          body { font-family: 'Segoe UI', sans-serif; font-size: 12px; padding: 15px; background-color: #f5f5f5; color: #333; overflow: hidden; }\r\n          .container { display: flex; flex-direction: column; gap: 12px; }\r\n          .header { display: flex; justify-content: space-between; align-items: center; }\r\n          label { font-weight: 600; font-size: 13px; }\r\n          input[type=range] { width: 100%; cursor: pointer; }\r\n          .val-display { \r\n            background: #fff; border: 1px solid #ccc; padding: 2px 8px; \r\n            border-radius: 4px; font-weight: bold; color: #E65100; min-width: 30px; text-align: center;\r\n          }\r\n          button { \r\n            padding: 10px; cursor: pointer; background: #2196F3; color: white; \r\n            border: none; border-radius: 4px; font-weight: bold; font-size: 13px;\r\n            text-transform: uppercase; letter-spacing: 0.5px; transition: background 0.2s; margin-top: 5px;\r\n          }\r\n          button:hover { background: #1976D2; }\r\n          .note { font-size: 11px; color: #666; font-style: italic; line-height: 1.3; }\r\n          .tag { font-size: 10px; background: #4CAF50; color: white; padding: 2px 5px; border-radius: 3px; }\r\n        </style>\r\n      </head>\r\n      <body>\r\n        <div class=\"container\">\r\n          <div class=\"header\">\r\n            <label>Densidade:</label>\r\n            <div class=\"val-display\">x<span id=\"val\">1</span></div>\r\n          </div>\r\n          \r\n          <input type=\"range\" id=\"slider\" min=\"1\" max=\"10\" step=\"1\" value=\"1\" oninput=\"updateVal(this.value)\">\r\n          \r\n          <div class=\"note\">\r\n            <span id=\"loop-msg\" style=\"display:none;\" class=\"tag\">LOOP DETECTADO</span><br>\r\n            Ajuste a densidade. A distribuição é adaptativa (foca em curvas) e contínua.\r\n          </div>\r\n\r\n          <button onclick=\"sendApply()\">Concluir (Aplicar)</button>\r\n        </div>\r\n        <script>\r\n          function updateVal(val) {\r\n            document.getElementById('val').innerText = val;\r\n            if (window.sketchup) { sketchup.on_slide(val); } \r\n            else { window.location = 'skp:on_slide@' + val; }\r\n          }\r\n          \r\n          function sendApply() {\r\n            if (window.sketchup) { sketchup.on_apply(); } \r\n            else { window.location = 'skp:on_apply'; }\r\n          }\r\n\r\n          function setLoopStatus(isLoop) {\r\n             if(isLoop) document.getElementById('loop-msg').style.display = 'inline-block';\r\n          }\r\n        </script>\r\n      </body>\r\n      </html>\r\n    }\r\n\r\n    @dialog.set_html(html_content)\r\n    \r\n    @dialog.add_action_callback(\"on_slide\") { |_, val|\r\n      @density_multiplier = val.to_i\r\n      calculate_spline\r\n      @view.invalidate\r\n    }\r\n\r\n    @dialog.add_action_callback(\"on_apply\") { \r\n      commit_geometry\r\n      # Ao selecionar nil aqui, o método deactivate será chamado, fechando a janela\r\n      @model.select_tool(nil)\r\n    }\r\n\r\n    @dialog.add_action_callback(\"exec_js\") { |_, js| @dialog.execute_script(js) }\r\n    \r\n    if @dialog.respond_to?(:center)\r\n      @dialog.center\r\n      @dialog.show\r\n    else\r\n      @dialog.show\r\n    end\r\n\r\n    UI.start_timer(0.5, false) { \r\n      @dialog.execute_script(\"setLoopStatus(#{@is_loop});\") if @dialog.visible?\r\n    }\r\n  end\r\n\r\n  # --- Lógica Matemática ---\r\n\r\n  def get_neighbors(i, points)\r\n    n = points.length\r\n    if @is_loop\r\n      p0 = points[(i - 1) % n]\r\n      p1 = points[i]\r\n      p2 = points[(i + 1) % n]\r\n      p3 = points[(i + 2) % n]\r\n    else\r\n      p0 = i == 0 ? points[0] : points[i-1]\r\n      p1 = points[i]\r\n      p2 = (i+1 >= n) ? points[n-1] : points[i+1]\r\n      p3 = (i+2 >= n) ? points[n-1] : points[i+2]\r\n    end\r\n    return p0, p1, p2, p3\r\n  end\r\n\r\n  def calculate_distribution_metrics\r\n    points = @ordered_vertices\r\n    @segment_weights = []\r\n    total_w = 0.0\r\n    limit = @is_loop ? points.length : points.length - 1\r\n\r\n    (0...limit).each do |i|\r\n      p0, p1, p2, p3 = get_neighbors(i, points)\r\n      len = p1.distance(p2)\r\n      \r\n      v_prev = p1 - p0\r\n      v_curr = p2 - p1\r\n      v_next = p3 - p2\r\n\r\n      angle_start = (v_prev.length > 0 && v_curr.length > 0) ? v_prev.angle_between(v_curr) : 0\r\n      angle_end   = (v_curr.length > 0 && v_next.length > 0) ? v_curr.angle_between(v_next) : 0\r\n      \r\n      avg_curvature = (angle_start + angle_end) / 2.0\r\n      curvature_factor = 1.0 + (avg_curvature * 3.0)\r\n\r\n      weighted_len = len * curvature_factor\r\n      @segment_weights << weighted_len\r\n      total_w += weighted_len\r\n    end\r\n    @total_weighted_length = total_w\r\n  end\r\n\r\n  def calculate_spline\r\n    return if @ordered_vertices.empty?\r\n    points = @ordered_vertices\r\n    @spline_points = []\r\n    \r\n    target_total_segments = [(@original_segment_count * @density_multiplier).round, 1].max\r\n    points_accumulator = 0.0\r\n    limit = @is_loop ? points.length : points.length - 1\r\n\r\n    (0...limit).each do |i|\r\n      p0, p1, p2, p3 = get_neighbors(i, points)\r\n      @spline_points << p1\r\n      \r\n      weighted_len = @segment_weights[i]\r\n      ratio = (@total_weighted_length > 0) ? (weighted_len / @total_weighted_length) : 0\r\n\r\n      exact_steps = ratio * target_total_segments\r\n      points_accumulator += exact_steps\r\n      \r\n      steps_to_draw = points_accumulator.floor\r\n      points_accumulator -= steps_to_draw\r\n\r\n      steps_final = steps_to_draw + 1\r\n\r\n      (1...steps_final).each do |t_step|\r\n        t = t_step.to_f / steps_final\r\n        @spline_points << catmull_rom(p0, p1, p2, p3, t)\r\n      end\r\n    end\r\n    \r\n    if @is_loop\r\n      @spline_points << @spline_points.first\r\n    else\r\n      @spline_points << points.last\r\n    end\r\n  end\r\n\r\n  def catmull_rom(p0, p1, p2, p3, t)\r\n    t2 = t * t\r\n    t3 = t2 * t\r\n    x = 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * t + (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 + (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3)\r\n    y = 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3)\r\n    z = 0.5 * ((2 * p1.z) + (-p0.z + p2.z) * t + (2 * p0.z - 5 * p1.z + 4 * p2.z - p3.z) * t2 + (-p0.z + 3 * p1.z - 3 * p2.z + p3.z) * t3)\r\n    Geom::Point3d.new(x, y, z)\r\n  end\r\n\r\n  def commit_geometry\r\n    edges_to_delete = @selection.grep(Sketchup::Edge)\r\n    return if edges_to_delete.empty?\r\n    \r\n    @model.start_operation(\"Suavizar (Loop)\", true)\r\n    @model.active_entities.erase_entities(edges_to_delete)\r\n    if @spline_points.size > 1\r\n      @model.active_entities.add_curve(@spline_points)\r\n    end\r\n    @model.commit_operation\r\n    @spline_points = []\r\n  end\r\n\r\n  def get_ordered_vertices(selection)\r\n    edges = selection.grep(Sketchup::Edge)\r\n    return [] if edges.empty?\r\n\r\n    vertices = edges.map(&:vertices).flatten\r\n    counts = vertices.each_with_object(Hash.new(0)) { |v, h| h[v] += 1 }\r\n    \r\n    if counts.values.all? { |c| c == 2 }\r\n      @is_loop = true\r\n      start_vertex = edges.first.start \r\n    else\r\n      @is_loop = false\r\n      start_vertex = counts.key(1) \r\n    end\r\n    \r\n    start_vertex ||= edges.first.start \r\n\r\n    sorted_points = [start_vertex.position]\r\n    current_v = start_vertex\r\n    visited_edges = []\r\n    \r\n    while true\r\n      next_edge = current_v.edges.find { |e| edges.include?(e) && !visited_edges.include?(e) }\r\n      break unless next_edge\r\n      visited_edges << next_edge\r\n      other_v = next_edge.other_vertex(current_v)\r\n      if @is_loop && other_v == start_vertex\r\n        break\r\n      end\r\n      sorted_points << other_v.position\r\n      current_v = other_v\r\n    end\r\n\r\n    sorted_points\r\n  end\r\n  \r\n  def update_status\r\n     Sketchup.set_status_text(\"Suavizar: Loop = #{@is_loop ? 'Sim' : 'Não'}\")\r\n  end\r\nend\r\n\r\nSketchup.active_model.select_tool(SmoothPolyTool.new)",
      "en": "require 'sketchup.rb'\r\n\r\nclass SmoothPolyTool\r\n  \r\n  def initialize\r\n    @model = Sketchup.active_model\r\n    @selection = @model.selection\r\n    @view = @model.active_view\r\n    \r\n    @density_multiplier = 1\r\n    @is_loop = false \r\n    \r\n    # Coleta dados iniciais\r\n    @ordered_vertices = get_ordered_vertices(@selection)\r\n    \r\n    if @ordered_vertices.length < 2\r\n      UI.messagebox(\"Selecione uma sequência de arestas conectadas primeiro.\")\r\n      @model.select_tool(nil)\r\n      return\r\n    end\r\n\r\n    @original_segment_count = @is_loop ? @ordered_vertices.length : @ordered_vertices.length - 1\r\n    calculate_distribution_metrics\r\n\r\n    @spline_points = []\r\n    calculate_spline\r\n    \r\n    create_dialog\r\n  end\r\n\r\n  def activate\r\n    @view.invalidate\r\n    update_status\r\n  end\r\n\r\n  # Chamado quando a ferramenta é desativada (ex: usuário trocou de ferramenta ou fechou a janela)\r\n  def deactivate(view)\r\n    # Fecha a janela se ela ainda estiver aberta\r\n    if @dialog && @dialog.visible?\r\n      @dialog.close \r\n    end\r\n    @view.invalidate\r\n  end\r\n\r\n  def draw(view)\r\n    # 1. Caminho Laranja\r\n    if @spline_points && @spline_points.size > 1\r\n      view.line_width = 3\r\n      view.line_stipple = \"\" \r\n      view.drawing_color = \"orange\"\r\n      mode = @is_loop ? GL_LINE_LOOP : GL_LINE_STRIP\r\n      view.draw(mode, @spline_points)\r\n    end\r\n\r\n    # 2. Nós Vermelhos\r\n    if @spline_points && !@spline_points.empty?\r\n      if view.respond_to?(:draw_points)\r\n        view.draw_points(@spline_points, 8, 2, \"red\") \r\n      else\r\n        view.drawing_color = \"red\"\r\n        view.point_size = 8 if view.respond_to?(:point_size=)\r\n        view.draw(GL_POINTS, @spline_points)\r\n      end\r\n    end\r\n  end\r\n\r\n  # --- UI ---\r\n  def create_dialog\r\n    if defined?(UI::HtmlDialog)\r\n      @dialog = UI::HtmlDialog.new({\r\n        :dialog_title => \"Suavizar (Loop & Adaptativo)\",\r\n        :preferences_key => \"com.example.smooth_poly_final\",\r\n        :scrollable => false,\r\n        :resizable => false,\r\n        :width => 320,\r\n        :height => 260, \r\n        :style => UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n      \r\n      # --- CORREÇÃO AQUI: Detecta o fechamento da janela (botão X) ---\r\n      @dialog.set_on_closed {\r\n        # Força a saída da ferramenta selecionando 'nil' (Select Tool)\r\n        Sketchup.active_model.select_tool(nil)\r\n      }\r\n      # ---------------------------------------------------------------\r\n      \r\n    else\r\n      @dialog = UI::WebDialog.new(\"Suavizar\", false, \"SmoothPolyFinal\", 320, 260, 100, 100, true)\r\n      # WebDialog antigo não tem um set_on_closed confiável igual ao HtmlDialog,\r\n      # mas para versões modernas (2017+) o bloco acima resolve.\r\n    end\r\n\r\n    html_content = %{\r\n      <!DOCTYPE html>\r\n      <html>\r\n      <head>\r\n        <style>\r\n          body { font-family: 'Segoe UI', sans-serif; font-size: 12px; padding: 15px; background-color: #f5f5f5; color: #333; overflow: hidden; }\r\n          .container { display: flex; flex-direction: column; gap: 12px; }\r\n          .header { display: flex; justify-content: space-between; align-items: center; }\r\n          label { font-weight: 600; font-size: 13px; }\r\n          input[type=range] { width: 100%; cursor: pointer; }\r\n          .val-display { \r\n            background: #fff; border: 1px solid #ccc; padding: 2px 8px; \r\n            border-radius: 4px; font-weight: bold; color: #E65100; min-width: 30px; text-align: center;\r\n          }\r\n          button { \r\n            padding: 10px; cursor: pointer; background: #2196F3; color: white; \r\n            border: none; border-radius: 4px; font-weight: bold; font-size: 13px;\r\n            text-transform: uppercase; letter-spacing: 0.5px; transition: background 0.2s; margin-top: 5px;\r\n          }\r\n          button:hover { background: #1976D2; }\r\n          .note { font-size: 11px; color: #666; font-style: italic; line-height: 1.3; }\r\n          .tag { font-size: 10px; background: #4CAF50; color: white; padding: 2px 5px; border-radius: 3px; }\r\n        </style>\r\n      </head>\r\n      <body>\r\n        <div class=\"container\">\r\n          <div class=\"header\">\r\n            <label>Densidade:</label>\r\n            <div class=\"val-display\">x<span id=\"val\">1</span></div>\r\n          </div>\r\n          \r\n          <input type=\"range\" id=\"slider\" min=\"1\" max=\"10\" step=\"1\" value=\"1\" oninput=\"updateVal(this.value)\">\r\n          \r\n          <div class=\"note\">\r\n            <span id=\"loop-msg\" style=\"display:none;\" class=\"tag\">LOOP DETECTADO</span><br>\r\n            Ajuste a densidade. A distribuição é adaptativa (foca em curvas) e contínua.\r\n          </div>\r\n\r\n          <button onclick=\"sendApply()\">Concluir (Aplicar)</button>\r\n        </div>\r\n        <script>\r\n          function updateVal(val) {\r\n            document.getElementById('val').innerText = val;\r\n            if (window.sketchup) { sketchup.on_slide(val); } \r\n            else { window.location = 'skp:on_slide@' + val; }\r\n          }\r\n          \r\n          function sendApply() {\r\n            if (window.sketchup) { sketchup.on_apply(); } \r\n            else { window.location = 'skp:on_apply'; }\r\n          }\r\n\r\n          function setLoopStatus(isLoop) {\r\n             if(isLoop) document.getElementById('loop-msg').style.display = 'inline-block';\r\n          }\r\n        </script>\r\n      </body>\r\n      </html>\r\n    }\r\n\r\n    @dialog.set_html(html_content)\r\n    \r\n    @dialog.add_action_callback(\"on_slide\") { |_, val|\r\n      @density_multiplier = val.to_i\r\n      calculate_spline\r\n      @view.invalidate\r\n    }\r\n\r\n    @dialog.add_action_callback(\"on_apply\") { \r\n      commit_geometry\r\n      # Ao selecionar nil aqui, o método deactivate será chamado, fechando a janela\r\n      @model.select_tool(nil)\r\n    }\r\n\r\n    @dialog.add_action_callback(\"exec_js\") { |_, js| @dialog.execute_script(js) }\r\n    \r\n    if @dialog.respond_to?(:center)\r\n      @dialog.center\r\n      @dialog.show\r\n    else\r\n      @dialog.show\r\n    end\r\n\r\n    UI.start_timer(0.5, false) { \r\n      @dialog.execute_script(\"setLoopStatus(#{@is_loop});\") if @dialog.visible?\r\n    }\r\n  end\r\n\r\n  # --- Lógica Matemática ---\r\n\r\n  def get_neighbors(i, points)\r\n    n = points.length\r\n    if @is_loop\r\n      p0 = points[(i - 1) % n]\r\n      p1 = points[i]\r\n      p2 = points[(i + 1) % n]\r\n      p3 = points[(i + 2) % n]\r\n    else\r\n      p0 = i == 0 ? points[0] : points[i-1]\r\n      p1 = points[i]\r\n      p2 = (i+1 >= n) ? points[n-1] : points[i+1]\r\n      p3 = (i+2 >= n) ? points[n-1] : points[i+2]\r\n    end\r\n    return p0, p1, p2, p3\r\n  end\r\n\r\n  def calculate_distribution_metrics\r\n    points = @ordered_vertices\r\n    @segment_weights = []\r\n    total_w = 0.0\r\n    limit = @is_loop ? points.length : points.length - 1\r\n\r\n    (0...limit).each do |i|\r\n      p0, p1, p2, p3 = get_neighbors(i, points)\r\n      len = p1.distance(p2)\r\n      \r\n      v_prev = p1 - p0\r\n      v_curr = p2 - p1\r\n      v_next = p3 - p2\r\n\r\n      angle_start = (v_prev.length > 0 && v_curr.length > 0) ? v_prev.angle_between(v_curr) : 0\r\n      angle_end   = (v_curr.length > 0 && v_next.length > 0) ? v_curr.angle_between(v_next) : 0\r\n      \r\n      avg_curvature = (angle_start + angle_end) / 2.0\r\n      curvature_factor = 1.0 + (avg_curvature * 3.0)\r\n\r\n      weighted_len = len * curvature_factor\r\n      @segment_weights << weighted_len\r\n      total_w += weighted_len\r\n    end\r\n    @total_weighted_length = total_w\r\n  end\r\n\r\n  def calculate_spline\r\n    return if @ordered_vertices.empty?\r\n    points = @ordered_vertices\r\n    @spline_points = []\r\n    \r\n    target_total_segments = [(@original_segment_count * @density_multiplier).round, 1].max\r\n    points_accumulator = 0.0\r\n    limit = @is_loop ? points.length : points.length - 1\r\n\r\n    (0...limit).each do |i|\r\n      p0, p1, p2, p3 = get_neighbors(i, points)\r\n      @spline_points << p1\r\n      \r\n      weighted_len = @segment_weights[i]\r\n      ratio = (@total_weighted_length > 0) ? (weighted_len / @total_weighted_length) : 0\r\n\r\n      exact_steps = ratio * target_total_segments\r\n      points_accumulator += exact_steps\r\n      \r\n      steps_to_draw = points_accumulator.floor\r\n      points_accumulator -= steps_to_draw\r\n\r\n      steps_final = steps_to_draw + 1\r\n\r\n      (1...steps_final).each do |t_step|\r\n        t = t_step.to_f / steps_final\r\n        @spline_points << catmull_rom(p0, p1, p2, p3, t)\r\n      end\r\n    end\r\n    \r\n    if @is_loop\r\n      @spline_points << @spline_points.first\r\n    else\r\n      @spline_points << points.last\r\n    end\r\n  end\r\n\r\n  def catmull_rom(p0, p1, p2, p3, t)\r\n    t2 = t * t\r\n    t3 = t2 * t\r\n    x = 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * t + (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 + (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3)\r\n    y = 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3)\r\n    z = 0.5 * ((2 * p1.z) + (-p0.z + p2.z) * t + (2 * p0.z - 5 * p1.z + 4 * p2.z - p3.z) * t2 + (-p0.z + 3 * p1.z - 3 * p2.z + p3.z) * t3)\r\n    Geom::Point3d.new(x, y, z)\r\n  end\r\n\r\n  def commit_geometry\r\n    edges_to_delete = @selection.grep(Sketchup::Edge)\r\n    return if edges_to_delete.empty?\r\n    \r\n    @model.start_operation(\"Suavizar (Loop)\", true)\r\n    @model.active_entities.erase_entities(edges_to_delete)\r\n    if @spline_points.size > 1\r\n      @model.active_entities.add_curve(@spline_points)\r\n    end\r\n    @model.commit_operation\r\n    @spline_points = []\r\n  end\r\n\r\n  def get_ordered_vertices(selection)\r\n    edges = selection.grep(Sketchup::Edge)\r\n    return [] if edges.empty?\r\n\r\n    vertices = edges.map(&:vertices).flatten\r\n    counts = vertices.each_with_object(Hash.new(0)) { |v, h| h[v] += 1 }\r\n    \r\n    if counts.values.all? { |c| c == 2 }\r\n      @is_loop = true\r\n      start_vertex = edges.first.start \r\n    else\r\n      @is_loop = false\r\n      start_vertex = counts.key(1) \r\n    end\r\n    \r\n    start_vertex ||= edges.first.start \r\n\r\n    sorted_points = [start_vertex.position]\r\n    current_v = start_vertex\r\n    visited_edges = []\r\n    \r\n    while true\r\n      next_edge = current_v.edges.find { |e| edges.include?(e) && !visited_edges.include?(e) }\r\n      break unless next_edge\r\n      visited_edges << next_edge\r\n      other_v = next_edge.other_vertex(current_v)\r\n      if @is_loop && other_v == start_vertex\r\n        break\r\n      end\r\n      sorted_points << other_v.position\r\n      current_v = other_v\r\n    end\r\n\r\n    sorted_points\r\n  end\r\n  \r\n  def update_status\r\n     Sketchup.set_status_text(\"Suavizar: Loop = #{@is_loop ? 'Sim' : 'Não'}\")\r\n  end\r\nend\r\n\r\nSketchup.active_model.select_tool(SmoothPolyTool.new)",
      "es": "require 'sketchup.rb'\r\n\r\nclass SmoothPolyTool\r\n  \r\n  def initialize\r\n    @model = Sketchup.active_model\r\n    @selection = @model.selection\r\n    @view = @model.active_view\r\n    \r\n    @density_multiplier = 1\r\n    @is_loop = false \r\n    \r\n    # Coleta dados iniciais\r\n    @ordered_vertices = get_ordered_vertices(@selection)\r\n    \r\n    if @ordered_vertices.length < 2\r\n      UI.messagebox(\"Selecione uma sequência de arestas conectadas primeiro.\")\r\n      @model.select_tool(nil)\r\n      return\r\n    end\r\n\r\n    @original_segment_count = @is_loop ? @ordered_vertices.length : @ordered_vertices.length - 1\r\n    calculate_distribution_metrics\r\n\r\n    @spline_points = []\r\n    calculate_spline\r\n    \r\n    create_dialog\r\n  end\r\n\r\n  def activate\r\n    @view.invalidate\r\n    update_status\r\n  end\r\n\r\n  # Chamado quando a ferramenta é desativada (ex: usuário trocou de ferramenta ou fechou a janela)\r\n  def deactivate(view)\r\n    # Fecha a janela se ela ainda estiver aberta\r\n    if @dialog && @dialog.visible?\r\n      @dialog.close \r\n    end\r\n    @view.invalidate\r\n  end\r\n\r\n  def draw(view)\r\n    # 1. Caminho Laranja\r\n    if @spline_points && @spline_points.size > 1\r\n      view.line_width = 3\r\n      view.line_stipple = \"\" \r\n      view.drawing_color = \"orange\"\r\n      mode = @is_loop ? GL_LINE_LOOP : GL_LINE_STRIP\r\n      view.draw(mode, @spline_points)\r\n    end\r\n\r\n    # 2. Nós Vermelhos\r\n    if @spline_points && !@spline_points.empty?\r\n      if view.respond_to?(:draw_points)\r\n        view.draw_points(@spline_points, 8, 2, \"red\") \r\n      else\r\n        view.drawing_color = \"red\"\r\n        view.point_size = 8 if view.respond_to?(:point_size=)\r\n        view.draw(GL_POINTS, @spline_points)\r\n      end\r\n    end\r\n  end\r\n\r\n  # --- UI ---\r\n  def create_dialog\r\n    if defined?(UI::HtmlDialog)\r\n      @dialog = UI::HtmlDialog.new({\r\n        :dialog_title => \"Suavizar (Loop & Adaptativo)\",\r\n        :preferences_key => \"com.example.smooth_poly_final\",\r\n        :scrollable => false,\r\n        :resizable => false,\r\n        :width => 320,\r\n        :height => 260, \r\n        :style => UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n      \r\n      # --- CORREÇÃO AQUI: Detecta o fechamento da janela (botão X) ---\r\n      @dialog.set_on_closed {\r\n        # Força a saída da ferramenta selecionando 'nil' (Select Tool)\r\n        Sketchup.active_model.select_tool(nil)\r\n      }\r\n      # ---------------------------------------------------------------\r\n      \r\n    else\r\n      @dialog = UI::WebDialog.new(\"Suavizar\", false, \"SmoothPolyFinal\", 320, 260, 100, 100, true)\r\n      # WebDialog antigo não tem um set_on_closed confiável igual ao HtmlDialog,\r\n      # mas para versões modernas (2017+) o bloco acima resolve.\r\n    end\r\n\r\n    html_content = %{\r\n      <!DOCTYPE html>\r\n      <html>\r\n      <head>\r\n        <style>\r\n          body { font-family: 'Segoe UI', sans-serif; font-size: 12px; padding: 15px; background-color: #f5f5f5; color: #333; overflow: hidden; }\r\n          .container { display: flex; flex-direction: column; gap: 12px; }\r\n          .header { display: flex; justify-content: space-between; align-items: center; }\r\n          label { font-weight: 600; font-size: 13px; }\r\n          input[type=range] { width: 100%; cursor: pointer; }\r\n          .val-display { \r\n            background: #fff; border: 1px solid #ccc; padding: 2px 8px; \r\n            border-radius: 4px; font-weight: bold; color: #E65100; min-width: 30px; text-align: center;\r\n          }\r\n          button { \r\n            padding: 10px; cursor: pointer; background: #2196F3; color: white; \r\n            border: none; border-radius: 4px; font-weight: bold; font-size: 13px;\r\n            text-transform: uppercase; letter-spacing: 0.5px; transition: background 0.2s; margin-top: 5px;\r\n          }\r\n          button:hover { background: #1976D2; }\r\n          .note { font-size: 11px; color: #666; font-style: italic; line-height: 1.3; }\r\n          .tag { font-size: 10px; background: #4CAF50; color: white; padding: 2px 5px; border-radius: 3px; }\r\n        </style>\r\n      </head>\r\n      <body>\r\n        <div class=\"container\">\r\n          <div class=\"header\">\r\n            <label>Densidade:</label>\r\n            <div class=\"val-display\">x<span id=\"val\">1</span></div>\r\n          </div>\r\n          \r\n          <input type=\"range\" id=\"slider\" min=\"1\" max=\"10\" step=\"1\" value=\"1\" oninput=\"updateVal(this.value)\">\r\n          \r\n          <div class=\"note\">\r\n            <span id=\"loop-msg\" style=\"display:none;\" class=\"tag\">LOOP DETECTADO</span><br>\r\n            Ajuste a densidade. A distribuição é adaptativa (foca em curvas) e contínua.\r\n          </div>\r\n\r\n          <button onclick=\"sendApply()\">Concluir (Aplicar)</button>\r\n        </div>\r\n        <script>\r\n          function updateVal(val) {\r\n            document.getElementById('val').innerText = val;\r\n            if (window.sketchup) { sketchup.on_slide(val); } \r\n            else { window.location = 'skp:on_slide@' + val; }\r\n          }\r\n          \r\n          function sendApply() {\r\n            if (window.sketchup) { sketchup.on_apply(); } \r\n            else { window.location = 'skp:on_apply'; }\r\n          }\r\n\r\n          function setLoopStatus(isLoop) {\r\n             if(isLoop) document.getElementById('loop-msg').style.display = 'inline-block';\r\n          }\r\n        </script>\r\n      </body>\r\n      </html>\r\n    }\r\n\r\n    @dialog.set_html(html_content)\r\n    \r\n    @dialog.add_action_callback(\"on_slide\") { |_, val|\r\n      @density_multiplier = val.to_i\r\n      calculate_spline\r\n      @view.invalidate\r\n    }\r\n\r\n    @dialog.add_action_callback(\"on_apply\") { \r\n      commit_geometry\r\n      # Ao selecionar nil aqui, o método deactivate será chamado, fechando a janela\r\n      @model.select_tool(nil)\r\n    }\r\n\r\n    @dialog.add_action_callback(\"exec_js\") { |_, js| @dialog.execute_script(js) }\r\n    \r\n    if @dialog.respond_to?(:center)\r\n      @dialog.center\r\n      @dialog.show\r\n    else\r\n      @dialog.show\r\n    end\r\n\r\n    UI.start_timer(0.5, false) { \r\n      @dialog.execute_script(\"setLoopStatus(#{@is_loop});\") if @dialog.visible?\r\n    }\r\n  end\r\n\r\n  # --- Lógica Matemática ---\r\n\r\n  def get_neighbors(i, points)\r\n    n = points.length\r\n    if @is_loop\r\n      p0 = points[(i - 1) % n]\r\n      p1 = points[i]\r\n      p2 = points[(i + 1) % n]\r\n      p3 = points[(i + 2) % n]\r\n    else\r\n      p0 = i == 0 ? points[0] : points[i-1]\r\n      p1 = points[i]\r\n      p2 = (i+1 >= n) ? points[n-1] : points[i+1]\r\n      p3 = (i+2 >= n) ? points[n-1] : points[i+2]\r\n    end\r\n    return p0, p1, p2, p3\r\n  end\r\n\r\n  def calculate_distribution_metrics\r\n    points = @ordered_vertices\r\n    @segment_weights = []\r\n    total_w = 0.0\r\n    limit = @is_loop ? points.length : points.length - 1\r\n\r\n    (0...limit).each do |i|\r\n      p0, p1, p2, p3 = get_neighbors(i, points)\r\n      len = p1.distance(p2)\r\n      \r\n      v_prev = p1 - p0\r\n      v_curr = p2 - p1\r\n      v_next = p3 - p2\r\n\r\n      angle_start = (v_prev.length > 0 && v_curr.length > 0) ? v_prev.angle_between(v_curr) : 0\r\n      angle_end   = (v_curr.length > 0 && v_next.length > 0) ? v_curr.angle_between(v_next) : 0\r\n      \r\n      avg_curvature = (angle_start + angle_end) / 2.0\r\n      curvature_factor = 1.0 + (avg_curvature * 3.0)\r\n\r\n      weighted_len = len * curvature_factor\r\n      @segment_weights << weighted_len\r\n      total_w += weighted_len\r\n    end\r\n    @total_weighted_length = total_w\r\n  end\r\n\r\n  def calculate_spline\r\n    return if @ordered_vertices.empty?\r\n    points = @ordered_vertices\r\n    @spline_points = []\r\n    \r\n    target_total_segments = [(@original_segment_count * @density_multiplier).round, 1].max\r\n    points_accumulator = 0.0\r\n    limit = @is_loop ? points.length : points.length - 1\r\n\r\n    (0...limit).each do |i|\r\n      p0, p1, p2, p3 = get_neighbors(i, points)\r\n      @spline_points << p1\r\n      \r\n      weighted_len = @segment_weights[i]\r\n      ratio = (@total_weighted_length > 0) ? (weighted_len / @total_weighted_length) : 0\r\n\r\n      exact_steps = ratio * target_total_segments\r\n      points_accumulator += exact_steps\r\n      \r\n      steps_to_draw = points_accumulator.floor\r\n      points_accumulator -= steps_to_draw\r\n\r\n      steps_final = steps_to_draw + 1\r\n\r\n      (1...steps_final).each do |t_step|\r\n        t = t_step.to_f / steps_final\r\n        @spline_points << catmull_rom(p0, p1, p2, p3, t)\r\n      end\r\n    end\r\n    \r\n    if @is_loop\r\n      @spline_points << @spline_points.first\r\n    else\r\n      @spline_points << points.last\r\n    end\r\n  end\r\n\r\n  def catmull_rom(p0, p1, p2, p3, t)\r\n    t2 = t * t\r\n    t3 = t2 * t\r\n    x = 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * t + (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 + (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3)\r\n    y = 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3)\r\n    z = 0.5 * ((2 * p1.z) + (-p0.z + p2.z) * t + (2 * p0.z - 5 * p1.z + 4 * p2.z - p3.z) * t2 + (-p0.z + 3 * p1.z - 3 * p2.z + p3.z) * t3)\r\n    Geom::Point3d.new(x, y, z)\r\n  end\r\n\r\n  def commit_geometry\r\n    edges_to_delete = @selection.grep(Sketchup::Edge)\r\n    return if edges_to_delete.empty?\r\n    \r\n    @model.start_operation(\"Suavizar (Loop)\", true)\r\n    @model.active_entities.erase_entities(edges_to_delete)\r\n    if @spline_points.size > 1\r\n      @model.active_entities.add_curve(@spline_points)\r\n    end\r\n    @model.commit_operation\r\n    @spline_points = []\r\n  end\r\n\r\n  def get_ordered_vertices(selection)\r\n    edges = selection.grep(Sketchup::Edge)\r\n    return [] if edges.empty?\r\n\r\n    vertices = edges.map(&:vertices).flatten\r\n    counts = vertices.each_with_object(Hash.new(0)) { |v, h| h[v] += 1 }\r\n    \r\n    if counts.values.all? { |c| c == 2 }\r\n      @is_loop = true\r\n      start_vertex = edges.first.start \r\n    else\r\n      @is_loop = false\r\n      start_vertex = counts.key(1) \r\n    end\r\n    \r\n    start_vertex ||= edges.first.start \r\n\r\n    sorted_points = [start_vertex.position]\r\n    current_v = start_vertex\r\n    visited_edges = []\r\n    \r\n    while true\r\n      next_edge = current_v.edges.find { |e| edges.include?(e) && !visited_edges.include?(e) }\r\n      break unless next_edge\r\n      visited_edges << next_edge\r\n      other_v = next_edge.other_vertex(current_v)\r\n      if @is_loop && other_v == start_vertex\r\n        break\r\n      end\r\n      sorted_points << other_v.position\r\n      current_v = other_v\r\n    end\r\n\r\n    sorted_points\r\n  end\r\n  \r\n  def update_status\r\n     Sketchup.set_status_text(\"Suavizar: Loop = #{@is_loop ? 'Sim' : 'Não'}\")\r\n  end\r\nend\r\n\r\nSketchup.active_model.select_tool(SmoothPolyTool.new)"
    },
    "enabled": false,
    "execute": true,
    "video": "https://youtu.be/nd8rkwn6BlU?si=a7OmdvWuj5juB07S"
  },
  {
    "id": "cria-textura-a-partir-da-malha-tm3dj",
    "title": {
      "pt": "Cria Textura a Partir da Malha",
      "en": "Cria Textura a Partir da Malha",
      "es": "Cria Textura a Partir da Malha"
    },
    "author": "Fábio Coutinho",
    "version": "0.1",
    "description": {
      "pt": "Cria um material com textura a partir de uma malha plana desenhada com suas arestas e cores ou texturas aplicadas, para ser usada em outra face.",
      "en": "Cria um material com textura a partir de uma malha plana desenhada com suas arestas e cores ou texturas aplicadas, para ser usada em outra face.",
      "es": "Cria um material com textura a partir de uma malha plana desenhada com suas arestas e cores ou texturas aplicadas, para ser usada em outra face."
    },
    "keywords": {
      "pt": [
        "textura"
      ],
      "en": [
        "textura"
      ],
      "es": [
        "textura"
      ]
    },
    "code": {
      "pt": "# ============================================================\r\n# BAKE TEXTURE (MALHA -> NOVO MATERIAL) | SketchUp Ruby Console\r\n# Saída em BMP 32-bit (sem ImageRep vazio)\r\n# ============================================================\r\n\r\nrequire 'sketchup.rb'\r\nrequire 'tmpdir'\r\n\r\nObject.send(:remove_const, :PBD_BakeMeshTexture) if defined?(PBD_BakeMeshTexture)\r\n\r\nmodule PBD_BakeMeshTexture\r\n  extend self\r\n\r\n  DEFAULT_TEX_SIZE = 2048\r\n\r\n  def run(tex_size: DEFAULT_TEX_SIZE)\r\n    m = Sketchup.active_model\r\n    sel = m.selection\r\n    raise \"Selecione faces ou um grupo/componente contendo a malha.\" if sel.empty?\r\n\r\n    faces = collect_faces(sel)\r\n    raise \"Nenhuma face encontrada na seleção.\" if faces.empty?\r\n\r\n    # normal média (plano de projeção)\r\n    n = Geom::Vector3d.new(0,0,0)\r\n    faces.each { |f| n += f.normal }\r\n    n.length < 1e-9 ? (n = Geom::Vector3d.new(0,0,1)) : n.normalize!\r\n\r\n    ref = (n.parallel?(Geom::Vector3d.new(0,0,1)) ? Geom::Vector3d.new(1,0,0) : Geom::Vector3d.new(0,0,1))\r\n    xaxis = n * ref\r\n    xaxis.length < 1e-9 ? (xaxis = Geom::Vector3d.new(1,0,0)) : xaxis.normalize!\r\n    yaxis = n * xaxis\r\n    yaxis.normalize!\r\n\r\n    origin = faces[0].bounds.center\r\n    world_to_plane = Geom::Transformation.axes(origin, xaxis, yaxis, n).inverse\r\n\r\n    # bbox 2D projetado\r\n    bb2 = Geom::BoundingBox.new\r\n    faces.each do |f|\r\n      f.vertices.each do |v|\r\n        p = v.position.transform(world_to_plane)\r\n        bb2.add([p.x, p.y, 0])\r\n      end\r\n    end\r\n\r\n    minx = bb2.min.x\r\n    miny = bb2.min.y\r\n    maxx = bb2.max.x\r\n    maxy = bb2.max.y\r\n    w_real = (maxx - minx)\r\n    h_real = (maxy - miny)\r\n    raise \"BBOX inválido (malha degenerada).\" if w_real.abs < 1e-6 || h_real.abs < 1e-6\r\n\r\n    out_w = tex_size.to_i\r\n    out_h = [(tex_size * (h_real / w_real)).round, 1].max\r\n    out_h = [out_h, tex_size].min\r\n\r\n    # OUTPUT = buffer BGRA (BMP 32-bit)\r\n    out_buf = \"\\x00\" * (out_w * out_h * 4)\r\n\r\n    tex_cache = {}\r\n\r\n    faces.each do |face|\r\n      mat  = face.material\r\n      back = face.back_material\r\n      use_back = (mat.nil? && !back.nil?)\r\n      mat = back if use_back\r\n\r\n      tw = Sketchup.create_texture_writer\r\n      uvh = face.get_UVHelper(true, true, tw)\r\n\r\n      src_rep = nil\r\n      src_w = src_h = nil\r\n      is_textured = false\r\n\r\n      if mat && mat.texture && mat.texture.filename && !mat.texture.filename.empty?\r\n        path = mat.texture.filename\r\n        src_rep = (tex_cache[path] ||= begin\r\n          rep = Sketchup::ImageRep.new\r\n          rep.load_file(path)\r\n          rep\r\n        rescue\r\n          nil\r\n        end)\r\n        if src_rep\r\n          src_w = src_rep.width\r\n          src_h = src_rep.height\r\n          is_textured = true\r\n        end\r\n      end\r\n\r\n      face_color = (mat && mat.color) ? mat.color : Sketchup::Color.new(200,200,200)\r\n\r\n      mesh = face.mesh(0)\r\n      mesh.polygons.each do |poly|\r\n        idx = poly.map(&:abs)\r\n        next if idx.length < 3\r\n\r\n        v0 = idx[0]\r\n        (1..(idx.length-2)).each do |k|\r\n          v1 = idx[k]\r\n          v2 = idx[k+1]\r\n\r\n          p0 = mesh.point_at(v0).transform(world_to_plane)\r\n          p1 = mesh.point_at(v1).transform(world_to_plane)\r\n          p2 = mesh.point_at(v2).transform(world_to_plane)\r\n\r\n          a = plane_to_px(p0, minx, miny, w_real, h_real, out_w, out_h)\r\n          b = plane_to_px(p1, minx, miny, w_real, h_real, out_w, out_h)\r\n          c = plane_to_px(p2, minx, miny, w_real, h_real, out_w, out_h)\r\n\r\n          if is_textured\r\n            uv0 = use_back ? uvh.get_back_UVQ(mesh.point_at(v0)) : uvh.get_front_UVQ(mesh.point_at(v0))\r\n            uv1 = use_back ? uvh.get_back_UVQ(mesh.point_at(v1)) : uvh.get_front_UVQ(mesh.point_at(v1))\r\n            uv2 = use_back ? uvh.get_back_UVQ(mesh.point_at(v2)) : uvh.get_front_UVQ(mesh.point_at(v2))\r\n\r\n            t0 = uvq_to_uv_px(uv0, src_w, src_h)\r\n            t1 = uvq_to_uv_px(uv1, src_w, src_h)\r\n            t2 = uvq_to_uv_px(uv2, src_w, src_h)\r\n\r\n            raster_triangle_uv_buf!(out_buf, out_w, out_h, a,b,c, src_rep, src_w, src_h, t0,t1,t2)\r\n          else\r\n            raster_triangle_color_buf!(out_buf, out_w, out_h, a,b,c, face_color)\r\n          end\r\n        end\r\n      end\r\n    end\r\n\r\n    dir = Dir.tmpdir\r\n    ts = Time.now.strftime(\"%Y%m%d_%H%M%S\")\r\n    bmp_path = File.join(dir, \"baked_mesh_#{ts}.bmp\")\r\n    write_bmp_32(bmp_path, out_w, out_h, out_buf)\r\n\r\n    mats = m.materials\r\n    name = unique_mat_name(mats, \"Baked_Mesh_#{ts}\")\r\n    new_mat = mats.add(name)\r\n    new_mat.texture = bmp_path\r\n    new_mat.texture.size = [w_real, h_real]\r\n\r\n    UI.messagebox(\"Material criado:\\n#{name}\\nTextura:\\n#{bmp_path}\")\r\n    new_mat\r\n  rescue => e\r\n    UI.messagebox(\"Erro:\\n#{e.message}\")\r\n    nil\r\n  end\r\n\r\n  # ---------- util ----------\r\n\r\n  def collect_faces(selection)\r\n    faces = []\r\n    selection.each do |ent|\r\n      case ent\r\n      when Sketchup::Face\r\n        faces << ent\r\n      when Sketchup::Group, Sketchup::ComponentInstance\r\n        faces.concat(rec_faces_in_entities(ent.definition.entities))\r\n      end\r\n    end\r\n    faces.uniq\r\n  end\r\n\r\n  def rec_faces_in_entities(ents, out = [])\r\n    ents.each do |e|\r\n      if e.is_a?(Sketchup::Face)\r\n        out << e\r\n      elsif e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance)\r\n        rec_faces_in_entities(e.definition.entities, out)\r\n      end\r\n    end\r\n    out\r\n  end\r\n\r\n  def plane_to_px(p, minx, miny, w, h, out_w, out_h)\r\n    u = (p.x - minx) / w\r\n    v = (p.y - miny) / h\r\n    x = (u * (out_w - 1)).round\r\n    y = ((1.0 - v) * (out_h - 1)).round\r\n    [x, y]\r\n  end\r\n\r\n  def uvq_to_uv_px(uvq, sw, sh)\r\n    z = uvq.z.to_f\r\n    z = 1.0 if z.abs < 1e-9\r\n    u = uvq.x.to_f / z\r\n    v = uvq.y.to_f / z\r\n    x = (u % 1.0) * (sw - 1)\r\n    y = (1.0 - (v % 1.0)) * (sh - 1)\r\n    [x, y]\r\n  end\r\n\r\n  def unique_mat_name(mats, base)\r\n    n = base\r\n    i = 1\r\n    while mats[n]\r\n      i += 1\r\n      n = \"#{base}_#{i}\"\r\n    end\r\n    n\r\n  end\r\n\r\n  def clamp(v, lo, hi)\r\n    v < lo ? lo : (v > hi ? hi : v)\r\n  end\r\n\r\n  def barycentric(p, a, b, c)\r\n    px, py = p\r\n    ax, ay = a\r\n    bx, by = b\r\n    cx, cy = c\r\n    v0x = bx - ax; v0y = by - ay\r\n    v1x = cx - ax; v1y = cy - ay\r\n    v2x = px - ax; v2y = py - ay\r\n    d00 = v0x*v0x + v0y*v0y\r\n    d01 = v0x*v1x + v0y*v1y\r\n    d11 = v1x*v1x + v1y*v1y\r\n    d20 = v2x*v0x + v2y*v0y\r\n    d21 = v2x*v1x + v2y*v1y\r\n    denom = (d00 * d11 - d01 * d01)\r\n    return nil if denom.abs < 1e-9\r\n    v = (d11 * d20 - d01 * d21) / denom\r\n    w = (d00 * d21 - d01 * d20) / denom\r\n    u = 1.0 - v - w\r\n    [u, v, w]\r\n  end\r\n\r\n  def tri_bbox(a,b,c, w, h)\r\n    xs = [a[0], b[0], c[0]]\r\n    ys = [a[1], b[1], c[1]]\r\n    [clamp(xs.min, 0, w-1), clamp(ys.min, 0, h-1),\r\n     clamp(xs.max, 0, w-1), clamp(ys.max, 0, h-1)]\r\n  end\r\n\r\n  # OUTPUT buffer é BGRA (BMP)\r\n  def set_px_bgra!(buf, w, x, y, r, g, b, a=255)\r\n    i = (y*w + x) * 4\r\n    buf.setbyte(i,     b)\r\n    buf.setbyte(i + 1, g)\r\n    buf.setbyte(i + 2, r)\r\n    buf.setbyte(i + 3, a)\r\n  end\r\n\r\n  def raster_triangle_color_buf!(buf, w, h, a,b,c, color)\r\n    minx, miny, maxx, maxy = tri_bbox(a,b,c, w, h)\r\n    (miny..maxy).each do |y|\r\n      (minx..maxx).each do |x|\r\n        bc = barycentric([x+0.5, y+0.5], a, b, c)\r\n        next unless bc\r\n        u,v,wg = bc\r\n        next if u < -0.001 || v < -0.001 || wg < -0.001\r\n        set_px_bgra!(buf, w, x, y, color.red, color.green, color.blue, 255)\r\n      end\r\n    end\r\n  end\r\n\r\n  def raster_triangle_uv_buf!(buf, ow, oh, a,b,c, src, sw, sh, t0,t1,t2)\r\n    minx, miny, maxx, maxy = tri_bbox(a,b,c, ow, oh)\r\n    src_rows = {}\r\n\r\n    (miny..maxy).each do |y|\r\n      (minx..maxx).each do |x|\r\n        bc = barycentric([x+0.5, y+0.5], a, b, c)\r\n        next unless bc\r\n        u,v,wg = bc\r\n        next if u < -0.001 || v < -0.001 || wg < -0.001\r\n\r\n        tx = t0[0]*u + t1[0]*v + t2[0]*wg\r\n        ty = t0[1]*u + t1[1]*v + t2[1]*wg\r\n\r\n        sx = clamp(tx.round, 0, sw-1)\r\n        sy = clamp(ty.round, 0, sh-1)\r\n\r\n        row = (src_rows[sy] ||= src.get_row(0, sy))\r\n        si = sx * 4\r\n        r = row[si]\r\n        g = row[si+1]\r\n        b = row[si+2]\r\n        a_ = row[si+3]\r\n\r\n        set_px_bgra!(buf, ow, x, y, r, g, b, a_)\r\n      end\r\n    end\r\n  end\r\n\r\n  # BMP 32-bit top-down (altura negativa)\r\n  def write_bmp_32(path, w, h, bgra_buf)\r\n    bgra_buf = bgra_buf.b\r\n\r\n    file_header_size = 14\r\n    dib_header_size  = 40\r\n    pixel_bytes = w * h * 4\r\n    file_size = file_header_size + dib_header_size + pixel_bytes\r\n    offset = file_header_size + dib_header_size\r\n\r\n    fh = \"BM\".b\r\n    fh << [file_size].pack(\"V\")\r\n    fh << [0].pack(\"V\")\r\n    fh << [offset].pack(\"V\")\r\n\r\n    dib = \"\".b\r\n    dib << [dib_header_size].pack(\"V\")\r\n    dib << [w].pack(\"V\")\r\n    dib << [(-h)].pack(\"V\")  # top-down\r\n    dib << [1].pack(\"v\")     # planes\r\n    dib << [32].pack(\"v\")    # bpp\r\n    dib << [0].pack(\"V\")     # BI_RGB\r\n    dib << [pixel_bytes].pack(\"V\")\r\n    dib << [2835].pack(\"V\")\r\n    dib << [2835].pack(\"V\")\r\n    dib << [0].pack(\"V\")\r\n    dib << [0].pack(\"V\")\r\n\r\n    File.binwrite(path, fh + dib + bgra_buf)\r\n  end\r\nend\r\n\r\n# EXEC\r\nPBD_BakeMeshTexture.run(tex_size: 2048)",
      "en": "# ============================================================\r\n# BAKE TEXTURE (MALHA -> NOVO MATERIAL) | SketchUp Ruby Console\r\n# Saída em BMP 32-bit (sem ImageRep vazio)\r\n# ============================================================\r\n\r\nrequire 'sketchup.rb'\r\nrequire 'tmpdir'\r\n\r\nObject.send(:remove_const, :PBD_BakeMeshTexture) if defined?(PBD_BakeMeshTexture)\r\n\r\nmodule PBD_BakeMeshTexture\r\n  extend self\r\n\r\n  DEFAULT_TEX_SIZE = 2048\r\n\r\n  def run(tex_size: DEFAULT_TEX_SIZE)\r\n    m = Sketchup.active_model\r\n    sel = m.selection\r\n    raise \"Selecione faces ou um grupo/componente contendo a malha.\" if sel.empty?\r\n\r\n    faces = collect_faces(sel)\r\n    raise \"Nenhuma face encontrada na seleção.\" if faces.empty?\r\n\r\n    # normal média (plano de projeção)\r\n    n = Geom::Vector3d.new(0,0,0)\r\n    faces.each { |f| n += f.normal }\r\n    n.length < 1e-9 ? (n = Geom::Vector3d.new(0,0,1)) : n.normalize!\r\n\r\n    ref = (n.parallel?(Geom::Vector3d.new(0,0,1)) ? Geom::Vector3d.new(1,0,0) : Geom::Vector3d.new(0,0,1))\r\n    xaxis = n * ref\r\n    xaxis.length < 1e-9 ? (xaxis = Geom::Vector3d.new(1,0,0)) : xaxis.normalize!\r\n    yaxis = n * xaxis\r\n    yaxis.normalize!\r\n\r\n    origin = faces[0].bounds.center\r\n    world_to_plane = Geom::Transformation.axes(origin, xaxis, yaxis, n).inverse\r\n\r\n    # bbox 2D projetado\r\n    bb2 = Geom::BoundingBox.new\r\n    faces.each do |f|\r\n      f.vertices.each do |v|\r\n        p = v.position.transform(world_to_plane)\r\n        bb2.add([p.x, p.y, 0])\r\n      end\r\n    end\r\n\r\n    minx = bb2.min.x\r\n    miny = bb2.min.y\r\n    maxx = bb2.max.x\r\n    maxy = bb2.max.y\r\n    w_real = (maxx - minx)\r\n    h_real = (maxy - miny)\r\n    raise \"BBOX inválido (malha degenerada).\" if w_real.abs < 1e-6 || h_real.abs < 1e-6\r\n\r\n    out_w = tex_size.to_i\r\n    out_h = [(tex_size * (h_real / w_real)).round, 1].max\r\n    out_h = [out_h, tex_size].min\r\n\r\n    # OUTPUT = buffer BGRA (BMP 32-bit)\r\n    out_buf = \"\\x00\" * (out_w * out_h * 4)\r\n\r\n    tex_cache = {}\r\n\r\n    faces.each do |face|\r\n      mat  = face.material\r\n      back = face.back_material\r\n      use_back = (mat.nil? && !back.nil?)\r\n      mat = back if use_back\r\n\r\n      tw = Sketchup.create_texture_writer\r\n      uvh = face.get_UVHelper(true, true, tw)\r\n\r\n      src_rep = nil\r\n      src_w = src_h = nil\r\n      is_textured = false\r\n\r\n      if mat && mat.texture && mat.texture.filename && !mat.texture.filename.empty?\r\n        path = mat.texture.filename\r\n        src_rep = (tex_cache[path] ||= begin\r\n          rep = Sketchup::ImageRep.new\r\n          rep.load_file(path)\r\n          rep\r\n        rescue\r\n          nil\r\n        end)\r\n        if src_rep\r\n          src_w = src_rep.width\r\n          src_h = src_rep.height\r\n          is_textured = true\r\n        end\r\n      end\r\n\r\n      face_color = (mat && mat.color) ? mat.color : Sketchup::Color.new(200,200,200)\r\n\r\n      mesh = face.mesh(0)\r\n      mesh.polygons.each do |poly|\r\n        idx = poly.map(&:abs)\r\n        next if idx.length < 3\r\n\r\n        v0 = idx[0]\r\n        (1..(idx.length-2)).each do |k|\r\n          v1 = idx[k]\r\n          v2 = idx[k+1]\r\n\r\n          p0 = mesh.point_at(v0).transform(world_to_plane)\r\n          p1 = mesh.point_at(v1).transform(world_to_plane)\r\n          p2 = mesh.point_at(v2).transform(world_to_plane)\r\n\r\n          a = plane_to_px(p0, minx, miny, w_real, h_real, out_w, out_h)\r\n          b = plane_to_px(p1, minx, miny, w_real, h_real, out_w, out_h)\r\n          c = plane_to_px(p2, minx, miny, w_real, h_real, out_w, out_h)\r\n\r\n          if is_textured\r\n            uv0 = use_back ? uvh.get_back_UVQ(mesh.point_at(v0)) : uvh.get_front_UVQ(mesh.point_at(v0))\r\n            uv1 = use_back ? uvh.get_back_UVQ(mesh.point_at(v1)) : uvh.get_front_UVQ(mesh.point_at(v1))\r\n            uv2 = use_back ? uvh.get_back_UVQ(mesh.point_at(v2)) : uvh.get_front_UVQ(mesh.point_at(v2))\r\n\r\n            t0 = uvq_to_uv_px(uv0, src_w, src_h)\r\n            t1 = uvq_to_uv_px(uv1, src_w, src_h)\r\n            t2 = uvq_to_uv_px(uv2, src_w, src_h)\r\n\r\n            raster_triangle_uv_buf!(out_buf, out_w, out_h, a,b,c, src_rep, src_w, src_h, t0,t1,t2)\r\n          else\r\n            raster_triangle_color_buf!(out_buf, out_w, out_h, a,b,c, face_color)\r\n          end\r\n        end\r\n      end\r\n    end\r\n\r\n    dir = Dir.tmpdir\r\n    ts = Time.now.strftime(\"%Y%m%d_%H%M%S\")\r\n    bmp_path = File.join(dir, \"baked_mesh_#{ts}.bmp\")\r\n    write_bmp_32(bmp_path, out_w, out_h, out_buf)\r\n\r\n    mats = m.materials\r\n    name = unique_mat_name(mats, \"Baked_Mesh_#{ts}\")\r\n    new_mat = mats.add(name)\r\n    new_mat.texture = bmp_path\r\n    new_mat.texture.size = [w_real, h_real]\r\n\r\n    UI.messagebox(\"Material criado:\\n#{name}\\nTextura:\\n#{bmp_path}\")\r\n    new_mat\r\n  rescue => e\r\n    UI.messagebox(\"Erro:\\n#{e.message}\")\r\n    nil\r\n  end\r\n\r\n  # ---------- util ----------\r\n\r\n  def collect_faces(selection)\r\n    faces = []\r\n    selection.each do |ent|\r\n      case ent\r\n      when Sketchup::Face\r\n        faces << ent\r\n      when Sketchup::Group, Sketchup::ComponentInstance\r\n        faces.concat(rec_faces_in_entities(ent.definition.entities))\r\n      end\r\n    end\r\n    faces.uniq\r\n  end\r\n\r\n  def rec_faces_in_entities(ents, out = [])\r\n    ents.each do |e|\r\n      if e.is_a?(Sketchup::Face)\r\n        out << e\r\n      elsif e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance)\r\n        rec_faces_in_entities(e.definition.entities, out)\r\n      end\r\n    end\r\n    out\r\n  end\r\n\r\n  def plane_to_px(p, minx, miny, w, h, out_w, out_h)\r\n    u = (p.x - minx) / w\r\n    v = (p.y - miny) / h\r\n    x = (u * (out_w - 1)).round\r\n    y = ((1.0 - v) * (out_h - 1)).round\r\n    [x, y]\r\n  end\r\n\r\n  def uvq_to_uv_px(uvq, sw, sh)\r\n    z = uvq.z.to_f\r\n    z = 1.0 if z.abs < 1e-9\r\n    u = uvq.x.to_f / z\r\n    v = uvq.y.to_f / z\r\n    x = (u % 1.0) * (sw - 1)\r\n    y = (1.0 - (v % 1.0)) * (sh - 1)\r\n    [x, y]\r\n  end\r\n\r\n  def unique_mat_name(mats, base)\r\n    n = base\r\n    i = 1\r\n    while mats[n]\r\n      i += 1\r\n      n = \"#{base}_#{i}\"\r\n    end\r\n    n\r\n  end\r\n\r\n  def clamp(v, lo, hi)\r\n    v < lo ? lo : (v > hi ? hi : v)\r\n  end\r\n\r\n  def barycentric(p, a, b, c)\r\n    px, py = p\r\n    ax, ay = a\r\n    bx, by = b\r\n    cx, cy = c\r\n    v0x = bx - ax; v0y = by - ay\r\n    v1x = cx - ax; v1y = cy - ay\r\n    v2x = px - ax; v2y = py - ay\r\n    d00 = v0x*v0x + v0y*v0y\r\n    d01 = v0x*v1x + v0y*v1y\r\n    d11 = v1x*v1x + v1y*v1y\r\n    d20 = v2x*v0x + v2y*v0y\r\n    d21 = v2x*v1x + v2y*v1y\r\n    denom = (d00 * d11 - d01 * d01)\r\n    return nil if denom.abs < 1e-9\r\n    v = (d11 * d20 - d01 * d21) / denom\r\n    w = (d00 * d21 - d01 * d20) / denom\r\n    u = 1.0 - v - w\r\n    [u, v, w]\r\n  end\r\n\r\n  def tri_bbox(a,b,c, w, h)\r\n    xs = [a[0], b[0], c[0]]\r\n    ys = [a[1], b[1], c[1]]\r\n    [clamp(xs.min, 0, w-1), clamp(ys.min, 0, h-1),\r\n     clamp(xs.max, 0, w-1), clamp(ys.max, 0, h-1)]\r\n  end\r\n\r\n  # OUTPUT buffer é BGRA (BMP)\r\n  def set_px_bgra!(buf, w, x, y, r, g, b, a=255)\r\n    i = (y*w + x) * 4\r\n    buf.setbyte(i,     b)\r\n    buf.setbyte(i + 1, g)\r\n    buf.setbyte(i + 2, r)\r\n    buf.setbyte(i + 3, a)\r\n  end\r\n\r\n  def raster_triangle_color_buf!(buf, w, h, a,b,c, color)\r\n    minx, miny, maxx, maxy = tri_bbox(a,b,c, w, h)\r\n    (miny..maxy).each do |y|\r\n      (minx..maxx).each do |x|\r\n        bc = barycentric([x+0.5, y+0.5], a, b, c)\r\n        next unless bc\r\n        u,v,wg = bc\r\n        next if u < -0.001 || v < -0.001 || wg < -0.001\r\n        set_px_bgra!(buf, w, x, y, color.red, color.green, color.blue, 255)\r\n      end\r\n    end\r\n  end\r\n\r\n  def raster_triangle_uv_buf!(buf, ow, oh, a,b,c, src, sw, sh, t0,t1,t2)\r\n    minx, miny, maxx, maxy = tri_bbox(a,b,c, ow, oh)\r\n    src_rows = {}\r\n\r\n    (miny..maxy).each do |y|\r\n      (minx..maxx).each do |x|\r\n        bc = barycentric([x+0.5, y+0.5], a, b, c)\r\n        next unless bc\r\n        u,v,wg = bc\r\n        next if u < -0.001 || v < -0.001 || wg < -0.001\r\n\r\n        tx = t0[0]*u + t1[0]*v + t2[0]*wg\r\n        ty = t0[1]*u + t1[1]*v + t2[1]*wg\r\n\r\n        sx = clamp(tx.round, 0, sw-1)\r\n        sy = clamp(ty.round, 0, sh-1)\r\n\r\n        row = (src_rows[sy] ||= src.get_row(0, sy))\r\n        si = sx * 4\r\n        r = row[si]\r\n        g = row[si+1]\r\n        b = row[si+2]\r\n        a_ = row[si+3]\r\n\r\n        set_px_bgra!(buf, ow, x, y, r, g, b, a_)\r\n      end\r\n    end\r\n  end\r\n\r\n  # BMP 32-bit top-down (altura negativa)\r\n  def write_bmp_32(path, w, h, bgra_buf)\r\n    bgra_buf = bgra_buf.b\r\n\r\n    file_header_size = 14\r\n    dib_header_size  = 40\r\n    pixel_bytes = w * h * 4\r\n    file_size = file_header_size + dib_header_size + pixel_bytes\r\n    offset = file_header_size + dib_header_size\r\n\r\n    fh = \"BM\".b\r\n    fh << [file_size].pack(\"V\")\r\n    fh << [0].pack(\"V\")\r\n    fh << [offset].pack(\"V\")\r\n\r\n    dib = \"\".b\r\n    dib << [dib_header_size].pack(\"V\")\r\n    dib << [w].pack(\"V\")\r\n    dib << [(-h)].pack(\"V\")  # top-down\r\n    dib << [1].pack(\"v\")     # planes\r\n    dib << [32].pack(\"v\")    # bpp\r\n    dib << [0].pack(\"V\")     # BI_RGB\r\n    dib << [pixel_bytes].pack(\"V\")\r\n    dib << [2835].pack(\"V\")\r\n    dib << [2835].pack(\"V\")\r\n    dib << [0].pack(\"V\")\r\n    dib << [0].pack(\"V\")\r\n\r\n    File.binwrite(path, fh + dib + bgra_buf)\r\n  end\r\nend\r\n\r\n# EXEC\r\nPBD_BakeMeshTexture.run(tex_size: 2048)",
      "es": "# ============================================================\r\n# BAKE TEXTURE (MALHA -> NOVO MATERIAL) | SketchUp Ruby Console\r\n# Saída em BMP 32-bit (sem ImageRep vazio)\r\n# ============================================================\r\n\r\nrequire 'sketchup.rb'\r\nrequire 'tmpdir'\r\n\r\nObject.send(:remove_const, :PBD_BakeMeshTexture) if defined?(PBD_BakeMeshTexture)\r\n\r\nmodule PBD_BakeMeshTexture\r\n  extend self\r\n\r\n  DEFAULT_TEX_SIZE = 2048\r\n\r\n  def run(tex_size: DEFAULT_TEX_SIZE)\r\n    m = Sketchup.active_model\r\n    sel = m.selection\r\n    raise \"Selecione faces ou um grupo/componente contendo a malha.\" if sel.empty?\r\n\r\n    faces = collect_faces(sel)\r\n    raise \"Nenhuma face encontrada na seleção.\" if faces.empty?\r\n\r\n    # normal média (plano de projeção)\r\n    n = Geom::Vector3d.new(0,0,0)\r\n    faces.each { |f| n += f.normal }\r\n    n.length < 1e-9 ? (n = Geom::Vector3d.new(0,0,1)) : n.normalize!\r\n\r\n    ref = (n.parallel?(Geom::Vector3d.new(0,0,1)) ? Geom::Vector3d.new(1,0,0) : Geom::Vector3d.new(0,0,1))\r\n    xaxis = n * ref\r\n    xaxis.length < 1e-9 ? (xaxis = Geom::Vector3d.new(1,0,0)) : xaxis.normalize!\r\n    yaxis = n * xaxis\r\n    yaxis.normalize!\r\n\r\n    origin = faces[0].bounds.center\r\n    world_to_plane = Geom::Transformation.axes(origin, xaxis, yaxis, n).inverse\r\n\r\n    # bbox 2D projetado\r\n    bb2 = Geom::BoundingBox.new\r\n    faces.each do |f|\r\n      f.vertices.each do |v|\r\n        p = v.position.transform(world_to_plane)\r\n        bb2.add([p.x, p.y, 0])\r\n      end\r\n    end\r\n\r\n    minx = bb2.min.x\r\n    miny = bb2.min.y\r\n    maxx = bb2.max.x\r\n    maxy = bb2.max.y\r\n    w_real = (maxx - minx)\r\n    h_real = (maxy - miny)\r\n    raise \"BBOX inválido (malha degenerada).\" if w_real.abs < 1e-6 || h_real.abs < 1e-6\r\n\r\n    out_w = tex_size.to_i\r\n    out_h = [(tex_size * (h_real / w_real)).round, 1].max\r\n    out_h = [out_h, tex_size].min\r\n\r\n    # OUTPUT = buffer BGRA (BMP 32-bit)\r\n    out_buf = \"\\x00\" * (out_w * out_h * 4)\r\n\r\n    tex_cache = {}\r\n\r\n    faces.each do |face|\r\n      mat  = face.material\r\n      back = face.back_material\r\n      use_back = (mat.nil? && !back.nil?)\r\n      mat = back if use_back\r\n\r\n      tw = Sketchup.create_texture_writer\r\n      uvh = face.get_UVHelper(true, true, tw)\r\n\r\n      src_rep = nil\r\n      src_w = src_h = nil\r\n      is_textured = false\r\n\r\n      if mat && mat.texture && mat.texture.filename && !mat.texture.filename.empty?\r\n        path = mat.texture.filename\r\n        src_rep = (tex_cache[path] ||= begin\r\n          rep = Sketchup::ImageRep.new\r\n          rep.load_file(path)\r\n          rep\r\n        rescue\r\n          nil\r\n        end)\r\n        if src_rep\r\n          src_w = src_rep.width\r\n          src_h = src_rep.height\r\n          is_textured = true\r\n        end\r\n      end\r\n\r\n      face_color = (mat && mat.color) ? mat.color : Sketchup::Color.new(200,200,200)\r\n\r\n      mesh = face.mesh(0)\r\n      mesh.polygons.each do |poly|\r\n        idx = poly.map(&:abs)\r\n        next if idx.length < 3\r\n\r\n        v0 = idx[0]\r\n        (1..(idx.length-2)).each do |k|\r\n          v1 = idx[k]\r\n          v2 = idx[k+1]\r\n\r\n          p0 = mesh.point_at(v0).transform(world_to_plane)\r\n          p1 = mesh.point_at(v1).transform(world_to_plane)\r\n          p2 = mesh.point_at(v2).transform(world_to_plane)\r\n\r\n          a = plane_to_px(p0, minx, miny, w_real, h_real, out_w, out_h)\r\n          b = plane_to_px(p1, minx, miny, w_real, h_real, out_w, out_h)\r\n          c = plane_to_px(p2, minx, miny, w_real, h_real, out_w, out_h)\r\n\r\n          if is_textured\r\n            uv0 = use_back ? uvh.get_back_UVQ(mesh.point_at(v0)) : uvh.get_front_UVQ(mesh.point_at(v0))\r\n            uv1 = use_back ? uvh.get_back_UVQ(mesh.point_at(v1)) : uvh.get_front_UVQ(mesh.point_at(v1))\r\n            uv2 = use_back ? uvh.get_back_UVQ(mesh.point_at(v2)) : uvh.get_front_UVQ(mesh.point_at(v2))\r\n\r\n            t0 = uvq_to_uv_px(uv0, src_w, src_h)\r\n            t1 = uvq_to_uv_px(uv1, src_w, src_h)\r\n            t2 = uvq_to_uv_px(uv2, src_w, src_h)\r\n\r\n            raster_triangle_uv_buf!(out_buf, out_w, out_h, a,b,c, src_rep, src_w, src_h, t0,t1,t2)\r\n          else\r\n            raster_triangle_color_buf!(out_buf, out_w, out_h, a,b,c, face_color)\r\n          end\r\n        end\r\n      end\r\n    end\r\n\r\n    dir = Dir.tmpdir\r\n    ts = Time.now.strftime(\"%Y%m%d_%H%M%S\")\r\n    bmp_path = File.join(dir, \"baked_mesh_#{ts}.bmp\")\r\n    write_bmp_32(bmp_path, out_w, out_h, out_buf)\r\n\r\n    mats = m.materials\r\n    name = unique_mat_name(mats, \"Baked_Mesh_#{ts}\")\r\n    new_mat = mats.add(name)\r\n    new_mat.texture = bmp_path\r\n    new_mat.texture.size = [w_real, h_real]\r\n\r\n    UI.messagebox(\"Material criado:\\n#{name}\\nTextura:\\n#{bmp_path}\")\r\n    new_mat\r\n  rescue => e\r\n    UI.messagebox(\"Erro:\\n#{e.message}\")\r\n    nil\r\n  end\r\n\r\n  # ---------- util ----------\r\n\r\n  def collect_faces(selection)\r\n    faces = []\r\n    selection.each do |ent|\r\n      case ent\r\n      when Sketchup::Face\r\n        faces << ent\r\n      when Sketchup::Group, Sketchup::ComponentInstance\r\n        faces.concat(rec_faces_in_entities(ent.definition.entities))\r\n      end\r\n    end\r\n    faces.uniq\r\n  end\r\n\r\n  def rec_faces_in_entities(ents, out = [])\r\n    ents.each do |e|\r\n      if e.is_a?(Sketchup::Face)\r\n        out << e\r\n      elsif e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance)\r\n        rec_faces_in_entities(e.definition.entities, out)\r\n      end\r\n    end\r\n    out\r\n  end\r\n\r\n  def plane_to_px(p, minx, miny, w, h, out_w, out_h)\r\n    u = (p.x - minx) / w\r\n    v = (p.y - miny) / h\r\n    x = (u * (out_w - 1)).round\r\n    y = ((1.0 - v) * (out_h - 1)).round\r\n    [x, y]\r\n  end\r\n\r\n  def uvq_to_uv_px(uvq, sw, sh)\r\n    z = uvq.z.to_f\r\n    z = 1.0 if z.abs < 1e-9\r\n    u = uvq.x.to_f / z\r\n    v = uvq.y.to_f / z\r\n    x = (u % 1.0) * (sw - 1)\r\n    y = (1.0 - (v % 1.0)) * (sh - 1)\r\n    [x, y]\r\n  end\r\n\r\n  def unique_mat_name(mats, base)\r\n    n = base\r\n    i = 1\r\n    while mats[n]\r\n      i += 1\r\n      n = \"#{base}_#{i}\"\r\n    end\r\n    n\r\n  end\r\n\r\n  def clamp(v, lo, hi)\r\n    v < lo ? lo : (v > hi ? hi : v)\r\n  end\r\n\r\n  def barycentric(p, a, b, c)\r\n    px, py = p\r\n    ax, ay = a\r\n    bx, by = b\r\n    cx, cy = c\r\n    v0x = bx - ax; v0y = by - ay\r\n    v1x = cx - ax; v1y = cy - ay\r\n    v2x = px - ax; v2y = py - ay\r\n    d00 = v0x*v0x + v0y*v0y\r\n    d01 = v0x*v1x + v0y*v1y\r\n    d11 = v1x*v1x + v1y*v1y\r\n    d20 = v2x*v0x + v2y*v0y\r\n    d21 = v2x*v1x + v2y*v1y\r\n    denom = (d00 * d11 - d01 * d01)\r\n    return nil if denom.abs < 1e-9\r\n    v = (d11 * d20 - d01 * d21) / denom\r\n    w = (d00 * d21 - d01 * d20) / denom\r\n    u = 1.0 - v - w\r\n    [u, v, w]\r\n  end\r\n\r\n  def tri_bbox(a,b,c, w, h)\r\n    xs = [a[0], b[0], c[0]]\r\n    ys = [a[1], b[1], c[1]]\r\n    [clamp(xs.min, 0, w-1), clamp(ys.min, 0, h-1),\r\n     clamp(xs.max, 0, w-1), clamp(ys.max, 0, h-1)]\r\n  end\r\n\r\n  # OUTPUT buffer é BGRA (BMP)\r\n  def set_px_bgra!(buf, w, x, y, r, g, b, a=255)\r\n    i = (y*w + x) * 4\r\n    buf.setbyte(i,     b)\r\n    buf.setbyte(i + 1, g)\r\n    buf.setbyte(i + 2, r)\r\n    buf.setbyte(i + 3, a)\r\n  end\r\n\r\n  def raster_triangle_color_buf!(buf, w, h, a,b,c, color)\r\n    minx, miny, maxx, maxy = tri_bbox(a,b,c, w, h)\r\n    (miny..maxy).each do |y|\r\n      (minx..maxx).each do |x|\r\n        bc = barycentric([x+0.5, y+0.5], a, b, c)\r\n        next unless bc\r\n        u,v,wg = bc\r\n        next if u < -0.001 || v < -0.001 || wg < -0.001\r\n        set_px_bgra!(buf, w, x, y, color.red, color.green, color.blue, 255)\r\n      end\r\n    end\r\n  end\r\n\r\n  def raster_triangle_uv_buf!(buf, ow, oh, a,b,c, src, sw, sh, t0,t1,t2)\r\n    minx, miny, maxx, maxy = tri_bbox(a,b,c, ow, oh)\r\n    src_rows = {}\r\n\r\n    (miny..maxy).each do |y|\r\n      (minx..maxx).each do |x|\r\n        bc = barycentric([x+0.5, y+0.5], a, b, c)\r\n        next unless bc\r\n        u,v,wg = bc\r\n        next if u < -0.001 || v < -0.001 || wg < -0.001\r\n\r\n        tx = t0[0]*u + t1[0]*v + t2[0]*wg\r\n        ty = t0[1]*u + t1[1]*v + t2[1]*wg\r\n\r\n        sx = clamp(tx.round, 0, sw-1)\r\n        sy = clamp(ty.round, 0, sh-1)\r\n\r\n        row = (src_rows[sy] ||= src.get_row(0, sy))\r\n        si = sx * 4\r\n        r = row[si]\r\n        g = row[si+1]\r\n        b = row[si+2]\r\n        a_ = row[si+3]\r\n\r\n        set_px_bgra!(buf, ow, x, y, r, g, b, a_)\r\n      end\r\n    end\r\n  end\r\n\r\n  # BMP 32-bit top-down (altura negativa)\r\n  def write_bmp_32(path, w, h, bgra_buf)\r\n    bgra_buf = bgra_buf.b\r\n\r\n    file_header_size = 14\r\n    dib_header_size  = 40\r\n    pixel_bytes = w * h * 4\r\n    file_size = file_header_size + dib_header_size + pixel_bytes\r\n    offset = file_header_size + dib_header_size\r\n\r\n    fh = \"BM\".b\r\n    fh << [file_size].pack(\"V\")\r\n    fh << [0].pack(\"V\")\r\n    fh << [offset].pack(\"V\")\r\n\r\n    dib = \"\".b\r\n    dib << [dib_header_size].pack(\"V\")\r\n    dib << [w].pack(\"V\")\r\n    dib << [(-h)].pack(\"V\")  # top-down\r\n    dib << [1].pack(\"v\")     # planes\r\n    dib << [32].pack(\"v\")    # bpp\r\n    dib << [0].pack(\"V\")     # BI_RGB\r\n    dib << [pixel_bytes].pack(\"V\")\r\n    dib << [2835].pack(\"V\")\r\n    dib << [2835].pack(\"V\")\r\n    dib << [0].pack(\"V\")\r\n    dib << [0].pack(\"V\")\r\n\r\n    File.binwrite(path, fh + dib + bgra_buf)\r\n  end\r\nend\r\n\r\n# EXEC\r\nPBD_BakeMeshTexture.run(tex_size: 2048)"
    },
    "enabled": false,
    "execute": true,
    "video": "https://youtu.be/tRwWJqDDiHI?si=tlH2vhRPcEViTkec"
  },
  {
    "id": "explosao-radial-1svwj",
    "title": {
      "pt": "Explosão Radial",
      "en": "Radial Explosion",
      "es": "Explosión radial"
    },
    "author": "Coutinho",
    "version": "1.5",
    "description": {
      "pt": "Explosão Permite simular uma explosão radial do elemento selecionado usando um slider.Radial",
      "en": "Explosion: Allows you to simulate a radial explosion of the selected element using a slider. Radial",
      "es": "Explosión: Permite simular una explosión radial del elemento seleccionado mediante un control deslizante. Radial"
    },
    "keywords": {
      "pt": [
        "explosão"
      ],
      "en": [
        "explosion"
      ],
      "es": [
        "explosión"
      ]
    },
    "code": {
      "pt": "require 'sketchup.rb'\r\nrequire 'json'\r\n\r\nmodule ScriptUpComunidade\r\n  module ExplosaoRadialFinal\r\n    extend self\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao => \"Selecione apenas um grupo ou componente.\",\r\n        :op_explosao  => \"Explosão Visual\",\r\n        :op_restaurar => \"Restaurar Explosão\",\r\n        :titulo       => \"Explosão Visual Radial\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao => \"Select only one group or component.\",\r\n        :op_explosao  => \"Visual Explosion\",\r\n        :op_restaurar => \"Restore Explosion\",\r\n        :titulo       => \"Radial Visual Explosion\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao => \"Seleccione solo un grupo o componente.\",\r\n        :op_explosao  => \"Explosión Visual\",\r\n        :op_restaurar => \"Restaurar Explosión\",\r\n        :titulo       => \"Explosión Visual Radial\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n      unless selection.length == 1 && (selection.first.is_a?(Sketchup::Group) || selection.first.is_a?(Sketchup::ComponentInstance))\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n\r\n      @root = selection.first\r\n      @root_tr = @root.transformation\r\n      @root_center = @root.bounds.center.transform(@root_tr)\r\n\r\n      @entities_data = []\r\n      collect_descendants(@root, @root_tr)\r\n\r\n      # Calcula centro médio original dos componentes internos\r\n      centros = @entities_data.map { |data| data[:original_center] }\r\n\r\n      avg_x = centros.map(&:x).sum / centros.size\r\n      avg_y = centros.map(&:y).sum / centros.size\r\n      avg_z = centros.map(&:z).sum / centros.size\r\n\r\n      @original_avg_center = Geom::Point3d.new(avg_x, avg_y, avg_z)\r\n\r\n      show_dialog\r\n    end\r\n\r\n    def collect_descendants(parent, parent_tr)\r\n      entities = parent.is_a?(Sketchup::Group) ? parent.entities : parent.definition.entities\r\n\r\n      entities.each do |ent|\r\n        next unless ent.is_a?(Sketchup::Group) || ent.is_a?(Sketchup::ComponentInstance)\r\n\r\n        full_tr = parent_tr * ent.transformation\r\n\r\n        origin_point = ORIGIN.transform(full_tr)\r\n        vector = Geom::Vector3d.new(origin_point - @root_center)\r\n        next if vector.length == 0.0\r\n\r\n        original_center = ent.bounds.center.transform(full_tr)\r\n\r\n        @entities_data << {\r\n          entity: ent,\r\n          original_transform: ent.transformation,\r\n          direction: vector,\r\n          original_center: original_center\r\n        }\r\n\r\n        collect_descendants(ent, full_tr)\r\n      end\r\n    end\r\n\r\n    def apply_explosion(factor)\r\n      model = Sketchup.active_model\r\n      model.start_operation(obter_texto(:op_explosao), true)\r\n      \r\n      exploded_centers = []\r\n      \r\n      @entities_data.each do |data|\r\n        original_direction = data[:direction]\r\n        next unless original_direction.respond_to?(:normalize)\r\n      \r\n        normalized = original_direction.normalize rescue nil\r\n        next unless normalized.is_a?(Geom::Vector3d)\r\n      \r\n        distance = original_direction.length * factor\r\n        move_vector = normalized.clone\r\n        move_vector.length = distance\r\n      \r\n        new_center = data[:original_center].offset(move_vector)\r\n        exploded_centers << new_center\r\n      \r\n        data[:_calculated_move] = move_vector\r\n      end\r\n      \r\n      if exploded_centers.empty?\r\n        model.abort_operation\r\n        return\r\n      end\r\n      \r\n      avg_x = exploded_centers.map(&:x).sum / exploded_centers.size\r\n      avg_y = exploded_centers.map(&:y).sum / exploded_centers.size\r\n      avg_z = exploded_centers.map(&:z).sum / exploded_centers.size\r\n      exploded_center = Geom::Point3d.new(avg_x, avg_y, avg_z)\r\n      \r\n      # Compensação agora é entre o centro visual salvo e o novo centro calculado\r\n      compensation_vector = exploded_center.vector_to(@original_avg_center)\r\n      \r\n      @entities_data.each do |data|\r\n        ent = data[:entity]\r\n        next unless ent.valid?\r\n      \r\n        move_vector = data[:_calculated_move]\r\n        compensated_vector = move_vector + compensation_vector\r\n      \r\n        ent.transformation = data[:original_transform] * Geom::Transformation.translation(compensated_vector)\r\n      end\r\n      \r\n      model.commit_operation\r\n    end\r\n\r\n    def restore_positions\r\n      model = Sketchup.active_model\r\n      model.start_operation(obter_texto(:op_restaurar), true)\r\n\r\n      @entities_data.each do |data|\r\n        ent = data[:entity]\r\n        ent.transformation = data[:original_transform] if ent.valid?\r\n      end\r\n\r\n      model.commit_operation\r\n    end\r\n\r\n    def show_dialog\r\n      html = <<-HTML\r\n        <!DOCTYPE html>\r\n        <html>\r\n        <head>\r\n          <meta charset=\"utf-8\">\r\n          <style>\r\n            body { font-family: sans-serif; padding: 10px; }\r\n            input[type=range] { width: 100%; }\r\n          </style>\r\n        </head>\r\n        <body>\r\n          <h3>#{obter_texto(:titulo)}</h3>\r\n          <input id=\"slider\" type=\"range\" min=\"0\" max=\"100\" value=\"0\">\r\n          <script>\r\n            const slider = document.getElementById('slider');\r\n            slider.addEventListener('input', () => {\r\n              window.sketchup.set_explosion(slider.value);\r\n            });\r\n            window.onbeforeunload = () => {\r\n              window.sketchup.restore_positions();\r\n            };\r\n          </script>\r\n        </body>\r\n        </html>\r\n      HTML\r\n\r\n      @dialog = UI::HtmlDialog.new({\r\n        dialog_title: obter_texto(:titulo),\r\n        width: 300,\r\n        height: 120,\r\n        style: UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n\r\n      @dialog.set_html(html)\r\n      @dialog.add_action_callback(\"set_explosion\") { |_ctx, val| apply_explosion(val.to_f / 100.0) }\r\n      @dialog.add_action_callback(\"restore_positions\") { |_ctx, _| restore_positions }\r\n      @dialog.show\r\n    end\r\n  end\r\nend\r\n\r\nScriptUpComunidade::ExplosaoRadialFinal.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "visita-virtual-3i642",
    "title": {
      "pt": "Visita virtual",
      "en": "Tour Virtual",
      "es": "Recorrido virtual"
    },
    "author": "Fábio Coutinho",
    "version": "2.5",
    "description": {
      "pt": "Permite criar cenas, gerenciar e exportar um vídeo de passeio pelo modelo.",
      "en": "Allows you to create scenes, manage, and export a walkthrough video of the model.",
      "es": "Le permite crear escenas, administrar y exportar un video recorrido del modelo."
    },
    "keywords": {
      "pt": [
        "tour virtual"
      ],
      "en": [
        "tour virtual"
      ],
      "es": [
        "recorrido virtual"
      ]
    },
    "code": {
      "pt": "require 'json'\r\nrequire 'sketchup.rb'\r\nrequire 'base64'\r\nrequire 'tmpdir'\r\nrequire 'fiddle/import'\r\nrequire 'fileutils'\r\nrequire 'open3'\r\nrequire 'etc'\r\nrequire 'open-uri'\r\n\r\nif Sketchup.platform == :platform_win\r\n  require 'win32ole'\r\nend\r\n\r\nmodule ScriptUpComunidade\r\n  module TourVirtualMultiTimeline\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :msg_erro_plugins      => \"Não foi possível resolver a pasta Plugins automaticamente.\",\r\n        :msg_ffmpeg_instalar   => \"Instalar FFmpeg em:\\n%s\\n\\nOrigem:\\n%s\\n\\nContinuar?\",\r\n        :msg_cancelado         => \"Instalação cancelada.\",\r\n        :msg_sobrescrever      => \"Já existe:\\n%s\\n\\nDeseja sobrescrever?\",\r\n        :msg_erro_ps           => \"Falha no Expand-Archive (PowerShell).\",\r\n        :msg_erro_mac          => \"Falha no unzip (macOS).\",\r\n        :msg_erro_nao_encontrado => \"Executável ffmpeg não encontrado no pacote baixado.\",\r\n        :msg_sucesso_instala   => \"FFmpeg instalado com sucesso em:\\n%s\",\r\n        :msg_falha_instala     => \"Falhou: %s\\nAbrindo o link no navegador...\",\r\n        :status_area           => \"CLIQUE E ARRASTE para definir a área de gravação do vídeo.\",\r\n        :msg_area_pequena      => \"Área muito pequena. Tente novamente.\",\r\n        :msg_ffmpeg_nao_encon  => \"FFmpeg não encontrado.\",\r\n        :msg_gravacao_fim      => \"Gravação finalizada!\\nSalvo em: %s\",\r\n        :msg_erro_gravador     => \"Erro ao iniciar gravador: %s\",\r\n        :select_dir            => \"Selecione a pasta para salvar\",\r\n        :html_titulo           => \"Tour Virtual\",\r\n        :html_subtitle         => \"Linha do Tempo\",\r\n        :html_total            => \"Total:\",\r\n        :html_visao            => \"Visão\",\r\n        :html_play             => \"Play\",\r\n        :html_play_all         => \"Play All\",\r\n        :html_atalho           => \"Atalho\",\r\n        :html_loop             => \"Loop\",\r\n        :html_easing           => \"Easing\",\r\n        :html_visoes_salvas    => \"Visões salvas\",\r\n        :html_gerenciar        => \"Gerenciar Time Line\",\r\n        :html_nova             => \"Nova\",\r\n        :html_exportar_atual   => \"Exportar Atual\",\r\n        :html_exportar_proj    => \"Exportar Projeto\",\r\n        :html_importar         => \"Importar\",\r\n        :html_exportar_video   => \"Exportar Vídeo\",\r\n        :html_viewport_atual   => \"Viewport atual:\",\r\n        :html_preset_sel       => \"Selecione o formato…\",\r\n        :html_rec_projeto      => \"Gravar todo o projeto (todas as Time Lines)\",\r\n        :html_rec_inicio       => \"Iniciar do quadro 1\",\r\n        :html_btn_record       => \"Iniciar Gravação\",\r\n        :html_gravando         => \"Gravando...\",\r\n        :html_ffmpeg_req       => \"FFmpeg necessário para gravar vídeo.\",\r\n        :html_instalar_ffmpeg  => \"Instalar FFmpeg\",\r\n        :html_modal_titulo     => \"Nome do arquivo\",\r\n        :html_modal_ext        => \"A extensão .mp4 será adicionada automaticamente.\",\r\n        :html_btn_cancelar     => \"Cancelar\",\r\n        :html_btn_salvar       => \"Salvar\",\r\n        :js_prompt_nome_tl     => \"Nome da Time Line:\",\r\n        :js_prompt_nova_tl     => \"Nome da nova Time Line:\",\r\n        :js_alert_duas_visoes  => \"Adicione pelo menos duas visões.\",\r\n        :js_alert_nenhuma_tl   => \"Nenhuma Time Line com 2+ visões.\",\r\n        :js_alert_nada_export  => \"Nenhuma visão para exportar.\",\r\n        :js_alert_nada_proj    => \"Nenhuma Time Line para exportar.\",\r\n        :js_alert_formato_inv  => \"Formato inválido.\",\r\n        :js_alert_erro_import  => \"Erro ao importar: \",\r\n        :js_alert_dims_inv     => \"Dimensões inválidas (mínimo 50 x 50 px).\",\r\n        :js_alert_nome_arq     => \"Digite um nome para o arquivo.\",\r\n        :js_placeholder_press  => \"Pressione...\",\r\n        :js_empty_state        => \"Nenhuma visão adicionada.<br>Posicione a câmera e clique em <b>+ Visão</b>.\",\r\n        :js_area_gravacao      => \"Área de gravação: \",\r\n        :ffmpeg_msg_pos_inst   => \"FFmpeg instalado. Execute o Tour Virtual novamente.\"\r\n      },\r\n      'en-US' => {\r\n        :msg_erro_plugins      => \"Could not resolve Plugins folder automatically.\",\r\n        :msg_ffmpeg_instalar   => \"Install FFmpeg in:\\n%s\\n\\nSource:\\n%s\\n\\nContinue?\",\r\n        :msg_cancelado         => \"Installation cancelled.\",\r\n        :msg_sobrescrever      => \"Already exists:\\n%s\\n\\nDo you want to overwrite?\",\r\n        :msg_erro_ps           => \"Fail on Expand-Archive (PowerShell).\",\r\n        :msg_erro_mac          => \"Fail on unzip (macOS).\",\r\n        :msg_erro_nao_encontrado => \"FFmpeg executable not found in the downloaded package.\",\r\n        :msg_sucesso_instala   => \"FFmpeg successfully installed in:\\n%s\",\r\n        :msg_falha_instala     => \"Failed: %s\\nOpening link in browser...\",\r\n        :status_area           => \"CLICK AND DRAG to define the video recording area.\",\r\n        :msg_area_pequena      => \"Area too small. Try again.\",\r\n        :msg_ffmpeg_nao_encon  => \"FFmpeg not found.\",\r\n        :msg_gravacao_fim      => \"Recording finished!\\nSaved in: %s\",\r\n        :msg_erro_gravador     => \"Error starting recorder: %s\",\r\n        :select_dir            => \"Select the folder to save\",\r\n        :html_titulo           => \"Virtual Tour\",\r\n        :html_subtitle         => \"Timeline\",\r\n        :html_total            => \"Total:\",\r\n        :html_visao            => \"Vision\",\r\n        :html_play             => \"Play\",\r\n        :html_play_all         => \"Play All\",\r\n        :html_atalho           => \"Hotkey\",\r\n        :html_loop             => \"Loop\",\r\n        :html_easing           => \"Easing\",\r\n        :html_visoes_salvas    => \"Saved Visions\",\r\n        :html_gerenciar        => \"Manage Timeline\",\r\n        :html_nova             => \"New\",\r\n        :html_exportar_atual   => \"Export Current\",\r\n        :html_exportar_proj    => \"Export Project\",\r\n        :html_importar         => \"Import\",\r\n        :html_exportar_video   => \"Export Video\",\r\n        :html_viewport_atual   => \"Current Viewport:\",\r\n        :html_preset_sel       => \"Select format...\",\r\n        :html_rec_projeto      => \"Record entire project (all timelines)\",\r\n        :html_rec_inicio       => \"Start from frame 1\",\r\n        :html_btn_record       => \"Start Recording\",\r\n        :html_gravando         => \"Recording...\",\r\n        :html_ffmpeg_req       => \"FFmpeg required to record video.\",\r\n        :html_instalar_ffmpeg  => \"Install FFmpeg\",\r\n        :html_modal_titulo     => \"File name\",\r\n        :html_modal_ext        => \".mp4 extension will be added automatically.\",\r\n        :html_btn_cancelar     => \"Cancel\",\r\n        :html_btn_salvar       => \"Save\",\r\n        :js_prompt_nome_tl     => \"Timeline Name:\",\r\n        :js_prompt_nova_tl     => \"New Timeline Name:\",\r\n        :js_alert_duas_visoes  => \"Add at least two visions.\",\r\n        :js_alert_nenhuma_tl   => \"No Timeline with 2+ visions.\",\r\n        :js_alert_nada_export  => \"No visions to export.\",\r\n        :js_alert_nada_proj    => \"No Timelines to export.\",\r\n        :js_alert_formato_inv  => \"Invalid format.\",\r\n        :js_alert_erro_import  => \"Import error: \",\r\n        :js_alert_dims_inv     => \"Invalid dimensions (minimum 50 x 50 px).\",\r\n        :js_alert_nome_arq     => \"Enter a file name.\",\r\n        :js_placeholder_press  => \"Press...\",\r\n        :js_empty_state        => \"No visions added.<br>Position the camera and click <b>+ Vision</b>.\",\r\n        :js_area_gravacao      => \"Recording area: \",\r\n        :ffmpeg_msg_pos_inst   => \"FFmpeg installed. Run Virtual Tour again.\"\r\n      },\r\n      'es' => {\r\n        :msg_erro_plugins      => \"No se pudo resolver la carpeta Plugins automáticamente.\",\r\n        :msg_ffmpeg_instalar   => \"¿Instalar FFmpeg en:\\n%s\\n\\nOrigen:\\n%s\\n\\nContinuar?\",\r\n        :msg_cancelado         => \"Instalación cancelada.\",\r\n        :msg_sobrescrever      => \"Ya existe:\\n%s\\n\\n¿Desea sobrescribir?\",\r\n        :msg_erro_ps           => \"Fallo en Expand-Archive (PowerShell).\",\r\n        :msg_erro_mac          => \"Fallo en unzip (macOS).\",\r\n        :msg_erro_nao_encontrado => \"Ejecutable ffmpeg no encontrado en el paquete descargado.\",\r\n        :msg_sucesso_instala   => \"FFmpeg instalado con éxito en:\\n%s\",\r\n        :msg_falha_instala     => \"Falló: %s\\nAbriendo el enlace en el navegador...\",\r\n        :status_area           => \"CLIC Y ARRASTRE para definir el área de grabación del video.\",\r\n        :msg_area_pequena      => \"Área demasiado pequeña. Intente de nuevo.\",\r\n        :msg_ffmpeg_nao_encon  => \"FFmpeg no encontrado.\",\r\n        :msg_gravacao_fim      => \"¡Grabación finalizada!\\nGuardado en: %s\",\r\n        :msg_erro_gravador     => \"Error al iniciar el grabador: %s\",\r\n        :select_dir            => \"Seleccione la carpeta para guardar\",\r\n        :html_titulo           => \"Tour Virtual\",\r\n        :html_subtitle         => \"Línea de Tiempo\",\r\n        :html_total            => \"Total:\",\r\n        :html_visao            => \"Visión\",\r\n        :html_play             => \"Play\",\r\n        :html_play_all         => \"Play All\",\r\n        :html_atalho           => \"Atajo\",\r\n        :html_loop             => \"Bucle\",\r\n        :html_easing           => \"Suavizado\",\r\n        :html_visoes_salvas    => \"Visiones guardadas\",\r\n        :html_gerenciar        => \"Gestionar Línea de Tiempo\",\r\n        :html_nova             => \"Nueva\",\r\n        :html_exportar_atual   => \"Exportar Actual\",\r\n        :html_exportar_proj    => \"Exportar Proyecto\",\r\n        :html_importar         => \"Importar\",\r\n        :html_exportar_video   => \"Exportar Video\",\r\n        :html_viewport_atual   => \"Viewport actual:\",\r\n        :html_preset_sel       => \"Seleccione el formato...\",\r\n        :html_rec_projeto      => \"Grabar todo el proyecto (todas las líneas)\",\r\n        :html_rec_inicio       => \"Iniciar desde el cuadro 1\",\r\n        :html_btn_record       => \"Iniciar Grabación\",\r\n        :html_gravando         => \"Grabando...\",\r\n        :html_ffmpeg_req       => \"FFmpeg necesario para grabar video.\",\r\n        :html_instalar_ffmpeg  => \"Instalar FFmpeg\",\r\n        :html_modal_titulo     => \"Nombre del archivo\",\r\n        :html_modal_ext        => \"La extensión .mp4 se agregará automáticamente.\",\r\n        :html_btn_cancelar     => \"Cancelar\",\r\n        :html_btn_salvar       => \"Guardar\",\r\n        :js_prompt_nome_tl     => \"Nombre de la Línea de Tiempo:\",\r\n        :js_prompt_nova_tl     => \"Nombre de la nueva Línea de Tiempo:\",\r\n        :js_alert_duas_visoes  => \"Agregue al menos dos visiones.\",\r\n        :js_alert_nenhuma_tl   => \"Ninguna Línea de Tiempo con 2+ visiones.\",\r\n        :js_alert_nada_export  => \"No hay visiones para exportar.\",\r\n        :js_alert_nada_proj    => \"No hay Líneas de Tiempo para exportar.\",\r\n        :js_alert_formato_inv  => \"Formato inválido.\",\r\n        :js_alert_erro_import  => \"Error al importar: \",\r\n        :js_alert_dims_inv     => \"Dimensiones inválidas (mínimo 50 x 50 px).\",\r\n        :js_alert_nome_arq     => \"Ingrese un nombre para el archivo.\",\r\n        :js_placeholder_press  => \"Presione...\",\r\n        :js_empty_state        => \"Ninguna visión agregada.<br>Posicione la cámara y haga clic en <b>+ Visión</b>.\",\r\n        :js_area_gravacao      => \"Área de grabación: \",\r\n        :ffmpeg_msg_pos_inst   => \"FFmpeg instalado. Ejecute el Tour Virtual nuevamente.\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    # --- Definições de Diretórios ---\r\n    plugins_root = Sketchup.find_support_file(\"Plugins\")\r\n    PLUGIN_DIR = if plugins_root\r\n                   File.expand_path(File.join(plugins_root, 'ScriptUp'))\r\n                 else\r\n                   File.expand_path(File.dirname(__FILE__))\r\n                 end\r\n\r\n    # --- Script de Instalação do FFmpeg ---\r\n    FFMPEG_INSTALL_SCRIPT = <<~RUBY\r\n      require 'sketchup'\r\n      require 'open-uri'\r\n      require 'fileutils'\r\n      require 'tmpdir'\r\n\r\n      URL_WIN = 'https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-master-latest-win64-gpl.zip'\r\n      URL_MAC = 'https://evermeet.cx/ffmpeg/getrelease/zip'\r\n\r\n      win = Sketchup.platform == :platform_win\r\n      major = Sketchup.version.to_s[/^\\\\d+/].to_i\r\n      sketchup_year = 2000 + major\r\n\r\n      plugins_dir = Sketchup.find_support_file('Plugins')\r\n      if !plugins_dir || plugins_dir.empty? || !Dir.exist?(plugins_dir)\r\n        if win\r\n          base = ENV['APPDATA'].to_s\r\n          plugins_dir = File.join(base, 'SketchUp', \"SketchUp \\#{sketchup_year}\", 'SketchUp', 'Plugins')\r\n        else\r\n          plugins_dir = File.expand_path(\"~/Library/Application Support/SketchUp \\#{sketchup_year}/SketchUp/Plugins\")\r\n        end\r\n      end\r\n\r\n      target_dir = File.join(plugins_dir, 'ScriptUp', 'ffmpeg')\r\n      target_exe = File.join(target_dir, win ? 'ffmpeg.exe' : 'ffmpeg')\r\n      url = win ? URL_WIN : URL_MAC\r\n      default_zip_name = win ? 'ffmpeg-win64-gpl-latest.zip' : 'ffmpeg-macos-release.zip'\r\n\r\n      proceed = true\r\n\r\n      unless plugins_dir && !plugins_dir.empty?\r\n        UI.messagebox(\"#{obter_texto(:msg_erro_plugins)}\")\r\n        proceed = false\r\n      end\r\n\r\n      if proceed\r\n        msg = \"#{obter_texto(:msg_ffmpeg_instalar)}\" % [target_dir, url]\r\n        if UI.messagebox(msg, MB_YESNO) != IDYES\r\n          UI.messagebox(\"#{obter_texto(:msg_cancelado)}\")\r\n          proceed = false\r\n        end\r\n      end\r\n\r\n      if proceed && File.exist?(target_exe)\r\n        overwrite = UI.messagebox(\"#{obter_texto(:msg_sobrescrever)}\" % target_exe, MB_YESNO)\r\n        if overwrite != IDYES\r\n          UI.messagebox(\"#{obter_texto(:msg_cancelado)}\")\r\n          proceed = false\r\n        end\r\n      end\r\n\r\n      if proceed\r\n        Dir.mktmpdir('ffmpeg_dl_') do |tmp|\r\n          zip_path = File.join(tmp, default_zip_name)\r\n          extract_dir = File.join(tmp, 'unzipped')\r\n          begin\r\n            URI.open(url, 'rb') do |io|\r\n              File.open(zip_path, 'wb') { |f| IO.copy_stream(io, f) }\r\n            end\r\n            Dir.mkdir(extract_dir)\r\n            if win\r\n              ps = 'powershell -NoProfile -ExecutionPolicy Bypass -Command'\r\n              cmd = \"\\#{ps} \\\\\"Expand-Archive -LiteralPath '\\#{zip_path}' -DestinationPath '\\#{extract_dir}' -Force\\\\\"\"\r\n              ok = system(cmd)\r\n              raise \"#{obter_texto(:msg_erro_ps)}\" unless ok\r\n            else\r\n              ok = system(\"unzip -o -q '\\#{zip_path}' -d '\\#{extract_dir}'\")\r\n              raise \"#{obter_texto(:msg_erro_mac)}\" unless ok\r\n            end\r\n\r\n            pattern = win ? '**/ffmpeg.exe' : '**/ffmpeg'\r\n            bin = Dir.glob(File.join(extract_dir, pattern)).find { |p| File.file?(p) }\r\n            raise \"#{obter_texto(:msg_erro_nao_encontrado)}\" unless bin\r\n\r\n            FileUtils.mkdir_p(target_dir) unless Dir.exist?(target_dir)\r\n            FileUtils.cp(bin, target_exe)\r\n            unless win\r\n              FileUtils.chmod(0o755, target_exe)\r\n              system(\"xattr -d com.apple.quarantine '\\#{target_exe}' 2>/dev/null\")\r\n            end\r\n\r\n            UI.messagebox(\"#{obter_texto(:msg_sucesso_instala)}\" % target_exe)\r\n          rescue => e\r\n            UI.messagebox(\"#{obter_texto(:msg_falha_instala)}\" % e.message)\r\n            UI.openURL(url)\r\n          end\r\n        end\r\n      end\r\n    RUBY\r\n\r\n    # --- Módulo WindowUtils ---\r\n    module WindowUtils\r\n      extend Fiddle::Importer\r\n      dlload 'user32.dll' if Sketchup.platform == :platform_win\r\n\r\n      if Sketchup.platform == :platform_win\r\n        typealias 'HWND', 'void*'\r\n        extern 'HWND GetActiveWindow()'\r\n        extern 'HWND GetForegroundWindow()'\r\n        extern 'HWND GetWindow(HWND, int)'\r\n        extern 'int GetWindowRect(HWND, void*)'\r\n        extern 'HWND GetParent(HWND)'\r\n        \r\n        GW_CHILD = 5\r\n        GW_HWNDNEXT = 2\r\n        Rect = struct ['long left', 'long top', 'long right', 'long bottom']\r\n      end\r\n\r\n      def self.get_viewport_rect_deep(view)\r\n        return nil unless Sketchup.platform == :platform_win\r\n        hwnd = GetForegroundWindow()\r\n        return nil if hwnd.nil? || hwnd == 0\r\n        vw = view.vpwidth\r\n        vh = view.vpheight\r\n        found = find_recursive(hwnd, vw, vh)\r\n        return found if found\r\n        parent = GetParent(hwnd)\r\n        if parent && parent != 0\r\n          found = find_recursive(parent, vw, vh)\r\n          return found if found\r\n        end\r\n        nil\r\n      end\r\n\r\n      def self.find_recursive(parent_hwnd, target_w, target_h)\r\n        child = GetWindow(parent_hwnd, GW_CHILD)\r\n        while child && child.to_i != 0\r\n          rect = Rect.malloc\r\n          if GetWindowRect(child, rect) != 0\r\n            w = rect.right - rect.left\r\n            h = rect.bottom - rect.top\r\n            match = check_match(w, h, target_w, target_h, rect)\r\n            return match if match\r\n          end\r\n          found_in_child = find_recursive(child, target_w, target_h)\r\n          return found_in_child if found_in_child\r\n          child = GetWindow(child, GW_HWNDNEXT)\r\n        end\r\n        nil\r\n      end\r\n\r\n      def self.check_match(w, h, target_w, target_h, rect)\r\n        tol = 30\r\n        [1.0, 1.25, 1.5, 2.0].each do |scale|\r\n          if (w - target_w * scale).abs <= tol && (h - target_h * scale).abs <= tol\r\n            return { :x => rect.left, :y => rect.top, :w => w, :h => h, :scale => scale }\r\n          end\r\n        end\r\n        nil\r\n      end\r\n    end\r\n\r\n    # --- Módulo ScreenCapture ---\r\n    module ScreenCapture\r\n      extend Fiddle::Importer\r\n      if Sketchup.platform == :platform_win\r\n        dlload 'gdi32.dll', 'user32.dll'\r\n        extern 'void* GetDC(void*)'\r\n        extern 'int ReleaseDC(void*, void*)'\r\n        extern 'int PrintWindow(void*, void*, unsigned int)'\r\n        extern 'void* CreateCompatibleDC(void*)'\r\n        extern 'void* CreateCompatibleBitmap(void*, int, int)'\r\n        extern 'void* SelectObject(void*, void*)'\r\n        extern 'int BitBlt(void*, int, int, int, int, void*, int, int, unsigned long)'\r\n        extern 'int StretchBlt(void*, int, int, int, int, void*, int, int, int, int, unsigned long)'\r\n        extern 'int SetStretchBltMode(void*, int)'\r\n        extern 'int GetDIBits(void*, void*, unsigned int, unsigned int, void*, void*, unsigned int)'\r\n        extern 'int DeleteDC(void*)'\r\n        extern 'int DeleteObject(void*)'\r\n        SRCCOPY        = 0x00CC0020\r\n        HALFTONE       = 4\r\n        DIB_RGB_COLORS = 0\r\n      end\r\n\r\n      def self.pack_bitmapinfoheader(width, height, image_size)\r\n        [40, width, -height, 1, 24, 0, image_size, 0, 0, 0, 0].pack('L<l<l<S<S<L<L<l<l<L<L<')\r\n      end\r\n\r\n      def self.pack_bmp_file_header(pixel_data_size)\r\n        file_size = 14 + 40 + pixel_data_size\r\n        [0x4D42, file_size, 0, 0, 54].pack('S<L<S<S<L<')\r\n      end\r\n\r\n      def self.capture_viewport(view, thumb_w = 96, thumb_h = 60)\r\n        return nil unless Sketchup.platform == :platform_win\r\n        vp = WindowUtils.get_viewport_rect_deep(view)\r\n        return nil unless vp\r\n        src_w = vp[:w]\r\n        src_h = vp[:h]\r\n        screen_dc = GetDC(0)\r\n        return nil if screen_dc.nil? || screen_dc.to_i == 0\r\n        begin\r\n          mem_dc = CreateCompatibleDC(screen_dc)\r\n          return nil if mem_dc.nil? || mem_dc.to_i == 0\r\n          begin\r\n            bmp = CreateCompatibleBitmap(screen_dc, thumb_w, thumb_h)\r\n            return nil if bmp.nil? || bmp.to_i == 0\r\n            begin\r\n              old = SelectObject(mem_dc, bmp)\r\n              SetStretchBltMode(mem_dc, HALFTONE)\r\n              ok = StretchBlt(mem_dc, 0, 0, thumb_w, thumb_h, screen_dc, vp[:x], vp[:y], src_w, src_h, SRCCOPY)\r\n              return nil if ok == 0\r\n              SelectObject(mem_dc, old)\r\n              old = nil\r\n              stride = ((thumb_w * 3 + 3) & ~3)\r\n              pixel_size = stride * thumb_h\r\n              bmi_bytes = pack_bitmapinfoheader(thumb_w, thumb_h, pixel_size)\r\n              bmi_ptr = Fiddle::Pointer.malloc(bmi_bytes.bytesize)\r\n              bmi_ptr[0, bmi_bytes.bytesize] = bmi_bytes\r\n              buf = Fiddle::Pointer.malloc(pixel_size)\r\n              begin\r\n                rows = GetDIBits(mem_dc, bmp, 0, thumb_h, buf, bmi_ptr, DIB_RGB_COLORS)\r\n                return nil if rows == 0\r\n                pixel_data = buf[0, pixel_size]\r\n                file_hdr = pack_bmp_file_header(pixel_size)\r\n                info_hdr = pack_bitmapinfoheader(thumb_w, thumb_h, pixel_size)\r\n                Base64.strict_encode64(file_hdr + info_hdr + pixel_data)\r\n              ensure\r\n                Fiddle.free(bmi_ptr) if bmi_ptr\r\n                Fiddle.free(buf) if buf\r\n              end\r\n            ensure\r\n              SelectObject(mem_dc, old) if old\r\n              DeleteObject(bmp)\r\n            end\r\n          ensure\r\n            DeleteDC(mem_dc)\r\n          end\r\n        ensure\r\n          ReleaseDC(0, screen_dc)\r\n        end\r\n      rescue => e\r\n        nil\r\n      end\r\n    end\r\n\r\n    class AreaSelectorTool\r\n      def initialize(callback)\r\n        @callback = callback\r\n        @start_x = nil; @start_y = nil; @current_x = nil; @current_y = nil\r\n        @drawing = false\r\n      end\r\n      def activate\r\n        Sketchup.active_model.active_view.invalidate\r\n        Sketchup.status_text = TourVirtualMultiTimeline.obter_texto(:status_area)\r\n      end\r\n      def onLButtonDown(flags, x, y, view)\r\n        @start_x = x; @start_y = y; @current_x = x; @current_y = y\r\n        @drawing = true\r\n      end\r\n      def onMouseMove(flags, x, y, view)\r\n        if @drawing\r\n          @current_x = x; @current_y = y\r\n          view.invalidate\r\n        end\r\n      end\r\n      def onLButtonUp(flags, x, y, view)\r\n        return unless @drawing\r\n        @drawing = false\r\n        x1 = [@start_x, @current_x].min\r\n        y1 = [@start_y, @current_y].min\r\n        x2 = [@start_x, @current_x].max\r\n        y2 = [@start_y, @current_y].max\r\n        width = x2 - x1\r\n        height = y2 - y1\r\n        if width < 50 || height < 50\r\n          UI.messagebox(TourVirtualMultiTimeline.obter_texto(:msg_area_pequena))\r\n          Sketchup.active_model.select_tool(nil)\r\n          return\r\n        end\r\n        @callback.call({ :x => x1, :y => y1, :w => width, :h => height })\r\n        Sketchup.active_model.select_tool(nil) \r\n      end\r\n      def draw(view)\r\n        return unless @drawing && @start_x && @current_x\r\n        points = [\r\n          Geom::Point3d.new(@start_x, @start_y, 0),\r\n          Geom::Point3d.new(@current_x, @start_y, 0),\r\n          Geom::Point3d.new(@current_x, @current_y, 0),\r\n          Geom::Point3d.new(@start_x, @current_y, 0)\r\n        ]\r\n        view.line_width = 3\r\n        view.drawing_color = 'red'\r\n        view.draw2d(GL_LINE_LOOP, points)\r\n      end\r\n    end\r\n\r\n    class ExportPreviewTool\r\n      def initialize(target_w, target_h)\r\n        @target_w = target_w\r\n        @target_h = target_h\r\n      end\r\n      def activate\r\n        Sketchup.active_model.active_view.invalidate\r\n      end\r\n      def deactivate(view)\r\n        view.invalidate\r\n      end\r\n      def draw(view)\r\n        vw = view.vpwidth\r\n        vh = view.vpheight\r\n        ew = [@target_w, vw].min\r\n        eh = [@target_h, vh].min\r\n        ox = (vw - ew) / 2\r\n        oy = (vh - eh) / 2\r\n        view.drawing_color = Sketchup::Color.new(0, 0, 0, 120)\r\n        if oy > 0\r\n          view.draw2d(GL_QUADS, [Geom::Point3d.new(0,0,0), Geom::Point3d.new(vw,0,0), Geom::Point3d.new(vw,oy,0), Geom::Point3d.new(0,oy,0)])\r\n          view.draw2d(GL_QUADS, [Geom::Point3d.new(0,oy+eh,0), Geom::Point3d.new(vw,oy+eh,0), Geom::Point3d.new(vw,vh,0), Geom::Point3d.new(0,vh,0)])\r\n        end\r\n        if ox > 0\r\n          view.draw2d(GL_QUADS, [Geom::Point3d.new(0,oy,0), Geom::Point3d.new(ox,oy,0), Geom::Point3d.new(ox,oy+eh,0), Geom::Point3d.new(0,oy+eh,0)])\r\n          view.draw2d(GL_QUADS, [Geom::Point3d.new(ox+ew,oy,0), Geom::Point3d.new(vw,oy,0), Geom::Point3d.new(vw,oy+eh,0), Geom::Point3d.new(ox+ew,oy+eh,0)])\r\n        end\r\n        view.line_width = 2\r\n        view.drawing_color = Sketchup::Color.new(255, 255, 255, 200)\r\n        view.draw2d(GL_LINE_LOOP, [Geom::Point3d.new(ox,oy,0), Geom::Point3d.new(ox+ew,oy,0), Geom::Point3d.new(ox+ew,oy+eh,0), Geom::Point3d.new(ox,oy+eh,0)])\r\n      end\r\n    end\r\n\r\n    module CameraTimeline\r\n      module GlobalKey\r\n        extend Fiddle::Importer\r\n        if Sketchup.platform == :platform_win\r\n          dlload 'user32.dll'\r\n          extern 'short GetAsyncKeyState(int)'\r\n        else\r\n          dlload '/System/Library/Frameworks/ApplicationServices.framework/ApplicationServices'\r\n          extern 'bool CGEventSourceKeyState(int, int)'\r\n        end\r\n        DEFAULT_HOTKEY = Sketchup.platform == :platform_win ? 0x6B : 69\r\n        @key_code = Sketchup.read_default(\"TourVirtual\", \"Hotkey\", DEFAULT_HOTKEY).to_i\r\n        @ctrl = Sketchup.read_default(\"TourVirtual\", \"HotkeyCtrl\", false)\r\n        @alt = Sketchup.read_default(\"TourVirtual\", \"HotkeyAlt\", false)\r\n        @shift = Sketchup.read_default(\"TourVirtual\", \"HotkeyShift\", false)\r\n        VK_CONTROL = 0x11; VK_MENU = 0x12; VK_SHIFT = 0x10\r\n        MAC_CTRL = 59; MAC_SHIFT = 56; MAC_ALT = 58\r\n        def self.set_hotkey(code, ctrl, alt, shift)\r\n          @key_code = code.to_i; @ctrl = ctrl; @alt = alt; @shift = shift\r\n        end\r\n        def self.key_code; @key_code; end\r\n        def self.ctrl; @ctrl; end\r\n        def self.alt; @alt; end\r\n        def self.shift; @shift; end\r\n        def self.key_pressed?(code)\r\n          if Sketchup.platform == :platform_win\r\n            GetAsyncKeyState(code) & 0x8000 != 0\r\n          else\r\n            CGEventSourceKeyState(0, code)\r\n          end\r\n        end\r\n        def self.space_pressed?\r\n          return false unless key_pressed?(@key_code)\r\n          if Sketchup.platform == :platform_win\r\n            return false if @ctrl && !key_pressed?(VK_CONTROL)\r\n            return false if @alt && !key_pressed?(VK_MENU)\r\n            return false if @shift && !key_pressed?(VK_SHIFT)\r\n          else\r\n            return false if @ctrl && !key_pressed?(MAC_CTRL)\r\n            return false if @alt && !key_pressed?(MAC_ALT)\r\n            return false if @shift && !key_pressed?(MAC_SHIFT)\r\n          end\r\n          true\r\n        end\r\n      end\r\n\r\n      def self.start_space_timer\r\n        return if defined?(@space_timer) && @space_timer\r\n        @space_down = false\r\n        @space_timer = UI.start_timer(0.1, true) do\r\n          if GlobalKey.space_pressed?\r\n            unless @space_down\r\n              @space_down = true\r\n              @dialog.execute_script('triggerSpaceFromRuby()')\r\n            end\r\n          else\r\n            @space_down = false\r\n          end\r\n        end\r\n      end\r\n\r\n      def self.stop_space_timer\r\n        if defined?(@space_timer) && @space_timer\r\n          UI.stop_timer(@space_timer)\r\n          @space_timer = nil\r\n        end\r\n      end\r\n\r\n      def self.capture_thumbnail\r\n        view = Sketchup.active_model.active_view\r\n        result = ScreenCapture.capture_viewport(view, 96, 60) rescue nil\r\n        return result if result && result.length > 0\r\n        path = File.join(Dir.tmpdir, \"thumb_\\#{Time.now.to_i}.jpg\")\r\n        view.write_image(path, 96, 60, false, 0.5)\r\n        encoded = Base64.strict_encode64(File.binread(path))\r\n        File.delete(path) if File.exist?(path)\r\n        encoded\r\n      end\r\n\r\n      def self.calcular_rect_gravacao(export_width, export_height)\r\n        view = Sketchup.active_model.active_view\r\n        viewport_global = WindowUtils.get_viewport_rect_deep(view)\r\n        unless viewport_global\r\n          viewport_global = { :x => 0, :y => 0, :w => view.vpwidth, :h => view.vpheight, :scale => 1.0 }\r\n        end\r\n        vp_w = viewport_global[:w]\r\n        vp_h = viewport_global[:h]\r\n        final_w = [export_width.to_i, vp_w].min\r\n        final_h = [export_height.to_i, vp_h].min\r\n        offset_x = viewport_global[:x] + ((vp_w - final_w) / 2).to_i\r\n        offset_y = viewport_global[:y] + ((vp_h - final_h) / 2).to_i\r\n        final_w -= 1 if final_w.odd?\r\n        final_h -= 1 if final_h.odd?\r\n        { :x => offset_x, :y => offset_y, :w => final_w, :h => final_h }\r\n      end\r\n\r\n      def self.iniciar_processo_exportacao(json_data, use_easing, start_index_from_js, export_width, export_height, filename)\r\n        effective_index = start_index_from_js.to_i\r\n        if effective_index == 0\r\n          @dialog.execute_script(\"currentIndex = 0; updateTime(0); sketchup.goto_camera(JSON.stringify(visoes[0]));\")\r\n          sleep(0.5)\r\n        end\r\n        rect = calcular_rect_gravacao(export_width, export_height)\r\n        executar_gravacao_ffmpeg(json_data, use_easing, rect, effective_index, filename)\r\n      end\r\n\r\n      def self.iniciar_processo_exportacao_projeto(all_timelines_json, use_easing, active_tl_index, start_vision_index, export_width, export_height, filename)\r\n        timelines = JSON.parse(all_timelines_json, symbolize_names: true)\r\n        rect = calcular_rect_gravacao(export_width, export_height)\r\n        start_tl = active_tl_index.to_i\r\n        start_vision = start_vision_index.to_i\r\n        total_time = 0.0\r\n        timelines.each_with_index do |tl, i|\r\n          next if i < start_tl\r\n          next unless tl[:visoes] && tl[:visoes].length >= 2\r\n          sorted = tl[:visoes].sort_by { |v| v[:time] }\r\n          first_v = (i == start_tl && start_vision > 0 && start_vision < sorted.length) ? start_vision : 0\r\n          if first_v < sorted.length - 1\r\n            total_time += sorted.last[:time] - sorted[first_v][:time]\r\n            total_time += 0.5\r\n          end\r\n        end\r\n        play_cmd = \"startRecordingPlayAll(\\#{start_tl}, \\#{start_vision})\"\r\n        executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, play_cmd)\r\n      end\r\n\r\n      def self.executar_gravacao_ffmpeg(json_data, use_easing, rect, start_index, filename)\r\n        camera_keys = JSON.parse(json_data, symbolize_names: true)\r\n        camera_keys.sort_by! { |v| v[:time] }\r\n        total_time = 0\r\n        if start_index < camera_keys.length - 1\r\n          relevant_keys = camera_keys[start_index..-1]\r\n          relevant_keys.each_cons(2) { |c, n| total_time += (n[:time] - c[:time]).abs }\r\n        end\r\n        executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, \"triggerSpaceFromRuby()\")\r\n      end\r\n\r\n      def self.executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, play_command)\r\n        folder = UI.select_directory(title: TourVirtualMultiTimeline.obter_texto(:select_dir))\r\n        return unless folder\r\n        output_path = File.join(folder, \"\\#{filename}.mp4\")\r\n        is_win = Sketchup.platform == :platform_win\r\n        ffmpeg_path = File.join(PLUGIN_DIR, 'ffmpeg', is_win ? 'ffmpeg.exe' : 'ffmpeg')\r\n        unless File.exist?(ffmpeg_path)\r\n          UI.messagebox(TourVirtualMultiTimeline.obter_texto(:msg_ffmpeg_nao_encon))\r\n          return\r\n        end\r\n        duration_padding = 4.0\r\n        recording_duration = total_time + duration_padding\r\n        input_format = is_win ? 'gdigrab' : 'avfoundation'\r\n        input_source = is_win ? 'desktop' : '1:none'\r\n        cmd_array = [\"\\\\\"\\#{ffmpeg_path}\\\\\"\", '-y', '-f', input_format, '-framerate', '30', '-t', recording_duration.to_s]\r\n        if is_win\r\n          cmd_array.concat(['-draw_mouse', '0', '-offset_x', rect[:x].to_s, '-offset_y', rect[:y].to_s, '-video_size', \"\\#{rect[:w]}x\\#{rect[:h]}\", '-i', input_source])\r\n        else\r\n          cmd_array.concat(['-i', input_source, '-vf', \"crop=\\#{rect[:w]}:\\#{rect[:h]}:\\#{rect[:x]}:\\#{rect[:y]}\"])\r\n        end\r\n        cmd_array.concat(['-c:v', 'libx264', '-preset', 'ultrafast', '-pix_fmt', 'yuv420p', \"\\\\\"\\#{output_path}\\\\\"\"])\r\n        cmd = cmd_array.join(' ')\r\n        begin\r\n          if is_win\r\n            WIN32OLE.new('WScript.Shell').Run(cmd, 0, false)\r\n          else\r\n            pid = spawn(cmd)\r\n            Process.detach(pid)\r\n          end\r\n        rescue => e\r\n          UI.messagebox(TourVirtualMultiTimeline.obter_texto(:msg_erro_gravador) % e.message)\r\n          return\r\n        end\r\n        sleep(1.5)\r\n        @dialog.execute_script(\"showRecordingIndicator()\")\r\n        @dialog.execute_script(play_command)\r\n        UI.start_timer(recording_duration + 1.0, false) do\r\n          @dialog.execute_script(\"hideRecordingIndicator()\")\r\n          UI.messagebox(TourVirtualMultiTimeline.obter_texto(:msg_gravacao_fim) % output_path)\r\n          @dialog.execute_script(\"resetPlayButton(); resetPlayAll();\")\r\n        end\r\n      end\r\n\r\n      def self.start_ui\r\n        current_hotkey = GlobalKey.key_code\r\n        hotkey_ctrl = GlobalKey.ctrl ? 'true' : 'false'\r\n        hotkey_alt = GlobalKey.alt ? 'true' : 'false'\r\n        hotkey_shift = GlobalKey.shift ? 'true' : 'false'\r\n        ffmpeg_path = File.join(PLUGIN_DIR, 'ffmpeg', Sketchup.platform == :platform_win ? 'ffmpeg.exe' : 'ffmpeg')\r\n        has_ffmpeg = File.exist?(ffmpeg_path)\r\n        view = Sketchup.active_model.active_view\r\n        vp_width = view.vpwidth\r\n        vp_height = view.vpheight\r\n\r\n        html = <<-HTML\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n  <meta charset=\"utf-8\">\r\n  <title>#{obter_texto(:html_titulo)}</title>\r\n  <style>\r\n    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }\r\n    body { font-family: system-ui, -apple-system, 'Segoe UI', sans-serif; background: #f5f5f5; color: #333; font-size: 13px; padding: 16px; line-height: 1.4; }\r\n    .header { display: flex; align-items: center; gap: 10px; padding-bottom: 14px; border-bottom: 2px solid #0066cc; margin-bottom: 16px; }\r\n    .header h1 { font-size: 17px; font-weight: 700; color: #1a1a1a; }\r\n    .header .subtitle { font-size: 11px; color: #888; font-weight: 400; }\r\n    .card { background: #fff; border: 1px solid #e0e0e0; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.06); margin-bottom: 12px; overflow: hidden; }\r\n    .card-header { display: flex; align-items: center; justify-content: space-between; padding: 10px 14px; background: #fafafa; border-bottom: 1px solid #eee; cursor: pointer; user-select: none; }\r\n    .card-header h2 { font-size: 13px; font-weight: 600; color: #444; }\r\n    .card-header .toggle-icon { font-size: 11px; color: #999; transition: transform 0.2s; }\r\n    .card-header.collapsed .toggle-icon { transform: rotate(-90deg); }\r\n    .card-body { padding: 14px; }\r\n    .card-body.collapsed { display: none; }\r\n    .timeline-wrapper { position: relative; padding: 8px 0 20px; }\r\n    .timeline-track { position: absolute; top: 20px; left: 6px; right: 6px; height: 4px; background: #ddd; border-radius: 2px; z-index: 0; }\r\n    #timeline_range { -webkit-appearance: none; appearance: none; width: 100%; height: 6px; background: transparent; outline: none; position: relative; z-index: 2; cursor: pointer; }\r\n    #timeline_range::-webkit-slider-runnable-track { height: 6px; background: linear-gradient(90deg, #0066cc 0%, #4da6ff 100%); border-radius: 3px; }\r\n    #timeline_range::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; background: #0066cc; border: 2px solid #fff; border-radius: 50%; margin-top: -5px; cursor: grab; box-shadow: 0 1px 4px rgba(0,0,0,0.2); }\r\n    #markers_layer { position: absolute; top: 0; left: 0; width: 100%; height: 40px; pointer-events: none; z-index: 3; }\r\n    .marker { position: absolute; top: 26px; width: 14px; height: 14px; background: #0066cc; border-radius: 50%; border: 2px solid #fff; transform: translateX(-50%); pointer-events: auto; cursor: pointer; box-shadow: 0 1px 3px rgba(0,0,0,0.15); transition: transform 0.15s, background 0.15s; }\r\n    .marker .marker-tooltip { position: absolute; bottom: 18px; left: 50%; transform: translateX(-50%); background: #333; color: #fff; font-size: 10px; padding: 2px 6px; border-radius: 3px; white-space: nowrap; opacity: 0; pointer-events: none; transition: opacity 0.15s; }\r\n    .marker:hover .marker-tooltip { opacity: 1; }\r\n    .time-display { font-size: 20px; font-weight: 700; color: #0066cc; }\r\n    .btn { display: inline-flex; align-items: center; justify-content: center; gap: 6px; padding: 7px 14px; border: 1px solid transparent; border-radius: 6px; font-size: 12px; font-weight: 500; cursor: pointer; transition: all 0.15s; outline: none; }\r\n    .btn-primary { background: #0066cc; color: #fff; }\r\n    .btn-success { background: #28a745; color: #fff; }\r\n    .btn-danger { background: #dc3545; color: #fff; }\r\n    .btn-outline { background: transparent; border: 1px solid #ccc; color: #555; }\r\n    .btn-record { background: #dc3545; color: #fff; padding: 10px 20px; font-size: 13px; font-weight: 600; width:100%; margin-top:12px; }\r\n    .check-group { display: flex; align-items: center; gap: 16px; margin-top: 10px; }\r\n    .hotkey-editor { display: none; align-items: center; gap: 6px; background: #f9f9f9; padding: 6px 10px; border-radius: 6px; border: 1px solid #ddd; }\r\n    .hotkey-editor.visible { display: inline-flex; }\r\n    .vision-list { max-height: 350px; overflow-y: auto; }\r\n    .vision-item { display: flex; align-items: center; gap: 10px; padding: 8px 10px; border-bottom: 1px solid #f0f0f0; cursor: pointer; }\r\n    .vision-item img { width: 72px; height: 45px; object-fit: cover; border-radius: 4px; border: 1px solid #ddd; }\r\n    .recording-bar { display: none; align-items: center; gap: 8px; padding: 10px 14px; background: #fff5f5; border: 1px solid #f5c6cb; border-radius: 6px; margin-top: 10px; }\r\n    .recording-bar.active { display: flex; }\r\n    .recording-dot { width: 10px; height: 10px; background: #dc3545; border-radius: 50%; animation: pulse 1s infinite; }\r\n    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }\r\n    .tl-item { display: flex; align-items: center; gap: 8px; padding: 6px 10px; border-bottom: 1px solid #f0f0f0; cursor: pointer; font-size: 12px; }\r\n    .tl-item.active { border-left: 3px solid #0066cc; background: #f7faff; }\r\n    .hidden { display: none !important; }\r\n  </style>\r\n</head>\r\n<body>\r\n<div class=\"header\">\r\n  <svg width=\"28\" height=\"28\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"#0066cc\" stroke-width=\"2\"><path d=\"M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z\"/><circle cx=\"12\" cy=\"13\" r=\"4\"/></svg>\r\n  <div><h1>#{obter_texto(:html_titulo)}</h1><span class=\"subtitle\">#{obter_texto(:html_subtitle)}</span></div>\r\n</div>\r\n<div class=\"card\">\r\n  <div class=\"card-body\">\r\n    <div class=\"timeline-wrapper\">\r\n      <div class=\"timeline-track\"></div>\r\n      <input type=\"range\" min=\"0\" max=\"60\" step=\"0.1\" value=\"0\" id=\"timeline_range\" oninput=\"updateTime(this.value)\">\r\n      <div id=\"markers_layer\"></div>\r\n    </div>\r\n    <div style=\"display:flex; justify-content:space-between; align-items:center;\">\r\n      <div class=\"time-display\"><span id=\"current_time\">0.0</span><small>s</small></div>\r\n      <div><label>#{obter_texto(:html_total)}</label> <input id=\"max_time\" type=\"number\" step=\"1\" value=\"60\" min=\"1\" onchange=\"atualizarTempoTotal()\" style=\"width:60px;\">s</div>\r\n    </div>\r\n  </div>\r\n</div>\r\n<div class=\"card playback-card\">\r\n  <div class=\"card-body\">\r\n    <div style=\"display:flex; gap:8px; flex-wrap:wrap;\">\r\n      <button class=\"btn btn-primary\" onclick=\"addVision()\">+ #{obter_texto(:html_visao)}</button>\r\n      <button id=\"play_button\" class=\"btn btn-success\" onclick=\"togglePlay()\">&#9654; #{obter_texto(:html_play)}</button>\r\n      <button id=\"play_all_button\" class=\"btn btn-outline hidden\" onclick=\"togglePlayAll()\">#{obter_texto(:html_play_all)}</button>\r\n      <button class=\"btn btn-outline\" onclick=\"mostrarCampoAtalho()\">#{obter_texto(:html_atalho)}</button>\r\n      <span id=\"hotkey_edit\" class=\"hotkey-editor\">\r\n        <input id=\"hotkey_input\" type=\"text\" placeholder=\"#{obter_texto(:js_placeholder_press)}\" onkeydown=\"capturarAtalhoInput(event)\" style=\"width:100px;\">\r\n        <button class=\"btn btn-primary\" onclick=\"confirmarAtalho()\">Ok</button>\r\n      </span>\r\n    </div>\r\n    <div class=\"check-group\">\r\n      <label><input type=\"checkbox\" id=\"loop_checkbox\"> #{obter_texto(:html_loop)}</label>\r\n      <label><input type=\"checkbox\" id=\"easing_checkbox\"> #{obter_texto(:html_easing)}</label>\r\n    </div>\r\n  </div>\r\n</div>\r\n<div class=\"card\">\r\n  <div class=\"card-header\" onclick=\"toggleSection('visions')\">\r\n    <h2>#{obter_texto(:html_visoes_salvas)} <span id=\"vision_count\"></span></h2>\r\n    <span id=\"visions_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body\" id=\"visions_body\"><div class=\"vision-list\" id=\"lista_visoes\"></div></div>\r\n</div>\r\n<div class=\"card\">\r\n  <div class=\"card-header\" onclick=\"toggleSection('timeline_mgr')\">\r\n    <h2>#{obter_texto(:html_gerenciar)}</h2>\r\n    <span id=\"timeline_mgr_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body\" id=\"timeline_mgr_body\">\r\n    <div style=\"display:flex; gap:8px; margin-bottom:10px;\">\r\n      <button class=\"btn btn-outline\" onclick=\"novaTimeline()\">#{obter_texto(:html_nova)}</button>\r\n      <button class=\"btn btn-outline\" onclick=\"exportarTimeline()\">#{obter_texto(:html_exportar_atual)}</button>\r\n      <button class=\"btn btn-outline\" onclick=\"exportarProjeto()\">#{obter_texto(:html_exportar_proj)}</button>\r\n      <button class=\"btn btn-outline\" onclick=\"document.getElementById('import_file').click()\">#{obter_texto(:html_importar)}</button>\r\n      <input type=\"file\" id=\"import_file\" class=\"hidden\" accept=\".json\" onchange=\"importarTimeline(this)\">\r\n    </div>\r\n    <div id=\"saved_timelines_list\"></div>\r\n  </div>\r\n</div>\r\n<div class=\"card\">\r\n  <div class=\"card-header collapsed\" onclick=\"toggleSection('export')\">\r\n    <h2>#{obter_texto(:html_exportar_video)}</h2>\r\n    <span id=\"export_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body collapsed\" id=\"export_body\">\r\n    <div id=\"ffmpeg_section\" class=\"#{has_ffmpeg ? '' : 'hidden'}\">\r\n      <p>#{obter_texto(:html_viewport_atual)} <b>#{vp_width}x#{vp_height}px</b></p>\r\n      <select id=\"preset_select\" onchange=\"onPresetChange()\" style=\"width:100%; margin:10px 0; padding:5px;\">\r\n        <option value=\"\" disabled selected>#{obter_texto(:html_preset_sel)}</option>\r\n      </select>\r\n      <div id=\"preset_preview\" style=\"display:none; color:#0066cc; margin-bottom:10px;\"></div>\r\n      <label><input type=\"checkbox\" id=\"rec_projeto\"> #{obter_texto(:html_rec_projeto)}</label><br>\r\n      <label><input type=\"checkbox\" id=\"rec_inicio\" checked> #{obter_texto(:html_rec_inicio)}</label>\r\n      <button class=\"btn btn-record\" id=\"btn_record\" onclick=\"iniciarGravacao()\" disabled>#{obter_texto(:html_btn_record)}</button>\r\n      <div class=\"recording-bar\" id=\"recording_bar\"><div class=\"recording-dot\"></div><span>#{obter_texto(:html_gravando)}</span></div>\r\n    </div>\r\n    <div id=\"ffmpeg_install\" class=\"#{has_ffmpeg ? 'hidden' : ''}\" style=\"text-align:center;\">\r\n      <p>#{obter_texto(:html_ffmpeg_req)}</p>\r\n      <button class=\"btn btn-primary\" onclick=\"instalarExportacao()\">#{obter_texto(:html_instalar_ffmpeg)}</button>\r\n    </div>\r\n  </div>\r\n</div>\r\n<div id=\"filename_modal\" style=\"display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:100;align-items:center;justify-content:center;\">\r\n  <div style=\"background:#fff;padding:20px;border-radius:8px;width:300px;\">\r\n    <h3>#{obter_texto(:html_modal_titulo)}</h3>\r\n    <input id=\"filename_input\" type=\"text\" style=\"width:100%; padding:5px; margin:10px 0;\">\r\n    <p style=\"font-size:11px; color:#666;\">#{obter_texto(:html_modal_ext)}</p>\r\n    <div style=\"text-align:right; margin-top:10px;\">\r\n      <button class=\"btn btn-outline\" onclick=\"fecharModalFilename()\">#{obter_texto(:html_btn_cancelar)}</button>\r\n      <button class=\"btn btn-primary\" onclick=\"confirmarFilename()\">#{obter_texto(:html_btn_salvar)}</button>\r\n    </div>\r\n  </div>\r\n</div>\r\n<script>\r\n    let visoes = [], playing = false, currentIndex = 0;\r\n    let hotkey = { keyCode: #{current_hotkey}, ctrl: #{hotkey_ctrl}, alt: #{hotkey_alt}, shift: #{hotkey_shift} };\r\n    let savedTimelines = [], activeTimelineIndex = -1, playingAll = false, playAllQueue = [];\r\n    var viewportW = #{vp_width}, viewportH = #{vp_height};\r\n\r\n    const EXPORT_FORMATS = [\r\n      { label: '16:9 Paisagem', ratio: [16, 9] },\r\n      { label: '9:16 Retrato', ratio: [9, 16] },\r\n      { label: '1:1 Quadrado', ratio: [1, 1] },\r\n      { label: 'Viewport Inteira', ratio: null }\r\n    ];\r\n\r\n    function updateTime(val) { document.getElementById(\"current_time\").innerText = parseFloat(val).toFixed(1); }\r\n    function toggleSection(n) {\r\n      let b = document.getElementById(n+'_body'), i = document.getElementById(n+'_toggle');\r\n      b.classList.toggle('collapsed'); i.innerHTML = b.classList.contains('collapsed') ? '&#9654;' : '&#9660;';\r\n      if(n==='export' && b.classList.contains('collapsed') && window.sketchup) window.sketchup.hide_export_preview();\r\n    }\r\n    function atualizarTempoTotal() {\r\n      let v = parseFloat(document.getElementById(\"max_time\").value); if(isNaN(v)||v<=0) return;\r\n      document.getElementById(\"timeline_range\").max = v; renderMarkers();\r\n    }\r\n    function addVision() {\r\n      if(savedTimelines.length===0 && visoes.length===0){\r\n        let n = prompt(\"#{obter_texto(:js_prompt_nome_tl)}\", \"TL 1\"); if(!n) return;\r\n        savedTimelines.push({name:n, visoes:[], maxTime:60}); activeTimelineIndex=0; renderSavedTimelines();\r\n      }\r\n      sketchup.capture_camera(parseFloat(document.getElementById(\"timeline_range\").value));\r\n    }\r\n    function captureVisionFromRuby(j) {\r\n      let o = JSON.parse(j); o.anchor=false; visoes=visoes.filter(v=>v.time!==o.time);\r\n      visoes.push(o); visoes.sort((a,b)=>a.time-b.time); if(visoes.length>0) visoes[0].time=0;\r\n      syncActiveTimeline(); renderMarkers(); renderSavedTimelines();\r\n    }\r\n    function renderMarkers() {\r\n      let l = document.getElementById(\"markers_layer\"), list = document.getElementById(\"lista_visoes\"), range = document.getElementById(\"timeline_range\");\r\n      let max = parseFloat(range.max), w = range.offsetWidth; l.innerHTML=\"\"; list.innerHTML=\"\";\r\n      document.getElementById(\"vision_count\").innerText = visoes.length ? \"(\"+visoes.length+\")\" : \"\";\r\n      if(!visoes.length){ list.innerHTML='<div style=\"text-align:center;padding:20px;color:#999;\">#{obter_texto(:js_empty_state)}</div>'; return; }\r\n      visoes.forEach((v,i)=>{\r\n        let m = document.createElement(\"div\"); m.className=\"marker\";\r\n        m.style.left = ((v.time/max)*(w-16)+8)+\"px\"; m.onclick=()=>{range.value=v.time; updateTime(v.time); currentIndex=i; sketchup.goto_camera(JSON.stringify(v));};\r\n        l.appendChild(m);\r\n        let item = document.createElement(\"div\"); item.className=\"vision-item\";\r\n        item.innerHTML = '<span>'+(i+1)+'</span><img src=\"data:image/bmp;base64,'+v.thumb+'\"><div>'+v.time+'s</div>';\r\n        item.onclick = m.onclick; list.appendChild(item);\r\n      });\r\n    }\r\n    function syncActiveTimeline() { if(activeTimelineIndex>=0) { savedTimelines[activeTimelineIndex].visoes=JSON.parse(JSON.stringify(visoes)); savedTimelines[activeTimelineIndex].maxTime=parseFloat(document.getElementById(\"max_time\").value); } }\r\n    function togglePlay() {\r\n      if(!playing){\r\n        if(visoes.length<2) return alert(\"#{obter_texto(:js_alert_duas_visoes)}\");\r\n        playing=true; document.getElementById(\"play_button\").innerText=\"Stop\";\r\n        sketchup.play_tour(JSON.stringify(visoes), document.getElementById(\"loop_checkbox\").checked, false, document.getElementById(\"easing_checkbox\").checked, currentIndex);\r\n      } else { resetPlayButton(); sketchup.stop_tour(); }\r\n    }\r\n    function resetPlayButton(){ playing=false; document.getElementById(\"play_button\").innerText=\"Play\"; }\r\n    function novaTimeline() {\r\n      let n = prompt(\"#{obter_texto(:js_prompt_nova_tl)}\", \"TL \"+(savedTimelines.length+1)); if(!n) return;\r\n      syncActiveTimeline(); savedTimelines.push({name:n, visoes:[], maxTime:60}); activeTimelineIndex=savedTimelines.length-1;\r\n      visoes=[]; document.getElementById(\"max_time\").value=60; renderMarkers(); renderSavedTimelines();\r\n    }\r\n    function switchTimeline(i) { syncActiveTimeline(); activeTimelineIndex=i; let t=savedTimelines[i]; visoes=JSON.parse(JSON.stringify(t.visoes)); document.getElementById(\"max_time\").value=t.maxTime; renderMarkers(); renderSavedTimelines(); }\r\n    function renderSavedTimelines() {\r\n      let c = document.getElementById(\"saved_timelines_list\"); c.innerHTML=\"\";\r\n      savedTimelines.forEach((t,i)=>{\r\n        let d = document.createElement(\"div\"); d.className=\"tl-item\"+(i===activeTimelineIndex?\" active\":\"\");\r\n        d.innerHTML='<span>'+t.name+'</span><small>('+t.visoes.length+')</small>'; d.onclick=()=>switchTimeline(i); c.appendChild(d);\r\n      });\r\n      document.getElementById(\"play_all_button\").classList.toggle(\"hidden\", savedTimelines.length<2);\r\n    }\r\n    function onPresetChange() {\r\n      let s = document.getElementById(\"preset_select\"), idx = parseInt(s.value), fmt = EXPORT_FORMATS[idx];\r\n      document.getElementById(\"btn_record\").disabled=false;\r\n      let w=viewportW, h=viewportH; if(fmt.ratio){ let sc=Math.min(viewportW/fmt.ratio[0], viewportH/fmt.ratio[1]); w=Math.floor(fmt.ratio[0]*sc); h=Math.floor(fmt.ratio[1]*sc); }\r\n      w=w%2?w-1:w; h=h%2?h-1:h;\r\n      document.getElementById(\"preset_preview\").innerText=\"#{obter_texto(:js_area_gravacao)}\"+w+\"x\"+h+\"px\";\r\n      document.getElementById(\"preset_preview\").style.display=\"block\";\r\n      sketchup.show_export_preview(w,h);\r\n    }\r\n    function iniciarGravacao() {\r\n      if(visoes.length<2 && !document.getElementById(\"rec_projeto\").checked) return alert(\"#{obter_texto(:js_alert_duas_visoes)}\");\r\n      document.getElementById(\"filename_modal\").style.display=\"flex\";\r\n    }\r\n    function fecharModalFilename() { document.getElementById(\"filename_modal\").style.display=\"none\"; }\r\n    function confirmarFilename() {\r\n      let n = document.getElementById(\"filename_input\").value; if(!n) return alert(\"#{obter_texto(:js_alert_nome_arq)}\");\r\n      fecharModalFilename(); let s = document.getElementById(\"preset_select\"), fmt = EXPORT_FORMATS[parseInt(s.value)];\r\n      let w=viewportW, h=viewportH; if(fmt.ratio){ let sc=Math.min(viewportW/fmt.ratio[0], viewportH/fmt.ratio[1]); w=Math.floor(fmt.ratio[0]*sc); h=Math.floor(fmt.ratio[1]*sc); }\r\n      w=w%2?w-1:w; h=h%2?h-1:h;\r\n      if(document.getElementById(\"rec_projeto\").checked) sketchup.start_export_project(JSON.stringify(savedTimelines), document.getElementById(\"easing_checkbox\").checked, activeTimelineIndex, 0, w, h, n);\r\n      else sketchup.start_export_process(JSON.stringify(visoes), document.getElementById(\"easing_checkbox\").checked, 0, w, h, n);\r\n    }\r\n    function showRecordingIndicator() { document.getElementById(\"recording_bar\").classList.add(\"active\"); }\r\n    function hideRecordingIndicator() { document.getElementById(\"recording_bar\").classList.remove(\"active\"); }\r\n    function instalarExportacao() { sketchup.install_ffmpeg(); }\r\n    populatePresets();\r\n    function populatePresets(){ let s=document.getElementById(\"preset_select\"); EXPORT_FORMATS.forEach((f,i)=>{let o=document.createElement(\"option\"); o.value=i; o.text=f.label; s.add(o);}); }\r\n    window.captureVisionFromRuby = captureVisionFromRuby;\r\n    window.showRecordingIndicator = showRecordingIndicator;\r\n    window.hideRecordingIndicator = hideRecordingIndicator;\r\n    window.resetPlayButton = resetPlayButton;\r\n</script>\r\n</body>\r\n</html>\r\nHTML\r\n\r\n        @dialog ||= UI::HtmlDialog.new({:dialog_title => obter_texto(:html_titulo), :width => 430, :height => 790, :style => UI::HtmlDialog::STYLE_DIALOG})\r\n        @dialog.set_html(html)\r\n        start_space_timer\r\n        @dialog.add_action_callback(\"set_hotkey\") { |_, k, c, a, s| GlobalKey.set_hotkey(k.to_i, c, a, s) }\r\n        @dialog.add_action_callback(\"capture_camera\") do |_, t|\r\n          cam = Sketchup.active_model.active_view.camera\r\n          camera_data = {time: t.to_f, eye: cam.eye.to_a, target: cam.target.to_a, up: cam.up.to_a, fov: cam.fov, perspective: cam.perspective?, thumb: capture_thumbnail}\r\n          @dialog.execute_script(\"captureVisionFromRuby(\\\"#{camera_data.to_json.gsub('\"', '\\\"')}\\\")\")\r\n        end\r\n        @dialog.add_action_callback(\"goto_camera\") do |_, j|\r\n          d = JSON.parse(j, symbolize_names: true)\r\n          cam = Sketchup::Camera.new(d[:eye], d[:target], d[:up], d[:perspective])\r\n          cam.fov = d[:fov]; Sketchup.active_model.active_view.camera = cam\r\n        end\r\n        @dialog.add_action_callback(\"play_tour\") do |_, j, l, i, e, s|\r\n          @camera_keys = JSON.parse(j, symbolize_names: true).sort_by{|v| v[:time]}\r\n          @index = s.to_i; view = Sketchup.active_model.active_view\r\n          define_singleton_method(:play_transition) do\r\n            cur = @camera_keys[@index]; nxt = @camera_keys[@index+1]\r\n            unless nxt; @dialog.execute_script(\"resetPlayButton()\"); return; end\r\n            dur = (nxt[:time]-cur[:time]).abs; t_start = Time.now\r\n            @timer_id = UI.start_timer(0.03, true) do\r\n              t = [ (Time.now-t_start)/dur, 1.0 ].min\r\n              t = t < 0.5 ? 2*t*t : -1+(4-2*t)*t if e\r\n              eye = cur[:eye].zip(nxt[:eye]).map{|a,b| a+(b-a)*t}\r\n              target = cur[:target].zip(nxt[:target]).map{|a,b| a+(b-a)*t}\r\n              up = cur[:up].zip(nxt[:up]).map{|a,b| a+(b-a)*t}\r\n              fov = cur[:fov] + (nxt[:fov]-cur[:fov])*t\r\n              view.camera = Sketchup::Camera.new(eye, target, up, cur[:perspective])\r\n              view.camera.fov = fov; view.refresh\r\n              if t >= 1.0; UI.stop_timer(@timer_id); @index += 1; play_transition; end\r\n            end\r\n          end\r\n          play_transition\r\n        end\r\n        @dialog.add_action_callback(\"start_export_process\") { |_, j, e, s, w, h, f| iniciar_processo_exportacao(j, e, s, w, h, f) }\r\n        @dialog.add_action_callback(\"start_export_project\") { |_, j, e, ti, vi, w, h, f| iniciar_processo_exportacao_projeto(j, e, ti, vi, w, h, f) }\r\n        @dialog.add_action_callback(\"install_ffmpeg\") { eval(FFMPEG_INSTALL_SCRIPT, TOPLEVEL_BINDING); UI.messagebox(obter_texto(:ffmpeg_msg_pos_inst)) }\r\n        @dialog.add_action_callback(\"stop_tour\") { UI.stop_timer(@timer_id) if @timer_id }\r\n        @dialog.add_action_callback(\"show_export_preview\") { |_, w, h| @preview_tool = ExportPreviewTool.new(w.to_i, h.to_i); Sketchup.active_model.select_tool(@preview_tool) }\r\n        @dialog.add_action_callback(\"hide_export_preview\") { Sketchup.active_model.select_tool(nil); @preview_tool = nil }\r\n        @dialog.set_on_closed { UI.stop_timer(@timer_id) if defined?(@timer_id); stop_space_timer; Sketchup.active_model.select_tool(nil) if @preview_tool }\r\n        @dialog.show\r\n      end\r\n    end\r\n\r\n    def self.executar\r\n      CameraTimeline.start_ui\r\n    end\r\n\r\n  end\r\nend\r\n\r\nScriptUpComunidade::TourVirtualMultiTimeline.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "teletransporte-42ulf",
    "title": {
      "pt": "Teletransporte",
      "en": "Teleportation",
      "es": "Teletransportación"
    },
    "author": "Fábio",
    "version": "1.0",
    "description": {
      "pt": "Permite transportar uma geometria de um lugar para outro.",
      "en": "It allows you to transport a geometry from one place to another.",
      "es": "Permite transportar una geometría de un lugar a otro."
    },
    "keywords": {
      "pt": [
        "cópia"
      ],
      "en": [
        "copy"
      ],
      "es": [
        "copiar"
      ]
    },
    "code": {
      "pt": "module TeletransportadorDeGeometria\r\n  class Tool\r\n    VK_CONTROL ||= 17\r\n    VK_SHIFT ||= 16\r\n\r\n    def initialize\r\n      @step = :select_source\r\n      @mode = :transportar\r\n      @localizacao = :interno\r\n      @source = nil\r\n    end\r\n\r\n    def activate\r\n      Sketchup.status_text = status_message\r\n      Sketchup.active_model.selection.clear\r\n    end\r\n\r\n    def status_message\r\n      acao = @mode == :transportar ? \"Transportar\" : \"Substituir\"\r\n      local = @localizacao == :interno ? \"Interno\" : \"Externo\"\r\n      case @step\r\n      when :select_source\r\n        \"Modo: #{acao} | Localização: #{local} | Clique no item que será transportado.\"\r\n      when :select_target\r\n        \"Modo: #{acao} | Localização: #{local} | Clique no local de destino.\"\r\n      end\r\n    end\r\n\r\n    def onKeyDown(key, repeat, flags, view)\r\n      case key\r\n      when VK_CONTROL\r\n        @mode = (@mode == :transportar ? :substituir : :transportar)\r\n      when VK_SHIFT\r\n        @localizacao = (@localizacao == :interno ? :externo : :interno)\r\n      end\r\n      Sketchup.status_text = status_message\r\n    end\r\n\r\n    def onMouseMove(flags, x, y, view)\r\n      model = Sketchup.active_model\r\n      ph = view.pick_helper\r\n      ph.do_pick(x, y)\r\n      path = ph.path_at(0)\r\n      return model.selection.clear unless path\r\n    \r\n      entity = path.to_a.first\r\n    \r\n      if @step == :select_source\r\n        if entity.is_a?(Sketchup::Group) || entity.is_a?(Sketchup::ComponentInstance)\r\n          model.selection.clear\r\n          model.selection.add(entity)\r\n        else\r\n          model.selection.clear\r\n        end\r\n      else\r\n        entity = path.to_a.reverse.find { |e| e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance) }\r\n        if entity\r\n          model.selection.clear\r\n          model.selection.add(entity)\r\n        else\r\n          model.selection.clear\r\n        end\r\n      end\r\n\r\n      Sketchup.status_text = status_message\r\n    end\r\n\r\n    def onLButtonDown(flags, x, y, view)\r\n      model = Sketchup.active_model\r\n      ph = view.pick_helper\r\n      ph.do_pick(x, y)\r\n      path = ph.path_at(0)\r\n      return unless path\r\n\r\n      path_array = path.to_a\r\n\r\n      if @step == :select_source\r\n        entity = path_array.first\r\n        return unless entity.is_a?(Sketchup::Group) || entity.is_a?(Sketchup::ComponentInstance)\r\n      else\r\n        entity = path_array.reverse.find { |e| e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance) }\r\n        return unless entity\r\n      end\r\n\r\n      # Garante unicidade\r\n      entity.make_unique if entity.respond_to?(:make_unique)\r\n\r\n      instance_path = Sketchup::InstancePath.new(path_array[0..path_array.index(entity)])\r\n      global_tr = instance_path.transformation\r\n\r\n      if @step == :select_source\r\n        @source = {\r\n          entity: entity,\r\n          definition: entity.definition,\r\n          global_tr: global_tr\r\n        }\r\n        @step = :select_target\r\n        Sketchup.status_text = status_message\r\n      else\r\n        perform_transfer(@source, entity, global_tr, instance_path)\r\n        reset\r\n      end\r\n    end\r\n\r\n    def perform_transfer(source_data, destination, destination_tr, destination_path)\r\n      model = Sketchup.active_model\r\n      model.start_operation(\"Teletransporte\", true)\r\n    \r\n      source_entity = source_data[:entity]\r\n      source_definition = source_data[:definition]\r\n      source_tr = source_data[:global_tr]\r\n    \r\n      if @localizacao == :interno\r\n        dest_entities = destination.definition.entities\r\n        inverse_dest_tr = destination_tr.inverse\r\n        relative_tr = inverse_dest_tr * source_tr\r\n      else\r\n        dest_entities = destination.parent.entities\r\n    \r\n        if destination_path\r\n          parent_path = Sketchup::InstancePath.new(destination_path.to_a[0...-1])\r\n          inverse_parent_path_tr = parent_path.transformation.inverse\r\n          relative_tr = inverse_parent_path_tr * source_tr\r\n        else\r\n          relative_tr = source_tr\r\n        end\r\n      end\r\n    \r\n      new_instance = dest_entities.add_instance(source_definition, relative_tr)\r\n      new_instance.material = source_entity.material if source_entity.material\r\n    \r\n      unless new_instance && new_instance.valid?\r\n        UI.messagebox(\"Erro ao colar instância no destino!\")\r\n        model.abort_operation\r\n        return\r\n      end\r\n    \r\n      if @mode == :substituir\r\n        if @localizacao == :interno\r\n          keep_id = new_instance.entityID\r\n          to_erase = dest_entities.select { |e| e.entityID != keep_id }\r\n          dest_entities.erase_entities(to_erase)\r\n        else\r\n          destination.erase!\r\n        end\r\n      end\r\n    \r\n      source_entity.erase!\r\n    \r\n      model.commit_operation\r\n    end    \r\n\r\n    def reset\r\n      @step = :select_source\r\n      @source = nil\r\n      Sketchup.status_text = status_message\r\n      Sketchup.active_model.selection.clear\r\n    end\r\n\r\n    def deactivate(view)\r\n      Sketchup.status_text = \"\"\r\n      Sketchup.active_model.selection.clear\r\n    end\r\n  end\r\n\r\n  def self.ativar_ferramenta\r\n    Sketchup.active_model.select_tool(Tool.new)\r\n  end\r\nend\r\n\r\nTeletransportadorDeGeometria.ativar_ferramenta"
    },
    "enabled": false,
    "execute": true
  }
]