[
  {
    "id": "suavizar-segmentos-curvos-tcbdn",
    "title": {
      "pt": "Suavizar Segmentos Curvos",
      "en": "Suavizar Segmentos Curvos",
      "es": "Suavizar Segmentos Curvos"
    },
    "author": "Fábio Coutinho",
    "version": "0.5",
    "description": {
      "pt": "Adiciona segmentos em sequência de arestas (curva) para tornar mais suave.",
      "en": "Adiciona segmentos em sequência de arestas (curva) para tornar mais suave.",
      "es": "Adiciona segmentos em sequência de arestas (curva) para tornar mais suave."
    },
    "keywords": {
      "pt": [
        "suaviza curva"
      ],
      "en": [
        "suaviza curva"
      ],
      "es": [
        "suaviza curva"
      ]
    },
    "code": {
      "pt": "require 'sketchup.rb'\r\n\r\nclass SmoothPolyTool\r\n  \r\n  def initialize\r\n    @model = Sketchup.active_model\r\n    @selection = @model.selection\r\n    @view = @model.active_view\r\n    \r\n    @density_multiplier = 1\r\n    @is_loop = false \r\n    \r\n    # Coleta dados iniciais\r\n    @ordered_vertices = get_ordered_vertices(@selection)\r\n    \r\n    if @ordered_vertices.length < 2\r\n      UI.messagebox(\"Selecione uma sequência de arestas conectadas primeiro.\")\r\n      @model.select_tool(nil)\r\n      return\r\n    end\r\n\r\n    @original_segment_count = @is_loop ? @ordered_vertices.length : @ordered_vertices.length - 1\r\n    calculate_distribution_metrics\r\n\r\n    @spline_points = []\r\n    calculate_spline\r\n    \r\n    create_dialog\r\n  end\r\n\r\n  def activate\r\n    @view.invalidate\r\n    update_status\r\n  end\r\n\r\n  # Chamado quando a ferramenta é desativada (ex: usuário trocou de ferramenta ou fechou a janela)\r\n  def deactivate(view)\r\n    # Fecha a janela se ela ainda estiver aberta\r\n    if @dialog && @dialog.visible?\r\n      @dialog.close \r\n    end\r\n    @view.invalidate\r\n  end\r\n\r\n  def draw(view)\r\n    # 1. Caminho Laranja\r\n    if @spline_points && @spline_points.size > 1\r\n      view.line_width = 3\r\n      view.line_stipple = \"\" \r\n      view.drawing_color = \"orange\"\r\n      mode = @is_loop ? GL_LINE_LOOP : GL_LINE_STRIP\r\n      view.draw(mode, @spline_points)\r\n    end\r\n\r\n    # 2. Nós Vermelhos\r\n    if @spline_points && !@spline_points.empty?\r\n      if view.respond_to?(:draw_points)\r\n        view.draw_points(@spline_points, 8, 2, \"red\") \r\n      else\r\n        view.drawing_color = \"red\"\r\n        view.point_size = 8 if view.respond_to?(:point_size=)\r\n        view.draw(GL_POINTS, @spline_points)\r\n      end\r\n    end\r\n  end\r\n\r\n  # --- UI ---\r\n  def create_dialog\r\n    if defined?(UI::HtmlDialog)\r\n      @dialog = UI::HtmlDialog.new({\r\n        :dialog_title => \"Suavizar (Loop & Adaptativo)\",\r\n        :preferences_key => \"com.example.smooth_poly_final\",\r\n        :scrollable => false,\r\n        :resizable => false,\r\n        :width => 320,\r\n        :height => 260, \r\n        :style => UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n      \r\n      # --- CORREÇÃO AQUI: Detecta o fechamento da janela (botão X) ---\r\n      @dialog.set_on_closed {\r\n        # Força a saída da ferramenta selecionando 'nil' (Select Tool)\r\n        Sketchup.active_model.select_tool(nil)\r\n      }\r\n      # ---------------------------------------------------------------\r\n      \r\n    else\r\n      @dialog = UI::WebDialog.new(\"Suavizar\", false, \"SmoothPolyFinal\", 320, 260, 100, 100, true)\r\n      # WebDialog antigo não tem um set_on_closed confiável igual ao HtmlDialog,\r\n      # mas para versões modernas (2017+) o bloco acima resolve.\r\n    end\r\n\r\n    html_content = %{\r\n      <!DOCTYPE html>\r\n      <html>\r\n      <head>\r\n        <style>\r\n          body { font-family: 'Segoe UI', sans-serif; font-size: 12px; padding: 15px; background-color: #f5f5f5; color: #333; overflow: hidden; }\r\n          .container { display: flex; flex-direction: column; gap: 12px; }\r\n          .header { display: flex; justify-content: space-between; align-items: center; }\r\n          label { font-weight: 600; font-size: 13px; }\r\n          input[type=range] { width: 100%; cursor: pointer; }\r\n          .val-display { \r\n            background: #fff; border: 1px solid #ccc; padding: 2px 8px; \r\n            border-radius: 4px; font-weight: bold; color: #E65100; min-width: 30px; text-align: center;\r\n          }\r\n          button { \r\n            padding: 10px; cursor: pointer; background: #2196F3; color: white; \r\n            border: none; border-radius: 4px; font-weight: bold; font-size: 13px;\r\n            text-transform: uppercase; letter-spacing: 0.5px; transition: background 0.2s; margin-top: 5px;\r\n          }\r\n          button:hover { background: #1976D2; }\r\n          .note { font-size: 11px; color: #666; font-style: italic; line-height: 1.3; }\r\n          .tag { font-size: 10px; background: #4CAF50; color: white; padding: 2px 5px; border-radius: 3px; }\r\n        </style>\r\n      </head>\r\n      <body>\r\n        <div class=\"container\">\r\n          <div class=\"header\">\r\n            <label>Densidade:</label>\r\n            <div class=\"val-display\">x<span id=\"val\">1</span></div>\r\n          </div>\r\n          \r\n          <input type=\"range\" id=\"slider\" min=\"1\" max=\"10\" step=\"1\" value=\"1\" oninput=\"updateVal(this.value)\">\r\n          \r\n          <div class=\"note\">\r\n            <span id=\"loop-msg\" style=\"display:none;\" class=\"tag\">LOOP DETECTADO</span><br>\r\n            Ajuste a densidade. A distribuição é adaptativa (foca em curvas) e contínua.\r\n          </div>\r\n\r\n          <button onclick=\"sendApply()\">Concluir (Aplicar)</button>\r\n        </div>\r\n        <script>\r\n          function updateVal(val) {\r\n            document.getElementById('val').innerText = val;\r\n            if (window.sketchup) { sketchup.on_slide(val); } \r\n            else { window.location = 'skp:on_slide@' + val; }\r\n          }\r\n          \r\n          function sendApply() {\r\n            if (window.sketchup) { sketchup.on_apply(); } \r\n            else { window.location = 'skp:on_apply'; }\r\n          }\r\n\r\n          function setLoopStatus(isLoop) {\r\n             if(isLoop) document.getElementById('loop-msg').style.display = 'inline-block';\r\n          }\r\n        </script>\r\n      </body>\r\n      </html>\r\n    }\r\n\r\n    @dialog.set_html(html_content)\r\n    \r\n    @dialog.add_action_callback(\"on_slide\") { |_, val|\r\n      @density_multiplier = val.to_i\r\n      calculate_spline\r\n      @view.invalidate\r\n    }\r\n\r\n    @dialog.add_action_callback(\"on_apply\") { \r\n      commit_geometry\r\n      # Ao selecionar nil aqui, o método deactivate será chamado, fechando a janela\r\n      @model.select_tool(nil)\r\n    }\r\n\r\n    @dialog.add_action_callback(\"exec_js\") { |_, js| @dialog.execute_script(js) }\r\n    \r\n    if @dialog.respond_to?(:center)\r\n      @dialog.center\r\n      @dialog.show\r\n    else\r\n      @dialog.show\r\n    end\r\n\r\n    UI.start_timer(0.5, false) { \r\n      @dialog.execute_script(\"setLoopStatus(#{@is_loop});\") if @dialog.visible?\r\n    }\r\n  end\r\n\r\n  # --- Lógica Matemática ---\r\n\r\n  def get_neighbors(i, points)\r\n    n = points.length\r\n    if @is_loop\r\n      p0 = points[(i - 1) % n]\r\n      p1 = points[i]\r\n      p2 = points[(i + 1) % n]\r\n      p3 = points[(i + 2) % n]\r\n    else\r\n      p0 = i == 0 ? points[0] : points[i-1]\r\n      p1 = points[i]\r\n      p2 = (i+1 >= n) ? points[n-1] : points[i+1]\r\n      p3 = (i+2 >= n) ? points[n-1] : points[i+2]\r\n    end\r\n    return p0, p1, p2, p3\r\n  end\r\n\r\n  def calculate_distribution_metrics\r\n    points = @ordered_vertices\r\n    @segment_weights = []\r\n    total_w = 0.0\r\n    limit = @is_loop ? points.length : points.length - 1\r\n\r\n    (0...limit).each do |i|\r\n      p0, p1, p2, p3 = get_neighbors(i, points)\r\n      len = p1.distance(p2)\r\n      \r\n      v_prev = p1 - p0\r\n      v_curr = p2 - p1\r\n      v_next = p3 - p2\r\n\r\n      angle_start = (v_prev.length > 0 && v_curr.length > 0) ? v_prev.angle_between(v_curr) : 0\r\n      angle_end   = (v_curr.length > 0 && v_next.length > 0) ? v_curr.angle_between(v_next) : 0\r\n      \r\n      avg_curvature = (angle_start + angle_end) / 2.0\r\n      curvature_factor = 1.0 + (avg_curvature * 3.0)\r\n\r\n      weighted_len = len * curvature_factor\r\n      @segment_weights << weighted_len\r\n      total_w += weighted_len\r\n    end\r\n    @total_weighted_length = total_w\r\n  end\r\n\r\n  def calculate_spline\r\n    return if @ordered_vertices.empty?\r\n    points = @ordered_vertices\r\n    @spline_points = []\r\n    \r\n    target_total_segments = [(@original_segment_count * @density_multiplier).round, 1].max\r\n    points_accumulator = 0.0\r\n    limit = @is_loop ? points.length : points.length - 1\r\n\r\n    (0...limit).each do |i|\r\n      p0, p1, p2, p3 = get_neighbors(i, points)\r\n      @spline_points << p1\r\n      \r\n      weighted_len = @segment_weights[i]\r\n      ratio = (@total_weighted_length > 0) ? (weighted_len / @total_weighted_length) : 0\r\n\r\n      exact_steps = ratio * target_total_segments\r\n      points_accumulator += exact_steps\r\n      \r\n      steps_to_draw = points_accumulator.floor\r\n      points_accumulator -= steps_to_draw\r\n\r\n      steps_final = steps_to_draw + 1\r\n\r\n      (1...steps_final).each do |t_step|\r\n        t = t_step.to_f / steps_final\r\n        @spline_points << catmull_rom(p0, p1, p2, p3, t)\r\n      end\r\n    end\r\n    \r\n    if @is_loop\r\n      @spline_points << @spline_points.first\r\n    else\r\n      @spline_points << points.last\r\n    end\r\n  end\r\n\r\n  def catmull_rom(p0, p1, p2, p3, t)\r\n    t2 = t * t\r\n    t3 = t2 * t\r\n    x = 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * t + (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 + (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3)\r\n    y = 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3)\r\n    z = 0.5 * ((2 * p1.z) + (-p0.z + p2.z) * t + (2 * p0.z - 5 * p1.z + 4 * p2.z - p3.z) * t2 + (-p0.z + 3 * p1.z - 3 * p2.z + p3.z) * t3)\r\n    Geom::Point3d.new(x, y, z)\r\n  end\r\n\r\n  def commit_geometry\r\n    edges_to_delete = @selection.grep(Sketchup::Edge)\r\n    return if edges_to_delete.empty?\r\n    \r\n    @model.start_operation(\"Suavizar (Loop)\", true)\r\n    @model.active_entities.erase_entities(edges_to_delete)\r\n    if @spline_points.size > 1\r\n      @model.active_entities.add_curve(@spline_points)\r\n    end\r\n    @model.commit_operation\r\n    @spline_points = []\r\n  end\r\n\r\n  def get_ordered_vertices(selection)\r\n    edges = selection.grep(Sketchup::Edge)\r\n    return [] if edges.empty?\r\n\r\n    vertices = edges.map(&:vertices).flatten\r\n    counts = vertices.each_with_object(Hash.new(0)) { |v, h| h[v] += 1 }\r\n    \r\n    if counts.values.all? { |c| c == 2 }\r\n      @is_loop = true\r\n      start_vertex = edges.first.start \r\n    else\r\n      @is_loop = false\r\n      start_vertex = counts.key(1) \r\n    end\r\n    \r\n    start_vertex ||= edges.first.start \r\n\r\n    sorted_points = [start_vertex.position]\r\n    current_v = start_vertex\r\n    visited_edges = []\r\n    \r\n    while true\r\n      next_edge = current_v.edges.find { |e| edges.include?(e) && !visited_edges.include?(e) }\r\n      break unless next_edge\r\n      visited_edges << next_edge\r\n      other_v = next_edge.other_vertex(current_v)\r\n      if @is_loop && other_v == start_vertex\r\n        break\r\n      end\r\n      sorted_points << other_v.position\r\n      current_v = other_v\r\n    end\r\n\r\n    sorted_points\r\n  end\r\n  \r\n  def update_status\r\n     Sketchup.set_status_text(\"Suavizar: Loop = #{@is_loop ? 'Sim' : 'Não'}\")\r\n  end\r\nend\r\n\r\nSketchup.active_model.select_tool(SmoothPolyTool.new)",
      "en": "require 'sketchup.rb'\r\n\r\nclass SmoothPolyTool\r\n  \r\n  def initialize\r\n    @model = Sketchup.active_model\r\n    @selection = @model.selection\r\n    @view = @model.active_view\r\n    \r\n    @density_multiplier = 1\r\n    @is_loop = false \r\n    \r\n    # Coleta dados iniciais\r\n    @ordered_vertices = get_ordered_vertices(@selection)\r\n    \r\n    if @ordered_vertices.length < 2\r\n      UI.messagebox(\"Selecione uma sequência de arestas conectadas primeiro.\")\r\n      @model.select_tool(nil)\r\n      return\r\n    end\r\n\r\n    @original_segment_count = @is_loop ? @ordered_vertices.length : @ordered_vertices.length - 1\r\n    calculate_distribution_metrics\r\n\r\n    @spline_points = []\r\n    calculate_spline\r\n    \r\n    create_dialog\r\n  end\r\n\r\n  def activate\r\n    @view.invalidate\r\n    update_status\r\n  end\r\n\r\n  # Chamado quando a ferramenta é desativada (ex: usuário trocou de ferramenta ou fechou a janela)\r\n  def deactivate(view)\r\n    # Fecha a janela se ela ainda estiver aberta\r\n    if @dialog && @dialog.visible?\r\n      @dialog.close \r\n    end\r\n    @view.invalidate\r\n  end\r\n\r\n  def draw(view)\r\n    # 1. Caminho Laranja\r\n    if @spline_points && @spline_points.size > 1\r\n      view.line_width = 3\r\n      view.line_stipple = \"\" \r\n      view.drawing_color = \"orange\"\r\n      mode = @is_loop ? GL_LINE_LOOP : GL_LINE_STRIP\r\n      view.draw(mode, @spline_points)\r\n    end\r\n\r\n    # 2. Nós Vermelhos\r\n    if @spline_points && !@spline_points.empty?\r\n      if view.respond_to?(:draw_points)\r\n        view.draw_points(@spline_points, 8, 2, \"red\") \r\n      else\r\n        view.drawing_color = \"red\"\r\n        view.point_size = 8 if view.respond_to?(:point_size=)\r\n        view.draw(GL_POINTS, @spline_points)\r\n      end\r\n    end\r\n  end\r\n\r\n  # --- UI ---\r\n  def create_dialog\r\n    if defined?(UI::HtmlDialog)\r\n      @dialog = UI::HtmlDialog.new({\r\n        :dialog_title => \"Suavizar (Loop & Adaptativo)\",\r\n        :preferences_key => \"com.example.smooth_poly_final\",\r\n        :scrollable => false,\r\n        :resizable => false,\r\n        :width => 320,\r\n        :height => 260, \r\n        :style => UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n      \r\n      # --- CORREÇÃO AQUI: Detecta o fechamento da janela (botão X) ---\r\n      @dialog.set_on_closed {\r\n        # Força a saída da ferramenta selecionando 'nil' (Select Tool)\r\n        Sketchup.active_model.select_tool(nil)\r\n      }\r\n      # ---------------------------------------------------------------\r\n      \r\n    else\r\n      @dialog = UI::WebDialog.new(\"Suavizar\", false, \"SmoothPolyFinal\", 320, 260, 100, 100, true)\r\n      # WebDialog antigo não tem um set_on_closed confiável igual ao HtmlDialog,\r\n      # mas para versões modernas (2017+) o bloco acima resolve.\r\n    end\r\n\r\n    html_content = %{\r\n      <!DOCTYPE html>\r\n      <html>\r\n      <head>\r\n        <style>\r\n          body { font-family: 'Segoe UI', sans-serif; font-size: 12px; padding: 15px; background-color: #f5f5f5; color: #333; overflow: hidden; }\r\n          .container { display: flex; flex-direction: column; gap: 12px; }\r\n          .header { display: flex; justify-content: space-between; align-items: center; }\r\n          label { font-weight: 600; font-size: 13px; }\r\n          input[type=range] { width: 100%; cursor: pointer; }\r\n          .val-display { \r\n            background: #fff; border: 1px solid #ccc; padding: 2px 8px; \r\n            border-radius: 4px; font-weight: bold; color: #E65100; min-width: 30px; text-align: center;\r\n          }\r\n          button { \r\n            padding: 10px; cursor: pointer; background: #2196F3; color: white; \r\n            border: none; border-radius: 4px; font-weight: bold; font-size: 13px;\r\n            text-transform: uppercase; letter-spacing: 0.5px; transition: background 0.2s; margin-top: 5px;\r\n          }\r\n          button:hover { background: #1976D2; }\r\n          .note { font-size: 11px; color: #666; font-style: italic; line-height: 1.3; }\r\n          .tag { font-size: 10px; background: #4CAF50; color: white; padding: 2px 5px; border-radius: 3px; }\r\n        </style>\r\n      </head>\r\n      <body>\r\n        <div class=\"container\">\r\n          <div class=\"header\">\r\n            <label>Densidade:</label>\r\n            <div class=\"val-display\">x<span id=\"val\">1</span></div>\r\n          </div>\r\n          \r\n          <input type=\"range\" id=\"slider\" min=\"1\" max=\"10\" step=\"1\" value=\"1\" oninput=\"updateVal(this.value)\">\r\n          \r\n          <div class=\"note\">\r\n            <span id=\"loop-msg\" style=\"display:none;\" class=\"tag\">LOOP DETECTADO</span><br>\r\n            Ajuste a densidade. A distribuição é adaptativa (foca em curvas) e contínua.\r\n          </div>\r\n\r\n          <button onclick=\"sendApply()\">Concluir (Aplicar)</button>\r\n        </div>\r\n        <script>\r\n          function updateVal(val) {\r\n            document.getElementById('val').innerText = val;\r\n            if (window.sketchup) { sketchup.on_slide(val); } \r\n            else { window.location = 'skp:on_slide@' + val; }\r\n          }\r\n          \r\n          function sendApply() {\r\n            if (window.sketchup) { sketchup.on_apply(); } \r\n            else { window.location = 'skp:on_apply'; }\r\n          }\r\n\r\n          function setLoopStatus(isLoop) {\r\n             if(isLoop) document.getElementById('loop-msg').style.display = 'inline-block';\r\n          }\r\n        </script>\r\n      </body>\r\n      </html>\r\n    }\r\n\r\n    @dialog.set_html(html_content)\r\n    \r\n    @dialog.add_action_callback(\"on_slide\") { |_, val|\r\n      @density_multiplier = val.to_i\r\n      calculate_spline\r\n      @view.invalidate\r\n    }\r\n\r\n    @dialog.add_action_callback(\"on_apply\") { \r\n      commit_geometry\r\n      # Ao selecionar nil aqui, o método deactivate será chamado, fechando a janela\r\n      @model.select_tool(nil)\r\n    }\r\n\r\n    @dialog.add_action_callback(\"exec_js\") { |_, js| @dialog.execute_script(js) }\r\n    \r\n    if @dialog.respond_to?(:center)\r\n      @dialog.center\r\n      @dialog.show\r\n    else\r\n      @dialog.show\r\n    end\r\n\r\n    UI.start_timer(0.5, false) { \r\n      @dialog.execute_script(\"setLoopStatus(#{@is_loop});\") if @dialog.visible?\r\n    }\r\n  end\r\n\r\n  # --- Lógica Matemática ---\r\n\r\n  def get_neighbors(i, points)\r\n    n = points.length\r\n    if @is_loop\r\n      p0 = points[(i - 1) % n]\r\n      p1 = points[i]\r\n      p2 = points[(i + 1) % n]\r\n      p3 = points[(i + 2) % n]\r\n    else\r\n      p0 = i == 0 ? points[0] : points[i-1]\r\n      p1 = points[i]\r\n      p2 = (i+1 >= n) ? points[n-1] : points[i+1]\r\n      p3 = (i+2 >= n) ? points[n-1] : points[i+2]\r\n    end\r\n    return p0, p1, p2, p3\r\n  end\r\n\r\n  def calculate_distribution_metrics\r\n    points = @ordered_vertices\r\n    @segment_weights = []\r\n    total_w = 0.0\r\n    limit = @is_loop ? points.length : points.length - 1\r\n\r\n    (0...limit).each do |i|\r\n      p0, p1, p2, p3 = get_neighbors(i, points)\r\n      len = p1.distance(p2)\r\n      \r\n      v_prev = p1 - p0\r\n      v_curr = p2 - p1\r\n      v_next = p3 - p2\r\n\r\n      angle_start = (v_prev.length > 0 && v_curr.length > 0) ? v_prev.angle_between(v_curr) : 0\r\n      angle_end   = (v_curr.length > 0 && v_next.length > 0) ? v_curr.angle_between(v_next) : 0\r\n      \r\n      avg_curvature = (angle_start + angle_end) / 2.0\r\n      curvature_factor = 1.0 + (avg_curvature * 3.0)\r\n\r\n      weighted_len = len * curvature_factor\r\n      @segment_weights << weighted_len\r\n      total_w += weighted_len\r\n    end\r\n    @total_weighted_length = total_w\r\n  end\r\n\r\n  def calculate_spline\r\n    return if @ordered_vertices.empty?\r\n    points = @ordered_vertices\r\n    @spline_points = []\r\n    \r\n    target_total_segments = [(@original_segment_count * @density_multiplier).round, 1].max\r\n    points_accumulator = 0.0\r\n    limit = @is_loop ? points.length : points.length - 1\r\n\r\n    (0...limit).each do |i|\r\n      p0, p1, p2, p3 = get_neighbors(i, points)\r\n      @spline_points << p1\r\n      \r\n      weighted_len = @segment_weights[i]\r\n      ratio = (@total_weighted_length > 0) ? (weighted_len / @total_weighted_length) : 0\r\n\r\n      exact_steps = ratio * target_total_segments\r\n      points_accumulator += exact_steps\r\n      \r\n      steps_to_draw = points_accumulator.floor\r\n      points_accumulator -= steps_to_draw\r\n\r\n      steps_final = steps_to_draw + 1\r\n\r\n      (1...steps_final).each do |t_step|\r\n        t = t_step.to_f / steps_final\r\n        @spline_points << catmull_rom(p0, p1, p2, p3, t)\r\n      end\r\n    end\r\n    \r\n    if @is_loop\r\n      @spline_points << @spline_points.first\r\n    else\r\n      @spline_points << points.last\r\n    end\r\n  end\r\n\r\n  def catmull_rom(p0, p1, p2, p3, t)\r\n    t2 = t * t\r\n    t3 = t2 * t\r\n    x = 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * t + (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 + (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3)\r\n    y = 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3)\r\n    z = 0.5 * ((2 * p1.z) + (-p0.z + p2.z) * t + (2 * p0.z - 5 * p1.z + 4 * p2.z - p3.z) * t2 + (-p0.z + 3 * p1.z - 3 * p2.z + p3.z) * t3)\r\n    Geom::Point3d.new(x, y, z)\r\n  end\r\n\r\n  def commit_geometry\r\n    edges_to_delete = @selection.grep(Sketchup::Edge)\r\n    return if edges_to_delete.empty?\r\n    \r\n    @model.start_operation(\"Suavizar (Loop)\", true)\r\n    @model.active_entities.erase_entities(edges_to_delete)\r\n    if @spline_points.size > 1\r\n      @model.active_entities.add_curve(@spline_points)\r\n    end\r\n    @model.commit_operation\r\n    @spline_points = []\r\n  end\r\n\r\n  def get_ordered_vertices(selection)\r\n    edges = selection.grep(Sketchup::Edge)\r\n    return [] if edges.empty?\r\n\r\n    vertices = edges.map(&:vertices).flatten\r\n    counts = vertices.each_with_object(Hash.new(0)) { |v, h| h[v] += 1 }\r\n    \r\n    if counts.values.all? { |c| c == 2 }\r\n      @is_loop = true\r\n      start_vertex = edges.first.start \r\n    else\r\n      @is_loop = false\r\n      start_vertex = counts.key(1) \r\n    end\r\n    \r\n    start_vertex ||= edges.first.start \r\n\r\n    sorted_points = [start_vertex.position]\r\n    current_v = start_vertex\r\n    visited_edges = []\r\n    \r\n    while true\r\n      next_edge = current_v.edges.find { |e| edges.include?(e) && !visited_edges.include?(e) }\r\n      break unless next_edge\r\n      visited_edges << next_edge\r\n      other_v = next_edge.other_vertex(current_v)\r\n      if @is_loop && other_v == start_vertex\r\n        break\r\n      end\r\n      sorted_points << other_v.position\r\n      current_v = other_v\r\n    end\r\n\r\n    sorted_points\r\n  end\r\n  \r\n  def update_status\r\n     Sketchup.set_status_text(\"Suavizar: Loop = #{@is_loop ? 'Sim' : 'Não'}\")\r\n  end\r\nend\r\n\r\nSketchup.active_model.select_tool(SmoothPolyTool.new)",
      "es": "require 'sketchup.rb'\r\n\r\nclass SmoothPolyTool\r\n  \r\n  def initialize\r\n    @model = Sketchup.active_model\r\n    @selection = @model.selection\r\n    @view = @model.active_view\r\n    \r\n    @density_multiplier = 1\r\n    @is_loop = false \r\n    \r\n    # Coleta dados iniciais\r\n    @ordered_vertices = get_ordered_vertices(@selection)\r\n    \r\n    if @ordered_vertices.length < 2\r\n      UI.messagebox(\"Selecione uma sequência de arestas conectadas primeiro.\")\r\n      @model.select_tool(nil)\r\n      return\r\n    end\r\n\r\n    @original_segment_count = @is_loop ? @ordered_vertices.length : @ordered_vertices.length - 1\r\n    calculate_distribution_metrics\r\n\r\n    @spline_points = []\r\n    calculate_spline\r\n    \r\n    create_dialog\r\n  end\r\n\r\n  def activate\r\n    @view.invalidate\r\n    update_status\r\n  end\r\n\r\n  # Chamado quando a ferramenta é desativada (ex: usuário trocou de ferramenta ou fechou a janela)\r\n  def deactivate(view)\r\n    # Fecha a janela se ela ainda estiver aberta\r\n    if @dialog && @dialog.visible?\r\n      @dialog.close \r\n    end\r\n    @view.invalidate\r\n  end\r\n\r\n  def draw(view)\r\n    # 1. Caminho Laranja\r\n    if @spline_points && @spline_points.size > 1\r\n      view.line_width = 3\r\n      view.line_stipple = \"\" \r\n      view.drawing_color = \"orange\"\r\n      mode = @is_loop ? GL_LINE_LOOP : GL_LINE_STRIP\r\n      view.draw(mode, @spline_points)\r\n    end\r\n\r\n    # 2. Nós Vermelhos\r\n    if @spline_points && !@spline_points.empty?\r\n      if view.respond_to?(:draw_points)\r\n        view.draw_points(@spline_points, 8, 2, \"red\") \r\n      else\r\n        view.drawing_color = \"red\"\r\n        view.point_size = 8 if view.respond_to?(:point_size=)\r\n        view.draw(GL_POINTS, @spline_points)\r\n      end\r\n    end\r\n  end\r\n\r\n  # --- UI ---\r\n  def create_dialog\r\n    if defined?(UI::HtmlDialog)\r\n      @dialog = UI::HtmlDialog.new({\r\n        :dialog_title => \"Suavizar (Loop & Adaptativo)\",\r\n        :preferences_key => \"com.example.smooth_poly_final\",\r\n        :scrollable => false,\r\n        :resizable => false,\r\n        :width => 320,\r\n        :height => 260, \r\n        :style => UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n      \r\n      # --- CORREÇÃO AQUI: Detecta o fechamento da janela (botão X) ---\r\n      @dialog.set_on_closed {\r\n        # Força a saída da ferramenta selecionando 'nil' (Select Tool)\r\n        Sketchup.active_model.select_tool(nil)\r\n      }\r\n      # ---------------------------------------------------------------\r\n      \r\n    else\r\n      @dialog = UI::WebDialog.new(\"Suavizar\", false, \"SmoothPolyFinal\", 320, 260, 100, 100, true)\r\n      # WebDialog antigo não tem um set_on_closed confiável igual ao HtmlDialog,\r\n      # mas para versões modernas (2017+) o bloco acima resolve.\r\n    end\r\n\r\n    html_content = %{\r\n      <!DOCTYPE html>\r\n      <html>\r\n      <head>\r\n        <style>\r\n          body { font-family: 'Segoe UI', sans-serif; font-size: 12px; padding: 15px; background-color: #f5f5f5; color: #333; overflow: hidden; }\r\n          .container { display: flex; flex-direction: column; gap: 12px; }\r\n          .header { display: flex; justify-content: space-between; align-items: center; }\r\n          label { font-weight: 600; font-size: 13px; }\r\n          input[type=range] { width: 100%; cursor: pointer; }\r\n          .val-display { \r\n            background: #fff; border: 1px solid #ccc; padding: 2px 8px; \r\n            border-radius: 4px; font-weight: bold; color: #E65100; min-width: 30px; text-align: center;\r\n          }\r\n          button { \r\n            padding: 10px; cursor: pointer; background: #2196F3; color: white; \r\n            border: none; border-radius: 4px; font-weight: bold; font-size: 13px;\r\n            text-transform: uppercase; letter-spacing: 0.5px; transition: background 0.2s; margin-top: 5px;\r\n          }\r\n          button:hover { background: #1976D2; }\r\n          .note { font-size: 11px; color: #666; font-style: italic; line-height: 1.3; }\r\n          .tag { font-size: 10px; background: #4CAF50; color: white; padding: 2px 5px; border-radius: 3px; }\r\n        </style>\r\n      </head>\r\n      <body>\r\n        <div class=\"container\">\r\n          <div class=\"header\">\r\n            <label>Densidade:</label>\r\n            <div class=\"val-display\">x<span id=\"val\">1</span></div>\r\n          </div>\r\n          \r\n          <input type=\"range\" id=\"slider\" min=\"1\" max=\"10\" step=\"1\" value=\"1\" oninput=\"updateVal(this.value)\">\r\n          \r\n          <div class=\"note\">\r\n            <span id=\"loop-msg\" style=\"display:none;\" class=\"tag\">LOOP DETECTADO</span><br>\r\n            Ajuste a densidade. A distribuição é adaptativa (foca em curvas) e contínua.\r\n          </div>\r\n\r\n          <button onclick=\"sendApply()\">Concluir (Aplicar)</button>\r\n        </div>\r\n        <script>\r\n          function updateVal(val) {\r\n            document.getElementById('val').innerText = val;\r\n            if (window.sketchup) { sketchup.on_slide(val); } \r\n            else { window.location = 'skp:on_slide@' + val; }\r\n          }\r\n          \r\n          function sendApply() {\r\n            if (window.sketchup) { sketchup.on_apply(); } \r\n            else { window.location = 'skp:on_apply'; }\r\n          }\r\n\r\n          function setLoopStatus(isLoop) {\r\n             if(isLoop) document.getElementById('loop-msg').style.display = 'inline-block';\r\n          }\r\n        </script>\r\n      </body>\r\n      </html>\r\n    }\r\n\r\n    @dialog.set_html(html_content)\r\n    \r\n    @dialog.add_action_callback(\"on_slide\") { |_, val|\r\n      @density_multiplier = val.to_i\r\n      calculate_spline\r\n      @view.invalidate\r\n    }\r\n\r\n    @dialog.add_action_callback(\"on_apply\") { \r\n      commit_geometry\r\n      # Ao selecionar nil aqui, o método deactivate será chamado, fechando a janela\r\n      @model.select_tool(nil)\r\n    }\r\n\r\n    @dialog.add_action_callback(\"exec_js\") { |_, js| @dialog.execute_script(js) }\r\n    \r\n    if @dialog.respond_to?(:center)\r\n      @dialog.center\r\n      @dialog.show\r\n    else\r\n      @dialog.show\r\n    end\r\n\r\n    UI.start_timer(0.5, false) { \r\n      @dialog.execute_script(\"setLoopStatus(#{@is_loop});\") if @dialog.visible?\r\n    }\r\n  end\r\n\r\n  # --- Lógica Matemática ---\r\n\r\n  def get_neighbors(i, points)\r\n    n = points.length\r\n    if @is_loop\r\n      p0 = points[(i - 1) % n]\r\n      p1 = points[i]\r\n      p2 = points[(i + 1) % n]\r\n      p3 = points[(i + 2) % n]\r\n    else\r\n      p0 = i == 0 ? points[0] : points[i-1]\r\n      p1 = points[i]\r\n      p2 = (i+1 >= n) ? points[n-1] : points[i+1]\r\n      p3 = (i+2 >= n) ? points[n-1] : points[i+2]\r\n    end\r\n    return p0, p1, p2, p3\r\n  end\r\n\r\n  def calculate_distribution_metrics\r\n    points = @ordered_vertices\r\n    @segment_weights = []\r\n    total_w = 0.0\r\n    limit = @is_loop ? points.length : points.length - 1\r\n\r\n    (0...limit).each do |i|\r\n      p0, p1, p2, p3 = get_neighbors(i, points)\r\n      len = p1.distance(p2)\r\n      \r\n      v_prev = p1 - p0\r\n      v_curr = p2 - p1\r\n      v_next = p3 - p2\r\n\r\n      angle_start = (v_prev.length > 0 && v_curr.length > 0) ? v_prev.angle_between(v_curr) : 0\r\n      angle_end   = (v_curr.length > 0 && v_next.length > 0) ? v_curr.angle_between(v_next) : 0\r\n      \r\n      avg_curvature = (angle_start + angle_end) / 2.0\r\n      curvature_factor = 1.0 + (avg_curvature * 3.0)\r\n\r\n      weighted_len = len * curvature_factor\r\n      @segment_weights << weighted_len\r\n      total_w += weighted_len\r\n    end\r\n    @total_weighted_length = total_w\r\n  end\r\n\r\n  def calculate_spline\r\n    return if @ordered_vertices.empty?\r\n    points = @ordered_vertices\r\n    @spline_points = []\r\n    \r\n    target_total_segments = [(@original_segment_count * @density_multiplier).round, 1].max\r\n    points_accumulator = 0.0\r\n    limit = @is_loop ? points.length : points.length - 1\r\n\r\n    (0...limit).each do |i|\r\n      p0, p1, p2, p3 = get_neighbors(i, points)\r\n      @spline_points << p1\r\n      \r\n      weighted_len = @segment_weights[i]\r\n      ratio = (@total_weighted_length > 0) ? (weighted_len / @total_weighted_length) : 0\r\n\r\n      exact_steps = ratio * target_total_segments\r\n      points_accumulator += exact_steps\r\n      \r\n      steps_to_draw = points_accumulator.floor\r\n      points_accumulator -= steps_to_draw\r\n\r\n      steps_final = steps_to_draw + 1\r\n\r\n      (1...steps_final).each do |t_step|\r\n        t = t_step.to_f / steps_final\r\n        @spline_points << catmull_rom(p0, p1, p2, p3, t)\r\n      end\r\n    end\r\n    \r\n    if @is_loop\r\n      @spline_points << @spline_points.first\r\n    else\r\n      @spline_points << points.last\r\n    end\r\n  end\r\n\r\n  def catmull_rom(p0, p1, p2, p3, t)\r\n    t2 = t * t\r\n    t3 = t2 * t\r\n    x = 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * t + (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 + (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3)\r\n    y = 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * t + (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 + (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3)\r\n    z = 0.5 * ((2 * p1.z) + (-p0.z + p2.z) * t + (2 * p0.z - 5 * p1.z + 4 * p2.z - p3.z) * t2 + (-p0.z + 3 * p1.z - 3 * p2.z + p3.z) * t3)\r\n    Geom::Point3d.new(x, y, z)\r\n  end\r\n\r\n  def commit_geometry\r\n    edges_to_delete = @selection.grep(Sketchup::Edge)\r\n    return if edges_to_delete.empty?\r\n    \r\n    @model.start_operation(\"Suavizar (Loop)\", true)\r\n    @model.active_entities.erase_entities(edges_to_delete)\r\n    if @spline_points.size > 1\r\n      @model.active_entities.add_curve(@spline_points)\r\n    end\r\n    @model.commit_operation\r\n    @spline_points = []\r\n  end\r\n\r\n  def get_ordered_vertices(selection)\r\n    edges = selection.grep(Sketchup::Edge)\r\n    return [] if edges.empty?\r\n\r\n    vertices = edges.map(&:vertices).flatten\r\n    counts = vertices.each_with_object(Hash.new(0)) { |v, h| h[v] += 1 }\r\n    \r\n    if counts.values.all? { |c| c == 2 }\r\n      @is_loop = true\r\n      start_vertex = edges.first.start \r\n    else\r\n      @is_loop = false\r\n      start_vertex = counts.key(1) \r\n    end\r\n    \r\n    start_vertex ||= edges.first.start \r\n\r\n    sorted_points = [start_vertex.position]\r\n    current_v = start_vertex\r\n    visited_edges = []\r\n    \r\n    while true\r\n      next_edge = current_v.edges.find { |e| edges.include?(e) && !visited_edges.include?(e) }\r\n      break unless next_edge\r\n      visited_edges << next_edge\r\n      other_v = next_edge.other_vertex(current_v)\r\n      if @is_loop && other_v == start_vertex\r\n        break\r\n      end\r\n      sorted_points << other_v.position\r\n      current_v = other_v\r\n    end\r\n\r\n    sorted_points\r\n  end\r\n  \r\n  def update_status\r\n     Sketchup.set_status_text(\"Suavizar: Loop = #{@is_loop ? 'Sim' : 'Não'}\")\r\n  end\r\nend\r\n\r\nSketchup.active_model.select_tool(SmoothPolyTool.new)"
    },
    "enabled": false,
    "execute": true,
    "video": "https://youtu.be/nd8rkwn6BlU?si=a7OmdvWuj5juB07S"
  },
  {
    "id": "cria-textura-a-partir-da-malha-tm3dj",
    "title": {
      "pt": "Cria Textura a Partir da Malha",
      "en": "Cria Textura a Partir da Malha",
      "es": "Cria Textura a Partir da Malha"
    },
    "author": "Fábio Coutinho",
    "version": "0.1",
    "description": {
      "pt": "Cria um material com textura a partir de uma malha plana desenhada com suas arestas e cores ou texturas aplicadas, para ser usada em outra face.",
      "en": "Cria um material com textura a partir de uma malha plana desenhada com suas arestas e cores ou texturas aplicadas, para ser usada em outra face.",
      "es": "Cria um material com textura a partir de uma malha plana desenhada com suas arestas e cores ou texturas aplicadas, para ser usada em outra face."
    },
    "keywords": {
      "pt": [
        "textura"
      ],
      "en": [
        "textura"
      ],
      "es": [
        "textura"
      ]
    },
    "code": {
      "pt": "# ============================================================\r\n# BAKE TEXTURE (MALHA -> NOVO MATERIAL) | SketchUp Ruby Console\r\n# Saída em BMP 32-bit (sem ImageRep vazio)\r\n# ============================================================\r\n\r\nrequire 'sketchup.rb'\r\nrequire 'tmpdir'\r\n\r\nObject.send(:remove_const, :PBD_BakeMeshTexture) if defined?(PBD_BakeMeshTexture)\r\n\r\nmodule PBD_BakeMeshTexture\r\n  extend self\r\n\r\n  DEFAULT_TEX_SIZE = 2048\r\n\r\n  def run(tex_size: DEFAULT_TEX_SIZE)\r\n    m = Sketchup.active_model\r\n    sel = m.selection\r\n    raise \"Selecione faces ou um grupo/componente contendo a malha.\" if sel.empty?\r\n\r\n    faces = collect_faces(sel)\r\n    raise \"Nenhuma face encontrada na seleção.\" if faces.empty?\r\n\r\n    # normal média (plano de projeção)\r\n    n = Geom::Vector3d.new(0,0,0)\r\n    faces.each { |f| n += f.normal }\r\n    n.length < 1e-9 ? (n = Geom::Vector3d.new(0,0,1)) : n.normalize!\r\n\r\n    ref = (n.parallel?(Geom::Vector3d.new(0,0,1)) ? Geom::Vector3d.new(1,0,0) : Geom::Vector3d.new(0,0,1))\r\n    xaxis = n * ref\r\n    xaxis.length < 1e-9 ? (xaxis = Geom::Vector3d.new(1,0,0)) : xaxis.normalize!\r\n    yaxis = n * xaxis\r\n    yaxis.normalize!\r\n\r\n    origin = faces[0].bounds.center\r\n    world_to_plane = Geom::Transformation.axes(origin, xaxis, yaxis, n).inverse\r\n\r\n    # bbox 2D projetado\r\n    bb2 = Geom::BoundingBox.new\r\n    faces.each do |f|\r\n      f.vertices.each do |v|\r\n        p = v.position.transform(world_to_plane)\r\n        bb2.add([p.x, p.y, 0])\r\n      end\r\n    end\r\n\r\n    minx = bb2.min.x\r\n    miny = bb2.min.y\r\n    maxx = bb2.max.x\r\n    maxy = bb2.max.y\r\n    w_real = (maxx - minx)\r\n    h_real = (maxy - miny)\r\n    raise \"BBOX inválido (malha degenerada).\" if w_real.abs < 1e-6 || h_real.abs < 1e-6\r\n\r\n    out_w = tex_size.to_i\r\n    out_h = [(tex_size * (h_real / w_real)).round, 1].max\r\n    out_h = [out_h, tex_size].min\r\n\r\n    # OUTPUT = buffer BGRA (BMP 32-bit)\r\n    out_buf = \"\\x00\" * (out_w * out_h * 4)\r\n\r\n    tex_cache = {}\r\n\r\n    faces.each do |face|\r\n      mat  = face.material\r\n      back = face.back_material\r\n      use_back = (mat.nil? && !back.nil?)\r\n      mat = back if use_back\r\n\r\n      tw = Sketchup.create_texture_writer\r\n      uvh = face.get_UVHelper(true, true, tw)\r\n\r\n      src_rep = nil\r\n      src_w = src_h = nil\r\n      is_textured = false\r\n\r\n      if mat && mat.texture && mat.texture.filename && !mat.texture.filename.empty?\r\n        path = mat.texture.filename\r\n        src_rep = (tex_cache[path] ||= begin\r\n          rep = Sketchup::ImageRep.new\r\n          rep.load_file(path)\r\n          rep\r\n        rescue\r\n          nil\r\n        end)\r\n        if src_rep\r\n          src_w = src_rep.width\r\n          src_h = src_rep.height\r\n          is_textured = true\r\n        end\r\n      end\r\n\r\n      face_color = (mat && mat.color) ? mat.color : Sketchup::Color.new(200,200,200)\r\n\r\n      mesh = face.mesh(0)\r\n      mesh.polygons.each do |poly|\r\n        idx = poly.map(&:abs)\r\n        next if idx.length < 3\r\n\r\n        v0 = idx[0]\r\n        (1..(idx.length-2)).each do |k|\r\n          v1 = idx[k]\r\n          v2 = idx[k+1]\r\n\r\n          p0 = mesh.point_at(v0).transform(world_to_plane)\r\n          p1 = mesh.point_at(v1).transform(world_to_plane)\r\n          p2 = mesh.point_at(v2).transform(world_to_plane)\r\n\r\n          a = plane_to_px(p0, minx, miny, w_real, h_real, out_w, out_h)\r\n          b = plane_to_px(p1, minx, miny, w_real, h_real, out_w, out_h)\r\n          c = plane_to_px(p2, minx, miny, w_real, h_real, out_w, out_h)\r\n\r\n          if is_textured\r\n            uv0 = use_back ? uvh.get_back_UVQ(mesh.point_at(v0)) : uvh.get_front_UVQ(mesh.point_at(v0))\r\n            uv1 = use_back ? uvh.get_back_UVQ(mesh.point_at(v1)) : uvh.get_front_UVQ(mesh.point_at(v1))\r\n            uv2 = use_back ? uvh.get_back_UVQ(mesh.point_at(v2)) : uvh.get_front_UVQ(mesh.point_at(v2))\r\n\r\n            t0 = uvq_to_uv_px(uv0, src_w, src_h)\r\n            t1 = uvq_to_uv_px(uv1, src_w, src_h)\r\n            t2 = uvq_to_uv_px(uv2, src_w, src_h)\r\n\r\n            raster_triangle_uv_buf!(out_buf, out_w, out_h, a,b,c, src_rep, src_w, src_h, t0,t1,t2)\r\n          else\r\n            raster_triangle_color_buf!(out_buf, out_w, out_h, a,b,c, face_color)\r\n          end\r\n        end\r\n      end\r\n    end\r\n\r\n    dir = Dir.tmpdir\r\n    ts = Time.now.strftime(\"%Y%m%d_%H%M%S\")\r\n    bmp_path = File.join(dir, \"baked_mesh_#{ts}.bmp\")\r\n    write_bmp_32(bmp_path, out_w, out_h, out_buf)\r\n\r\n    mats = m.materials\r\n    name = unique_mat_name(mats, \"Baked_Mesh_#{ts}\")\r\n    new_mat = mats.add(name)\r\n    new_mat.texture = bmp_path\r\n    new_mat.texture.size = [w_real, h_real]\r\n\r\n    UI.messagebox(\"Material criado:\\n#{name}\\nTextura:\\n#{bmp_path}\")\r\n    new_mat\r\n  rescue => e\r\n    UI.messagebox(\"Erro:\\n#{e.message}\")\r\n    nil\r\n  end\r\n\r\n  # ---------- util ----------\r\n\r\n  def collect_faces(selection)\r\n    faces = []\r\n    selection.each do |ent|\r\n      case ent\r\n      when Sketchup::Face\r\n        faces << ent\r\n      when Sketchup::Group, Sketchup::ComponentInstance\r\n        faces.concat(rec_faces_in_entities(ent.definition.entities))\r\n      end\r\n    end\r\n    faces.uniq\r\n  end\r\n\r\n  def rec_faces_in_entities(ents, out = [])\r\n    ents.each do |e|\r\n      if e.is_a?(Sketchup::Face)\r\n        out << e\r\n      elsif e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance)\r\n        rec_faces_in_entities(e.definition.entities, out)\r\n      end\r\n    end\r\n    out\r\n  end\r\n\r\n  def plane_to_px(p, minx, miny, w, h, out_w, out_h)\r\n    u = (p.x - minx) / w\r\n    v = (p.y - miny) / h\r\n    x = (u * (out_w - 1)).round\r\n    y = ((1.0 - v) * (out_h - 1)).round\r\n    [x, y]\r\n  end\r\n\r\n  def uvq_to_uv_px(uvq, sw, sh)\r\n    z = uvq.z.to_f\r\n    z = 1.0 if z.abs < 1e-9\r\n    u = uvq.x.to_f / z\r\n    v = uvq.y.to_f / z\r\n    x = (u % 1.0) * (sw - 1)\r\n    y = (1.0 - (v % 1.0)) * (sh - 1)\r\n    [x, y]\r\n  end\r\n\r\n  def unique_mat_name(mats, base)\r\n    n = base\r\n    i = 1\r\n    while mats[n]\r\n      i += 1\r\n      n = \"#{base}_#{i}\"\r\n    end\r\n    n\r\n  end\r\n\r\n  def clamp(v, lo, hi)\r\n    v < lo ? lo : (v > hi ? hi : v)\r\n  end\r\n\r\n  def barycentric(p, a, b, c)\r\n    px, py = p\r\n    ax, ay = a\r\n    bx, by = b\r\n    cx, cy = c\r\n    v0x = bx - ax; v0y = by - ay\r\n    v1x = cx - ax; v1y = cy - ay\r\n    v2x = px - ax; v2y = py - ay\r\n    d00 = v0x*v0x + v0y*v0y\r\n    d01 = v0x*v1x + v0y*v1y\r\n    d11 = v1x*v1x + v1y*v1y\r\n    d20 = v2x*v0x + v2y*v0y\r\n    d21 = v2x*v1x + v2y*v1y\r\n    denom = (d00 * d11 - d01 * d01)\r\n    return nil if denom.abs < 1e-9\r\n    v = (d11 * d20 - d01 * d21) / denom\r\n    w = (d00 * d21 - d01 * d20) / denom\r\n    u = 1.0 - v - w\r\n    [u, v, w]\r\n  end\r\n\r\n  def tri_bbox(a,b,c, w, h)\r\n    xs = [a[0], b[0], c[0]]\r\n    ys = [a[1], b[1], c[1]]\r\n    [clamp(xs.min, 0, w-1), clamp(ys.min, 0, h-1),\r\n     clamp(xs.max, 0, w-1), clamp(ys.max, 0, h-1)]\r\n  end\r\n\r\n  # OUTPUT buffer é BGRA (BMP)\r\n  def set_px_bgra!(buf, w, x, y, r, g, b, a=255)\r\n    i = (y*w + x) * 4\r\n    buf.setbyte(i,     b)\r\n    buf.setbyte(i + 1, g)\r\n    buf.setbyte(i + 2, r)\r\n    buf.setbyte(i + 3, a)\r\n  end\r\n\r\n  def raster_triangle_color_buf!(buf, w, h, a,b,c, color)\r\n    minx, miny, maxx, maxy = tri_bbox(a,b,c, w, h)\r\n    (miny..maxy).each do |y|\r\n      (minx..maxx).each do |x|\r\n        bc = barycentric([x+0.5, y+0.5], a, b, c)\r\n        next unless bc\r\n        u,v,wg = bc\r\n        next if u < -0.001 || v < -0.001 || wg < -0.001\r\n        set_px_bgra!(buf, w, x, y, color.red, color.green, color.blue, 255)\r\n      end\r\n    end\r\n  end\r\n\r\n  def raster_triangle_uv_buf!(buf, ow, oh, a,b,c, src, sw, sh, t0,t1,t2)\r\n    minx, miny, maxx, maxy = tri_bbox(a,b,c, ow, oh)\r\n    src_rows = {}\r\n\r\n    (miny..maxy).each do |y|\r\n      (minx..maxx).each do |x|\r\n        bc = barycentric([x+0.5, y+0.5], a, b, c)\r\n        next unless bc\r\n        u,v,wg = bc\r\n        next if u < -0.001 || v < -0.001 || wg < -0.001\r\n\r\n        tx = t0[0]*u + t1[0]*v + t2[0]*wg\r\n        ty = t0[1]*u + t1[1]*v + t2[1]*wg\r\n\r\n        sx = clamp(tx.round, 0, sw-1)\r\n        sy = clamp(ty.round, 0, sh-1)\r\n\r\n        row = (src_rows[sy] ||= src.get_row(0, sy))\r\n        si = sx * 4\r\n        r = row[si]\r\n        g = row[si+1]\r\n        b = row[si+2]\r\n        a_ = row[si+3]\r\n\r\n        set_px_bgra!(buf, ow, x, y, r, g, b, a_)\r\n      end\r\n    end\r\n  end\r\n\r\n  # BMP 32-bit top-down (altura negativa)\r\n  def write_bmp_32(path, w, h, bgra_buf)\r\n    bgra_buf = bgra_buf.b\r\n\r\n    file_header_size = 14\r\n    dib_header_size  = 40\r\n    pixel_bytes = w * h * 4\r\n    file_size = file_header_size + dib_header_size + pixel_bytes\r\n    offset = file_header_size + dib_header_size\r\n\r\n    fh = \"BM\".b\r\n    fh << [file_size].pack(\"V\")\r\n    fh << [0].pack(\"V\")\r\n    fh << [offset].pack(\"V\")\r\n\r\n    dib = \"\".b\r\n    dib << [dib_header_size].pack(\"V\")\r\n    dib << [w].pack(\"V\")\r\n    dib << [(-h)].pack(\"V\")  # top-down\r\n    dib << [1].pack(\"v\")     # planes\r\n    dib << [32].pack(\"v\")    # bpp\r\n    dib << [0].pack(\"V\")     # BI_RGB\r\n    dib << [pixel_bytes].pack(\"V\")\r\n    dib << [2835].pack(\"V\")\r\n    dib << [2835].pack(\"V\")\r\n    dib << [0].pack(\"V\")\r\n    dib << [0].pack(\"V\")\r\n\r\n    File.binwrite(path, fh + dib + bgra_buf)\r\n  end\r\nend\r\n\r\n# EXEC\r\nPBD_BakeMeshTexture.run(tex_size: 2048)",
      "en": "# ============================================================\r\n# BAKE TEXTURE (MALHA -> NOVO MATERIAL) | SketchUp Ruby Console\r\n# Saída em BMP 32-bit (sem ImageRep vazio)\r\n# ============================================================\r\n\r\nrequire 'sketchup.rb'\r\nrequire 'tmpdir'\r\n\r\nObject.send(:remove_const, :PBD_BakeMeshTexture) if defined?(PBD_BakeMeshTexture)\r\n\r\nmodule PBD_BakeMeshTexture\r\n  extend self\r\n\r\n  DEFAULT_TEX_SIZE = 2048\r\n\r\n  def run(tex_size: DEFAULT_TEX_SIZE)\r\n    m = Sketchup.active_model\r\n    sel = m.selection\r\n    raise \"Selecione faces ou um grupo/componente contendo a malha.\" if sel.empty?\r\n\r\n    faces = collect_faces(sel)\r\n    raise \"Nenhuma face encontrada na seleção.\" if faces.empty?\r\n\r\n    # normal média (plano de projeção)\r\n    n = Geom::Vector3d.new(0,0,0)\r\n    faces.each { |f| n += f.normal }\r\n    n.length < 1e-9 ? (n = Geom::Vector3d.new(0,0,1)) : n.normalize!\r\n\r\n    ref = (n.parallel?(Geom::Vector3d.new(0,0,1)) ? Geom::Vector3d.new(1,0,0) : Geom::Vector3d.new(0,0,1))\r\n    xaxis = n * ref\r\n    xaxis.length < 1e-9 ? (xaxis = Geom::Vector3d.new(1,0,0)) : xaxis.normalize!\r\n    yaxis = n * xaxis\r\n    yaxis.normalize!\r\n\r\n    origin = faces[0].bounds.center\r\n    world_to_plane = Geom::Transformation.axes(origin, xaxis, yaxis, n).inverse\r\n\r\n    # bbox 2D projetado\r\n    bb2 = Geom::BoundingBox.new\r\n    faces.each do |f|\r\n      f.vertices.each do |v|\r\n        p = v.position.transform(world_to_plane)\r\n        bb2.add([p.x, p.y, 0])\r\n      end\r\n    end\r\n\r\n    minx = bb2.min.x\r\n    miny = bb2.min.y\r\n    maxx = bb2.max.x\r\n    maxy = bb2.max.y\r\n    w_real = (maxx - minx)\r\n    h_real = (maxy - miny)\r\n    raise \"BBOX inválido (malha degenerada).\" if w_real.abs < 1e-6 || h_real.abs < 1e-6\r\n\r\n    out_w = tex_size.to_i\r\n    out_h = [(tex_size * (h_real / w_real)).round, 1].max\r\n    out_h = [out_h, tex_size].min\r\n\r\n    # OUTPUT = buffer BGRA (BMP 32-bit)\r\n    out_buf = \"\\x00\" * (out_w * out_h * 4)\r\n\r\n    tex_cache = {}\r\n\r\n    faces.each do |face|\r\n      mat  = face.material\r\n      back = face.back_material\r\n      use_back = (mat.nil? && !back.nil?)\r\n      mat = back if use_back\r\n\r\n      tw = Sketchup.create_texture_writer\r\n      uvh = face.get_UVHelper(true, true, tw)\r\n\r\n      src_rep = nil\r\n      src_w = src_h = nil\r\n      is_textured = false\r\n\r\n      if mat && mat.texture && mat.texture.filename && !mat.texture.filename.empty?\r\n        path = mat.texture.filename\r\n        src_rep = (tex_cache[path] ||= begin\r\n          rep = Sketchup::ImageRep.new\r\n          rep.load_file(path)\r\n          rep\r\n        rescue\r\n          nil\r\n        end)\r\n        if src_rep\r\n          src_w = src_rep.width\r\n          src_h = src_rep.height\r\n          is_textured = true\r\n        end\r\n      end\r\n\r\n      face_color = (mat && mat.color) ? mat.color : Sketchup::Color.new(200,200,200)\r\n\r\n      mesh = face.mesh(0)\r\n      mesh.polygons.each do |poly|\r\n        idx = poly.map(&:abs)\r\n        next if idx.length < 3\r\n\r\n        v0 = idx[0]\r\n        (1..(idx.length-2)).each do |k|\r\n          v1 = idx[k]\r\n          v2 = idx[k+1]\r\n\r\n          p0 = mesh.point_at(v0).transform(world_to_plane)\r\n          p1 = mesh.point_at(v1).transform(world_to_plane)\r\n          p2 = mesh.point_at(v2).transform(world_to_plane)\r\n\r\n          a = plane_to_px(p0, minx, miny, w_real, h_real, out_w, out_h)\r\n          b = plane_to_px(p1, minx, miny, w_real, h_real, out_w, out_h)\r\n          c = plane_to_px(p2, minx, miny, w_real, h_real, out_w, out_h)\r\n\r\n          if is_textured\r\n            uv0 = use_back ? uvh.get_back_UVQ(mesh.point_at(v0)) : uvh.get_front_UVQ(mesh.point_at(v0))\r\n            uv1 = use_back ? uvh.get_back_UVQ(mesh.point_at(v1)) : uvh.get_front_UVQ(mesh.point_at(v1))\r\n            uv2 = use_back ? uvh.get_back_UVQ(mesh.point_at(v2)) : uvh.get_front_UVQ(mesh.point_at(v2))\r\n\r\n            t0 = uvq_to_uv_px(uv0, src_w, src_h)\r\n            t1 = uvq_to_uv_px(uv1, src_w, src_h)\r\n            t2 = uvq_to_uv_px(uv2, src_w, src_h)\r\n\r\n            raster_triangle_uv_buf!(out_buf, out_w, out_h, a,b,c, src_rep, src_w, src_h, t0,t1,t2)\r\n          else\r\n            raster_triangle_color_buf!(out_buf, out_w, out_h, a,b,c, face_color)\r\n          end\r\n        end\r\n      end\r\n    end\r\n\r\n    dir = Dir.tmpdir\r\n    ts = Time.now.strftime(\"%Y%m%d_%H%M%S\")\r\n    bmp_path = File.join(dir, \"baked_mesh_#{ts}.bmp\")\r\n    write_bmp_32(bmp_path, out_w, out_h, out_buf)\r\n\r\n    mats = m.materials\r\n    name = unique_mat_name(mats, \"Baked_Mesh_#{ts}\")\r\n    new_mat = mats.add(name)\r\n    new_mat.texture = bmp_path\r\n    new_mat.texture.size = [w_real, h_real]\r\n\r\n    UI.messagebox(\"Material criado:\\n#{name}\\nTextura:\\n#{bmp_path}\")\r\n    new_mat\r\n  rescue => e\r\n    UI.messagebox(\"Erro:\\n#{e.message}\")\r\n    nil\r\n  end\r\n\r\n  # ---------- util ----------\r\n\r\n  def collect_faces(selection)\r\n    faces = []\r\n    selection.each do |ent|\r\n      case ent\r\n      when Sketchup::Face\r\n        faces << ent\r\n      when Sketchup::Group, Sketchup::ComponentInstance\r\n        faces.concat(rec_faces_in_entities(ent.definition.entities))\r\n      end\r\n    end\r\n    faces.uniq\r\n  end\r\n\r\n  def rec_faces_in_entities(ents, out = [])\r\n    ents.each do |e|\r\n      if e.is_a?(Sketchup::Face)\r\n        out << e\r\n      elsif e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance)\r\n        rec_faces_in_entities(e.definition.entities, out)\r\n      end\r\n    end\r\n    out\r\n  end\r\n\r\n  def plane_to_px(p, minx, miny, w, h, out_w, out_h)\r\n    u = (p.x - minx) / w\r\n    v = (p.y - miny) / h\r\n    x = (u * (out_w - 1)).round\r\n    y = ((1.0 - v) * (out_h - 1)).round\r\n    [x, y]\r\n  end\r\n\r\n  def uvq_to_uv_px(uvq, sw, sh)\r\n    z = uvq.z.to_f\r\n    z = 1.0 if z.abs < 1e-9\r\n    u = uvq.x.to_f / z\r\n    v = uvq.y.to_f / z\r\n    x = (u % 1.0) * (sw - 1)\r\n    y = (1.0 - (v % 1.0)) * (sh - 1)\r\n    [x, y]\r\n  end\r\n\r\n  def unique_mat_name(mats, base)\r\n    n = base\r\n    i = 1\r\n    while mats[n]\r\n      i += 1\r\n      n = \"#{base}_#{i}\"\r\n    end\r\n    n\r\n  end\r\n\r\n  def clamp(v, lo, hi)\r\n    v < lo ? lo : (v > hi ? hi : v)\r\n  end\r\n\r\n  def barycentric(p, a, b, c)\r\n    px, py = p\r\n    ax, ay = a\r\n    bx, by = b\r\n    cx, cy = c\r\n    v0x = bx - ax; v0y = by - ay\r\n    v1x = cx - ax; v1y = cy - ay\r\n    v2x = px - ax; v2y = py - ay\r\n    d00 = v0x*v0x + v0y*v0y\r\n    d01 = v0x*v1x + v0y*v1y\r\n    d11 = v1x*v1x + v1y*v1y\r\n    d20 = v2x*v0x + v2y*v0y\r\n    d21 = v2x*v1x + v2y*v1y\r\n    denom = (d00 * d11 - d01 * d01)\r\n    return nil if denom.abs < 1e-9\r\n    v = (d11 * d20 - d01 * d21) / denom\r\n    w = (d00 * d21 - d01 * d20) / denom\r\n    u = 1.0 - v - w\r\n    [u, v, w]\r\n  end\r\n\r\n  def tri_bbox(a,b,c, w, h)\r\n    xs = [a[0], b[0], c[0]]\r\n    ys = [a[1], b[1], c[1]]\r\n    [clamp(xs.min, 0, w-1), clamp(ys.min, 0, h-1),\r\n     clamp(xs.max, 0, w-1), clamp(ys.max, 0, h-1)]\r\n  end\r\n\r\n  # OUTPUT buffer é BGRA (BMP)\r\n  def set_px_bgra!(buf, w, x, y, r, g, b, a=255)\r\n    i = (y*w + x) * 4\r\n    buf.setbyte(i,     b)\r\n    buf.setbyte(i + 1, g)\r\n    buf.setbyte(i + 2, r)\r\n    buf.setbyte(i + 3, a)\r\n  end\r\n\r\n  def raster_triangle_color_buf!(buf, w, h, a,b,c, color)\r\n    minx, miny, maxx, maxy = tri_bbox(a,b,c, w, h)\r\n    (miny..maxy).each do |y|\r\n      (minx..maxx).each do |x|\r\n        bc = barycentric([x+0.5, y+0.5], a, b, c)\r\n        next unless bc\r\n        u,v,wg = bc\r\n        next if u < -0.001 || v < -0.001 || wg < -0.001\r\n        set_px_bgra!(buf, w, x, y, color.red, color.green, color.blue, 255)\r\n      end\r\n    end\r\n  end\r\n\r\n  def raster_triangle_uv_buf!(buf, ow, oh, a,b,c, src, sw, sh, t0,t1,t2)\r\n    minx, miny, maxx, maxy = tri_bbox(a,b,c, ow, oh)\r\n    src_rows = {}\r\n\r\n    (miny..maxy).each do |y|\r\n      (minx..maxx).each do |x|\r\n        bc = barycentric([x+0.5, y+0.5], a, b, c)\r\n        next unless bc\r\n        u,v,wg = bc\r\n        next if u < -0.001 || v < -0.001 || wg < -0.001\r\n\r\n        tx = t0[0]*u + t1[0]*v + t2[0]*wg\r\n        ty = t0[1]*u + t1[1]*v + t2[1]*wg\r\n\r\n        sx = clamp(tx.round, 0, sw-1)\r\n        sy = clamp(ty.round, 0, sh-1)\r\n\r\n        row = (src_rows[sy] ||= src.get_row(0, sy))\r\n        si = sx * 4\r\n        r = row[si]\r\n        g = row[si+1]\r\n        b = row[si+2]\r\n        a_ = row[si+3]\r\n\r\n        set_px_bgra!(buf, ow, x, y, r, g, b, a_)\r\n      end\r\n    end\r\n  end\r\n\r\n  # BMP 32-bit top-down (altura negativa)\r\n  def write_bmp_32(path, w, h, bgra_buf)\r\n    bgra_buf = bgra_buf.b\r\n\r\n    file_header_size = 14\r\n    dib_header_size  = 40\r\n    pixel_bytes = w * h * 4\r\n    file_size = file_header_size + dib_header_size + pixel_bytes\r\n    offset = file_header_size + dib_header_size\r\n\r\n    fh = \"BM\".b\r\n    fh << [file_size].pack(\"V\")\r\n    fh << [0].pack(\"V\")\r\n    fh << [offset].pack(\"V\")\r\n\r\n    dib = \"\".b\r\n    dib << [dib_header_size].pack(\"V\")\r\n    dib << [w].pack(\"V\")\r\n    dib << [(-h)].pack(\"V\")  # top-down\r\n    dib << [1].pack(\"v\")     # planes\r\n    dib << [32].pack(\"v\")    # bpp\r\n    dib << [0].pack(\"V\")     # BI_RGB\r\n    dib << [pixel_bytes].pack(\"V\")\r\n    dib << [2835].pack(\"V\")\r\n    dib << [2835].pack(\"V\")\r\n    dib << [0].pack(\"V\")\r\n    dib << [0].pack(\"V\")\r\n\r\n    File.binwrite(path, fh + dib + bgra_buf)\r\n  end\r\nend\r\n\r\n# EXEC\r\nPBD_BakeMeshTexture.run(tex_size: 2048)",
      "es": "# ============================================================\r\n# BAKE TEXTURE (MALHA -> NOVO MATERIAL) | SketchUp Ruby Console\r\n# Saída em BMP 32-bit (sem ImageRep vazio)\r\n# ============================================================\r\n\r\nrequire 'sketchup.rb'\r\nrequire 'tmpdir'\r\n\r\nObject.send(:remove_const, :PBD_BakeMeshTexture) if defined?(PBD_BakeMeshTexture)\r\n\r\nmodule PBD_BakeMeshTexture\r\n  extend self\r\n\r\n  DEFAULT_TEX_SIZE = 2048\r\n\r\n  def run(tex_size: DEFAULT_TEX_SIZE)\r\n    m = Sketchup.active_model\r\n    sel = m.selection\r\n    raise \"Selecione faces ou um grupo/componente contendo a malha.\" if sel.empty?\r\n\r\n    faces = collect_faces(sel)\r\n    raise \"Nenhuma face encontrada na seleção.\" if faces.empty?\r\n\r\n    # normal média (plano de projeção)\r\n    n = Geom::Vector3d.new(0,0,0)\r\n    faces.each { |f| n += f.normal }\r\n    n.length < 1e-9 ? (n = Geom::Vector3d.new(0,0,1)) : n.normalize!\r\n\r\n    ref = (n.parallel?(Geom::Vector3d.new(0,0,1)) ? Geom::Vector3d.new(1,0,0) : Geom::Vector3d.new(0,0,1))\r\n    xaxis = n * ref\r\n    xaxis.length < 1e-9 ? (xaxis = Geom::Vector3d.new(1,0,0)) : xaxis.normalize!\r\n    yaxis = n * xaxis\r\n    yaxis.normalize!\r\n\r\n    origin = faces[0].bounds.center\r\n    world_to_plane = Geom::Transformation.axes(origin, xaxis, yaxis, n).inverse\r\n\r\n    # bbox 2D projetado\r\n    bb2 = Geom::BoundingBox.new\r\n    faces.each do |f|\r\n      f.vertices.each do |v|\r\n        p = v.position.transform(world_to_plane)\r\n        bb2.add([p.x, p.y, 0])\r\n      end\r\n    end\r\n\r\n    minx = bb2.min.x\r\n    miny = bb2.min.y\r\n    maxx = bb2.max.x\r\n    maxy = bb2.max.y\r\n    w_real = (maxx - minx)\r\n    h_real = (maxy - miny)\r\n    raise \"BBOX inválido (malha degenerada).\" if w_real.abs < 1e-6 || h_real.abs < 1e-6\r\n\r\n    out_w = tex_size.to_i\r\n    out_h = [(tex_size * (h_real / w_real)).round, 1].max\r\n    out_h = [out_h, tex_size].min\r\n\r\n    # OUTPUT = buffer BGRA (BMP 32-bit)\r\n    out_buf = \"\\x00\" * (out_w * out_h * 4)\r\n\r\n    tex_cache = {}\r\n\r\n    faces.each do |face|\r\n      mat  = face.material\r\n      back = face.back_material\r\n      use_back = (mat.nil? && !back.nil?)\r\n      mat = back if use_back\r\n\r\n      tw = Sketchup.create_texture_writer\r\n      uvh = face.get_UVHelper(true, true, tw)\r\n\r\n      src_rep = nil\r\n      src_w = src_h = nil\r\n      is_textured = false\r\n\r\n      if mat && mat.texture && mat.texture.filename && !mat.texture.filename.empty?\r\n        path = mat.texture.filename\r\n        src_rep = (tex_cache[path] ||= begin\r\n          rep = Sketchup::ImageRep.new\r\n          rep.load_file(path)\r\n          rep\r\n        rescue\r\n          nil\r\n        end)\r\n        if src_rep\r\n          src_w = src_rep.width\r\n          src_h = src_rep.height\r\n          is_textured = true\r\n        end\r\n      end\r\n\r\n      face_color = (mat && mat.color) ? mat.color : Sketchup::Color.new(200,200,200)\r\n\r\n      mesh = face.mesh(0)\r\n      mesh.polygons.each do |poly|\r\n        idx = poly.map(&:abs)\r\n        next if idx.length < 3\r\n\r\n        v0 = idx[0]\r\n        (1..(idx.length-2)).each do |k|\r\n          v1 = idx[k]\r\n          v2 = idx[k+1]\r\n\r\n          p0 = mesh.point_at(v0).transform(world_to_plane)\r\n          p1 = mesh.point_at(v1).transform(world_to_plane)\r\n          p2 = mesh.point_at(v2).transform(world_to_plane)\r\n\r\n          a = plane_to_px(p0, minx, miny, w_real, h_real, out_w, out_h)\r\n          b = plane_to_px(p1, minx, miny, w_real, h_real, out_w, out_h)\r\n          c = plane_to_px(p2, minx, miny, w_real, h_real, out_w, out_h)\r\n\r\n          if is_textured\r\n            uv0 = use_back ? uvh.get_back_UVQ(mesh.point_at(v0)) : uvh.get_front_UVQ(mesh.point_at(v0))\r\n            uv1 = use_back ? uvh.get_back_UVQ(mesh.point_at(v1)) : uvh.get_front_UVQ(mesh.point_at(v1))\r\n            uv2 = use_back ? uvh.get_back_UVQ(mesh.point_at(v2)) : uvh.get_front_UVQ(mesh.point_at(v2))\r\n\r\n            t0 = uvq_to_uv_px(uv0, src_w, src_h)\r\n            t1 = uvq_to_uv_px(uv1, src_w, src_h)\r\n            t2 = uvq_to_uv_px(uv2, src_w, src_h)\r\n\r\n            raster_triangle_uv_buf!(out_buf, out_w, out_h, a,b,c, src_rep, src_w, src_h, t0,t1,t2)\r\n          else\r\n            raster_triangle_color_buf!(out_buf, out_w, out_h, a,b,c, face_color)\r\n          end\r\n        end\r\n      end\r\n    end\r\n\r\n    dir = Dir.tmpdir\r\n    ts = Time.now.strftime(\"%Y%m%d_%H%M%S\")\r\n    bmp_path = File.join(dir, \"baked_mesh_#{ts}.bmp\")\r\n    write_bmp_32(bmp_path, out_w, out_h, out_buf)\r\n\r\n    mats = m.materials\r\n    name = unique_mat_name(mats, \"Baked_Mesh_#{ts}\")\r\n    new_mat = mats.add(name)\r\n    new_mat.texture = bmp_path\r\n    new_mat.texture.size = [w_real, h_real]\r\n\r\n    UI.messagebox(\"Material criado:\\n#{name}\\nTextura:\\n#{bmp_path}\")\r\n    new_mat\r\n  rescue => e\r\n    UI.messagebox(\"Erro:\\n#{e.message}\")\r\n    nil\r\n  end\r\n\r\n  # ---------- util ----------\r\n\r\n  def collect_faces(selection)\r\n    faces = []\r\n    selection.each do |ent|\r\n      case ent\r\n      when Sketchup::Face\r\n        faces << ent\r\n      when Sketchup::Group, Sketchup::ComponentInstance\r\n        faces.concat(rec_faces_in_entities(ent.definition.entities))\r\n      end\r\n    end\r\n    faces.uniq\r\n  end\r\n\r\n  def rec_faces_in_entities(ents, out = [])\r\n    ents.each do |e|\r\n      if e.is_a?(Sketchup::Face)\r\n        out << e\r\n      elsif e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance)\r\n        rec_faces_in_entities(e.definition.entities, out)\r\n      end\r\n    end\r\n    out\r\n  end\r\n\r\n  def plane_to_px(p, minx, miny, w, h, out_w, out_h)\r\n    u = (p.x - minx) / w\r\n    v = (p.y - miny) / h\r\n    x = (u * (out_w - 1)).round\r\n    y = ((1.0 - v) * (out_h - 1)).round\r\n    [x, y]\r\n  end\r\n\r\n  def uvq_to_uv_px(uvq, sw, sh)\r\n    z = uvq.z.to_f\r\n    z = 1.0 if z.abs < 1e-9\r\n    u = uvq.x.to_f / z\r\n    v = uvq.y.to_f / z\r\n    x = (u % 1.0) * (sw - 1)\r\n    y = (1.0 - (v % 1.0)) * (sh - 1)\r\n    [x, y]\r\n  end\r\n\r\n  def unique_mat_name(mats, base)\r\n    n = base\r\n    i = 1\r\n    while mats[n]\r\n      i += 1\r\n      n = \"#{base}_#{i}\"\r\n    end\r\n    n\r\n  end\r\n\r\n  def clamp(v, lo, hi)\r\n    v < lo ? lo : (v > hi ? hi : v)\r\n  end\r\n\r\n  def barycentric(p, a, b, c)\r\n    px, py = p\r\n    ax, ay = a\r\n    bx, by = b\r\n    cx, cy = c\r\n    v0x = bx - ax; v0y = by - ay\r\n    v1x = cx - ax; v1y = cy - ay\r\n    v2x = px - ax; v2y = py - ay\r\n    d00 = v0x*v0x + v0y*v0y\r\n    d01 = v0x*v1x + v0y*v1y\r\n    d11 = v1x*v1x + v1y*v1y\r\n    d20 = v2x*v0x + v2y*v0y\r\n    d21 = v2x*v1x + v2y*v1y\r\n    denom = (d00 * d11 - d01 * d01)\r\n    return nil if denom.abs < 1e-9\r\n    v = (d11 * d20 - d01 * d21) / denom\r\n    w = (d00 * d21 - d01 * d20) / denom\r\n    u = 1.0 - v - w\r\n    [u, v, w]\r\n  end\r\n\r\n  def tri_bbox(a,b,c, w, h)\r\n    xs = [a[0], b[0], c[0]]\r\n    ys = [a[1], b[1], c[1]]\r\n    [clamp(xs.min, 0, w-1), clamp(ys.min, 0, h-1),\r\n     clamp(xs.max, 0, w-1), clamp(ys.max, 0, h-1)]\r\n  end\r\n\r\n  # OUTPUT buffer é BGRA (BMP)\r\n  def set_px_bgra!(buf, w, x, y, r, g, b, a=255)\r\n    i = (y*w + x) * 4\r\n    buf.setbyte(i,     b)\r\n    buf.setbyte(i + 1, g)\r\n    buf.setbyte(i + 2, r)\r\n    buf.setbyte(i + 3, a)\r\n  end\r\n\r\n  def raster_triangle_color_buf!(buf, w, h, a,b,c, color)\r\n    minx, miny, maxx, maxy = tri_bbox(a,b,c, w, h)\r\n    (miny..maxy).each do |y|\r\n      (minx..maxx).each do |x|\r\n        bc = barycentric([x+0.5, y+0.5], a, b, c)\r\n        next unless bc\r\n        u,v,wg = bc\r\n        next if u < -0.001 || v < -0.001 || wg < -0.001\r\n        set_px_bgra!(buf, w, x, y, color.red, color.green, color.blue, 255)\r\n      end\r\n    end\r\n  end\r\n\r\n  def raster_triangle_uv_buf!(buf, ow, oh, a,b,c, src, sw, sh, t0,t1,t2)\r\n    minx, miny, maxx, maxy = tri_bbox(a,b,c, ow, oh)\r\n    src_rows = {}\r\n\r\n    (miny..maxy).each do |y|\r\n      (minx..maxx).each do |x|\r\n        bc = barycentric([x+0.5, y+0.5], a, b, c)\r\n        next unless bc\r\n        u,v,wg = bc\r\n        next if u < -0.001 || v < -0.001 || wg < -0.001\r\n\r\n        tx = t0[0]*u + t1[0]*v + t2[0]*wg\r\n        ty = t0[1]*u + t1[1]*v + t2[1]*wg\r\n\r\n        sx = clamp(tx.round, 0, sw-1)\r\n        sy = clamp(ty.round, 0, sh-1)\r\n\r\n        row = (src_rows[sy] ||= src.get_row(0, sy))\r\n        si = sx * 4\r\n        r = row[si]\r\n        g = row[si+1]\r\n        b = row[si+2]\r\n        a_ = row[si+3]\r\n\r\n        set_px_bgra!(buf, ow, x, y, r, g, b, a_)\r\n      end\r\n    end\r\n  end\r\n\r\n  # BMP 32-bit top-down (altura negativa)\r\n  def write_bmp_32(path, w, h, bgra_buf)\r\n    bgra_buf = bgra_buf.b\r\n\r\n    file_header_size = 14\r\n    dib_header_size  = 40\r\n    pixel_bytes = w * h * 4\r\n    file_size = file_header_size + dib_header_size + pixel_bytes\r\n    offset = file_header_size + dib_header_size\r\n\r\n    fh = \"BM\".b\r\n    fh << [file_size].pack(\"V\")\r\n    fh << [0].pack(\"V\")\r\n    fh << [offset].pack(\"V\")\r\n\r\n    dib = \"\".b\r\n    dib << [dib_header_size].pack(\"V\")\r\n    dib << [w].pack(\"V\")\r\n    dib << [(-h)].pack(\"V\")  # top-down\r\n    dib << [1].pack(\"v\")     # planes\r\n    dib << [32].pack(\"v\")    # bpp\r\n    dib << [0].pack(\"V\")     # BI_RGB\r\n    dib << [pixel_bytes].pack(\"V\")\r\n    dib << [2835].pack(\"V\")\r\n    dib << [2835].pack(\"V\")\r\n    dib << [0].pack(\"V\")\r\n    dib << [0].pack(\"V\")\r\n\r\n    File.binwrite(path, fh + dib + bgra_buf)\r\n  end\r\nend\r\n\r\n# EXEC\r\nPBD_BakeMeshTexture.run(tex_size: 2048)"
    },
    "enabled": false,
    "execute": true,
    "video": "https://youtu.be/tRwWJqDDiHI?si=tlH2vhRPcEViTkec"
  },
  {
    "id": "explosao-radial-1svwj",
    "title": {
      "pt": "Explosão Radial",
      "en": "Radial Explosion",
      "es": "Explosión radial"
    },
    "author": "Coutinho",
    "version": "1.5",
    "description": {
      "pt": "Explosão Permite simular uma explosão radial do elemento selecionado usando um slider.Radial",
      "en": "Explosion: Allows you to simulate a radial explosion of the selected element using a slider. Radial",
      "es": "Explosión: Permite simular una explosión radial del elemento seleccionado mediante un control deslizante. Radial"
    },
    "keywords": {
      "pt": [
        "explosão"
      ],
      "en": [
        "explosion"
      ],
      "es": [
        "explosión"
      ]
    },
    "code": {
      "pt": "require 'sketchup.rb'\r\nrequire 'json'\r\n\r\nmodule ScriptUpComunidade\r\n  module ExplosaoRadialFinal\r\n    extend self\r\n\r\n    IDIOMAS = {\r\n      'pt-BR' => {\r\n        :erro_selecao => \"Selecione apenas um grupo ou componente.\",\r\n        :op_explosao  => \"Explosão Visual\",\r\n        :op_restaurar => \"Restaurar Explosão\",\r\n        :titulo       => \"Explosão Visual Radial\"\r\n      },\r\n      'en-US' => {\r\n        :erro_selecao => \"Select only one group or component.\",\r\n        :op_explosao  => \"Visual Explosion\",\r\n        :op_restaurar => \"Restore Explosion\",\r\n        :titulo       => \"Radial Visual Explosion\"\r\n      },\r\n      'es' => {\r\n        :erro_selecao => \"Seleccione solo un grupo o componente.\",\r\n        :op_explosao  => \"Explosión Visual\",\r\n        :op_restaurar => \"Restaurar Explosión\",\r\n        :titulo       => \"Explosión Visual Radial\"\r\n      }\r\n    }\r\n\r\n    def self.obter_texto(chave)\r\n      locale = Sketchup.get_locale\r\n      lang   = IDIOMAS.key?(locale) ? locale : 'en-US'\r\n      IDIOMAS[lang][chave] || IDIOMAS['en-US'][chave] || chave.to_s\r\n    end\r\n\r\n    def executar\r\n      model = Sketchup.active_model\r\n      selection = model.selection\r\n      unless selection.length == 1 && (selection.first.is_a?(Sketchup::Group) || selection.first.is_a?(Sketchup::ComponentInstance))\r\n        UI.messagebox(obter_texto(:erro_selecao))\r\n        return\r\n      end\r\n\r\n      @root = selection.first\r\n      @root_tr = @root.transformation\r\n      @root_center = @root.bounds.center.transform(@root_tr)\r\n\r\n      @entities_data = []\r\n      collect_descendants(@root, @root_tr)\r\n\r\n      # Calcula centro médio original dos componentes internos\r\n      centros = @entities_data.map { |data| data[:original_center] }\r\n\r\n      avg_x = centros.map(&:x).sum / centros.size\r\n      avg_y = centros.map(&:y).sum / centros.size\r\n      avg_z = centros.map(&:z).sum / centros.size\r\n\r\n      @original_avg_center = Geom::Point3d.new(avg_x, avg_y, avg_z)\r\n\r\n      show_dialog\r\n    end\r\n\r\n    def collect_descendants(parent, parent_tr)\r\n      entities = parent.is_a?(Sketchup::Group) ? parent.entities : parent.definition.entities\r\n\r\n      entities.each do |ent|\r\n        next unless ent.is_a?(Sketchup::Group) || ent.is_a?(Sketchup::ComponentInstance)\r\n\r\n        full_tr = parent_tr * ent.transformation\r\n\r\n        origin_point = ORIGIN.transform(full_tr)\r\n        vector = Geom::Vector3d.new(origin_point - @root_center)\r\n        next if vector.length == 0.0\r\n\r\n        original_center = ent.bounds.center.transform(full_tr)\r\n\r\n        @entities_data << {\r\n          entity: ent,\r\n          original_transform: ent.transformation,\r\n          direction: vector,\r\n          original_center: original_center\r\n        }\r\n\r\n        collect_descendants(ent, full_tr)\r\n      end\r\n    end\r\n\r\n    def apply_explosion(factor)\r\n      model = Sketchup.active_model\r\n      model.start_operation(obter_texto(:op_explosao), true)\r\n      \r\n      exploded_centers = []\r\n      \r\n      @entities_data.each do |data|\r\n        original_direction = data[:direction]\r\n        next unless original_direction.respond_to?(:normalize)\r\n      \r\n        normalized = original_direction.normalize rescue nil\r\n        next unless normalized.is_a?(Geom::Vector3d)\r\n      \r\n        distance = original_direction.length * factor\r\n        move_vector = normalized.clone\r\n        move_vector.length = distance\r\n      \r\n        new_center = data[:original_center].offset(move_vector)\r\n        exploded_centers << new_center\r\n      \r\n        data[:_calculated_move] = move_vector\r\n      end\r\n      \r\n      if exploded_centers.empty?\r\n        model.abort_operation\r\n        return\r\n      end\r\n      \r\n      avg_x = exploded_centers.map(&:x).sum / exploded_centers.size\r\n      avg_y = exploded_centers.map(&:y).sum / exploded_centers.size\r\n      avg_z = exploded_centers.map(&:z).sum / exploded_centers.size\r\n      exploded_center = Geom::Point3d.new(avg_x, avg_y, avg_z)\r\n      \r\n      # Compensação agora é entre o centro visual salvo e o novo centro calculado\r\n      compensation_vector = exploded_center.vector_to(@original_avg_center)\r\n      \r\n      @entities_data.each do |data|\r\n        ent = data[:entity]\r\n        next unless ent.valid?\r\n      \r\n        move_vector = data[:_calculated_move]\r\n        compensated_vector = move_vector + compensation_vector\r\n      \r\n        ent.transformation = data[:original_transform] * Geom::Transformation.translation(compensated_vector)\r\n      end\r\n      \r\n      model.commit_operation\r\n    end\r\n\r\n    def restore_positions\r\n      model = Sketchup.active_model\r\n      model.start_operation(obter_texto(:op_restaurar), true)\r\n\r\n      @entities_data.each do |data|\r\n        ent = data[:entity]\r\n        ent.transformation = data[:original_transform] if ent.valid?\r\n      end\r\n\r\n      model.commit_operation\r\n    end\r\n\r\n    def show_dialog\r\n      html = <<-HTML\r\n        <!DOCTYPE html>\r\n        <html>\r\n        <head>\r\n          <meta charset=\"utf-8\">\r\n          <style>\r\n            body { font-family: sans-serif; padding: 10px; }\r\n            input[type=range] { width: 100%; }\r\n          </style>\r\n        </head>\r\n        <body>\r\n          <h3>#{obter_texto(:titulo)}</h3>\r\n          <input id=\"slider\" type=\"range\" min=\"0\" max=\"100\" value=\"0\">\r\n          <script>\r\n            const slider = document.getElementById('slider');\r\n            slider.addEventListener('input', () => {\r\n              window.sketchup.set_explosion(slider.value);\r\n            });\r\n            window.onbeforeunload = () => {\r\n              window.sketchup.restore_positions();\r\n            };\r\n          </script>\r\n        </body>\r\n        </html>\r\n      HTML\r\n\r\n      @dialog = UI::HtmlDialog.new({\r\n        dialog_title: obter_texto(:titulo),\r\n        width: 300,\r\n        height: 120,\r\n        style: UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n\r\n      @dialog.set_html(html)\r\n      @dialog.add_action_callback(\"set_explosion\") { |_ctx, val| apply_explosion(val.to_f / 100.0) }\r\n      @dialog.add_action_callback(\"restore_positions\") { |_ctx, _| restore_positions }\r\n      @dialog.show\r\n    end\r\n  end\r\nend\r\n\r\nScriptUpComunidade::ExplosaoRadialFinal.executar"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "teletransporte-42ulf",
    "title": {
      "pt": "Teletransporte",
      "en": "Teleportation",
      "es": "Teletransportación"
    },
    "author": "Fábio",
    "version": "1.0",
    "description": {
      "pt": "Permite transportar uma geometria de um lugar para outro.",
      "en": "It allows you to transport a geometry from one place to another.",
      "es": "Permite transportar una geometría de un lugar a otro."
    },
    "keywords": {
      "pt": [
        "cópia"
      ],
      "en": [
        "copy"
      ],
      "es": [
        "copiar"
      ]
    },
    "code": {
      "pt": "module TeletransportadorDeGeometria\r\n  class Tool\r\n    VK_CONTROL ||= 17\r\n    VK_SHIFT ||= 16\r\n\r\n    def initialize\r\n      @step = :select_source\r\n      @mode = :transportar\r\n      @localizacao = :interno\r\n      @source = nil\r\n    end\r\n\r\n    def activate\r\n      Sketchup.status_text = status_message\r\n      Sketchup.active_model.selection.clear\r\n    end\r\n\r\n    def status_message\r\n      acao = @mode == :transportar ? \"Transportar\" : \"Substituir\"\r\n      local = @localizacao == :interno ? \"Interno\" : \"Externo\"\r\n      case @step\r\n      when :select_source\r\n        \"Modo: #{acao} | Localização: #{local} | Clique no item que será transportado.\"\r\n      when :select_target\r\n        \"Modo: #{acao} | Localização: #{local} | Clique no local de destino.\"\r\n      end\r\n    end\r\n\r\n    def onKeyDown(key, repeat, flags, view)\r\n      case key\r\n      when VK_CONTROL\r\n        @mode = (@mode == :transportar ? :substituir : :transportar)\r\n      when VK_SHIFT\r\n        @localizacao = (@localizacao == :interno ? :externo : :interno)\r\n      end\r\n      Sketchup.status_text = status_message\r\n    end\r\n\r\n    def onMouseMove(flags, x, y, view)\r\n      model = Sketchup.active_model\r\n      ph = view.pick_helper\r\n      ph.do_pick(x, y)\r\n      path = ph.path_at(0)\r\n      return model.selection.clear unless path\r\n    \r\n      entity = path.to_a.first\r\n    \r\n      if @step == :select_source\r\n        if entity.is_a?(Sketchup::Group) || entity.is_a?(Sketchup::ComponentInstance)\r\n          model.selection.clear\r\n          model.selection.add(entity)\r\n        else\r\n          model.selection.clear\r\n        end\r\n      else\r\n        entity = path.to_a.reverse.find { |e| e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance) }\r\n        if entity\r\n          model.selection.clear\r\n          model.selection.add(entity)\r\n        else\r\n          model.selection.clear\r\n        end\r\n      end\r\n\r\n      Sketchup.status_text = status_message\r\n    end\r\n\r\n    def onLButtonDown(flags, x, y, view)\r\n      model = Sketchup.active_model\r\n      ph = view.pick_helper\r\n      ph.do_pick(x, y)\r\n      path = ph.path_at(0)\r\n      return unless path\r\n\r\n      path_array = path.to_a\r\n\r\n      if @step == :select_source\r\n        entity = path_array.first\r\n        return unless entity.is_a?(Sketchup::Group) || entity.is_a?(Sketchup::ComponentInstance)\r\n      else\r\n        entity = path_array.reverse.find { |e| e.is_a?(Sketchup::Group) || e.is_a?(Sketchup::ComponentInstance) }\r\n        return unless entity\r\n      end\r\n\r\n      # Garante unicidade\r\n      entity.make_unique if entity.respond_to?(:make_unique)\r\n\r\n      instance_path = Sketchup::InstancePath.new(path_array[0..path_array.index(entity)])\r\n      global_tr = instance_path.transformation\r\n\r\n      if @step == :select_source\r\n        @source = {\r\n          entity: entity,\r\n          definition: entity.definition,\r\n          global_tr: global_tr\r\n        }\r\n        @step = :select_target\r\n        Sketchup.status_text = status_message\r\n      else\r\n        perform_transfer(@source, entity, global_tr, instance_path)\r\n        reset\r\n      end\r\n    end\r\n\r\n    def perform_transfer(source_data, destination, destination_tr, destination_path)\r\n      model = Sketchup.active_model\r\n      model.start_operation(\"Teletransporte\", true)\r\n    \r\n      source_entity = source_data[:entity]\r\n      source_definition = source_data[:definition]\r\n      source_tr = source_data[:global_tr]\r\n    \r\n      if @localizacao == :interno\r\n        dest_entities = destination.definition.entities\r\n        inverse_dest_tr = destination_tr.inverse\r\n        relative_tr = inverse_dest_tr * source_tr\r\n      else\r\n        dest_entities = destination.parent.entities\r\n    \r\n        if destination_path\r\n          parent_path = Sketchup::InstancePath.new(destination_path.to_a[0...-1])\r\n          inverse_parent_path_tr = parent_path.transformation.inverse\r\n          relative_tr = inverse_parent_path_tr * source_tr\r\n        else\r\n          relative_tr = source_tr\r\n        end\r\n      end\r\n    \r\n      new_instance = dest_entities.add_instance(source_definition, relative_tr)\r\n      new_instance.material = source_entity.material if source_entity.material\r\n    \r\n      unless new_instance && new_instance.valid?\r\n        UI.messagebox(\"Erro ao colar instância no destino!\")\r\n        model.abort_operation\r\n        return\r\n      end\r\n    \r\n      if @mode == :substituir\r\n        if @localizacao == :interno\r\n          keep_id = new_instance.entityID\r\n          to_erase = dest_entities.select { |e| e.entityID != keep_id }\r\n          dest_entities.erase_entities(to_erase)\r\n        else\r\n          destination.erase!\r\n        end\r\n      end\r\n    \r\n      source_entity.erase!\r\n    \r\n      model.commit_operation\r\n    end    \r\n\r\n    def reset\r\n      @step = :select_source\r\n      @source = nil\r\n      Sketchup.status_text = status_message\r\n      Sketchup.active_model.selection.clear\r\n    end\r\n\r\n    def deactivate(view)\r\n      Sketchup.status_text = \"\"\r\n      Sketchup.active_model.selection.clear\r\n    end\r\n  end\r\n\r\n  def self.ativar_ferramenta\r\n    Sketchup.active_model.select_tool(Tool.new)\r\n  end\r\nend\r\n\r\nTeletransportadorDeGeometria.ativar_ferramenta"
    },
    "enabled": false,
    "execute": true
  },
  {
    "id": "tour-virtual-679qz",
    "title": {
      "pt": "Tour Virtual",
      "en": "Virtual Tour",
      "es": "Visita virtual"
    },
    "author": "Fábio Coutinho",
    "version": "3.6",
    "description": {
      "pt": "Cria um vídeo da viewport",
      "en": "Create a video of the viewport.",
      "es": "Crea un vídeo de la ventana gráfica."
    },
    "keywords": {
      "pt": [
        "tour"
      ],
      "en": [
        "tour"
      ],
      "es": [
        "recorrido"
      ]
    },
    "code": {
      "pt": "require 'json'\r\nrequire 'sketchup.rb'\r\nrequire 'base64'\r\nrequire 'tmpdir'\r\nrequire 'fiddle/import'\r\nrequire 'fileutils'\r\nrequire 'open3'\r\nrequire 'etc'\r\nrequire 'open-uri'\r\nif Sketchup.platform == :platform_win\r\n  require 'win32ole'\r\nend\r\n\r\n# --- Definições de Diretórios ---\r\nplugins_root = Sketchup.find_support_file(\"Plugins\")\r\nPLUGIN_DIR = if plugins_root\r\n               File.expand_path(File.join(plugins_root, 'ScriptUp'))\r\n             else\r\n               File.expand_path(File.dirname(__FILE__))\r\n             end\r\n\r\n# --- Script de Instalação do FFmpeg (Mantido) ---\r\nFFMPEG_INSTALL_SCRIPT ||= <<~'RUBY'\r\n  require 'sketchup'\r\n  require 'open-uri'\r\n  require 'fileutils'\r\n  require 'tmpdir'\r\n\r\n  URL_WIN ||= 'https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-master-latest-win64-gpl.zip'\r\n  URL_MAC ||= 'https://evermeet.cx/ffmpeg/getrelease/zip'\r\n\r\n  win = Sketchup.platform == :platform_win\r\n  major = Sketchup.version.to_s[/^\\d+/].to_i\r\n  sketchup_year = 2000 + major\r\n\r\n  plugins_dir = Sketchup.find_support_file('Plugins')\r\n  if !plugins_dir || plugins_dir.empty? || !Dir.exist?(plugins_dir)\r\n    if win\r\n      base = ENV['APPDATA'].to_s\r\n      plugins_dir = File.join(base, 'SketchUp', \"SketchUp #{sketchup_year}\", 'SketchUp', 'Plugins')\r\n    else\r\n      plugins_dir = File.expand_path(\"~/Library/Application Support/SketchUp #{sketchup_year}/SketchUp/Plugins\")\r\n    end\r\n  end\r\n\r\n  target_dir = File.join(plugins_dir, 'ScriptUp', 'ffmpeg')\r\n  target_exe = File.join(target_dir, win ? 'ffmpeg.exe' : 'ffmpeg')\r\n  url = win ? URL_WIN : URL_MAC\r\n  default_zip_name = win ? 'ffmpeg-win64-gpl-latest.zip' : 'ffmpeg-macos-release.zip'\r\n\r\n  proceed = true\r\n\r\n  unless plugins_dir && !plugins_dir.empty?\r\n    UI.messagebox(\"Não foi possível resolver a pasta Plugins automaticamente.\")\r\n    proceed = false\r\n  end\r\n\r\n  if proceed\r\n    msg = \"Instalar FFmpeg em:\\n#{target_dir}\\n\\nOrigem:\\n#{url}\\n\\nContinuar?\"\r\n    if UI.messagebox(msg, MB_YESNO) != IDYES\r\n      UI.messagebox('Instalação cancelada.')\r\n      proceed = false\r\n    end\r\n  end\r\n\r\n  if proceed && File.exist?(target_exe)\r\n    overwrite = UI.messagebox(\"Já existe:\\n#{target_exe}\\n\\nDeseja sobrescrever?\", MB_YESNO)\r\n    if overwrite != IDYES\r\n      UI.messagebox('Instalação cancelada.')\r\n      proceed = false\r\n    end\r\n  end\r\n\r\n  if proceed\r\n    Dir.mktmpdir('ffmpeg_dl_') do |tmp|\r\n      zip_path = File.join(tmp, default_zip_name)\r\n      extract_dir = File.join(tmp, 'unzipped')\r\n      begin\r\n        URI.open(url, 'rb') do |io|\r\n          File.open(zip_path, 'wb') { |f| IO.copy_stream(io, f) }\r\n        end\r\n        Dir.mkdir(extract_dir)\r\n        if win\r\n          ps = 'powershell -NoProfile -ExecutionPolicy Bypass -Command'\r\n          cmd = \"#{ps} \\\"Expand-Archive -LiteralPath '#{zip_path}' -DestinationPath '#{extract_dir}' -Force\\\"\"\r\n          ok = system(cmd)\r\n          raise 'Falha no Expand-Archive (PowerShell).' unless ok\r\n        else\r\n          ok = system(\"unzip -o -q '#{zip_path}' -d '#{extract_dir}'\")\r\n          raise 'Falha no unzip (macOS).' unless ok\r\n        end\r\n\r\n        pattern = win ? '**/ffmpeg.exe' : '**/ffmpeg'\r\n        bin = Dir.glob(File.join(extract_dir, pattern)).find { |p| File.file?(p) }\r\n        raise 'Executável ffmpeg não encontrado no pacote baixado.' unless bin\r\n\r\n        FileUtils.mkdir_p(target_dir) unless Dir.exist?(target_dir)\r\n        FileUtils.cp(bin, target_exe)\r\n        unless win\r\n          FileUtils.chmod(0o755, target_exe)\r\n          system(\"xattr -d com.apple.quarantine '#{target_exe}' 2>/dev/null\")\r\n        end\r\n\r\n        UI.messagebox(\"FFmpeg instalado com sucesso em:\\n#{target_exe}\")\r\n        puts \"OK: #{target_exe}\"\r\n      rescue => e\r\n        UI.messagebox(\"Falhou: #{e.message}\\nAbrindo o link no navegador...\")\r\n        UI.openURL(url)\r\n      end\r\n    end\r\n  end\r\nRUBY\r\n\r\n# --- Módulo WindowUtils ---\r\nmodule WindowUtils\r\n  extend Fiddle::Importer\r\n  dlload 'user32.dll' if Sketchup.platform == :platform_win\r\n\r\n  if Sketchup.platform == :platform_win\r\n    typealias 'HWND', 'void*'\r\n    extern 'HWND GetActiveWindow()'\r\n    extern 'HWND GetForegroundWindow()'\r\n    extern 'HWND GetWindow(HWND, int)'\r\n    extern 'int GetWindowRect(HWND, void*)'\r\n    extern 'HWND GetParent(HWND)'\r\n    \r\n    GW_CHILD = 5\r\n    GW_HWNDNEXT = 2\r\n    Rect = struct ['long left', 'long top', 'long right', 'long bottom']\r\n  end\r\n\r\n  def self.get_viewport_rect_deep(view)\r\n    return nil unless Sketchup.platform == :platform_win\r\n    \r\n    hwnd = GetForegroundWindow()\r\n    return nil if hwnd.nil? || hwnd == 0\r\n\r\n    vw = view.vpwidth\r\n    vh = view.vpheight\r\n    \r\n    found = find_recursive(hwnd, vw, vh)\r\n    return found if found\r\n\r\n    parent = GetParent(hwnd)\r\n    if parent && parent != 0\r\n      found = find_recursive(parent, vw, vh)\r\n      return found if found\r\n    end\r\n\r\n    nil\r\n  end\r\n\r\n  def self.find_recursive(parent_hwnd, target_w, target_h)\r\n    child = GetWindow(parent_hwnd, GW_CHILD)\r\n    while child && child.to_i != 0\r\n      rect = Rect.malloc\r\n      if GetWindowRect(child, rect) != 0\r\n        w = rect.right - rect.left\r\n        h = rect.bottom - rect.top\r\n        match = check_match(w, h, target_w, target_h, rect)\r\n        return match if match\r\n      end\r\n      found_in_child = find_recursive(child, target_w, target_h)\r\n      return found_in_child if found_in_child\r\n      child = GetWindow(child, GW_HWNDNEXT)\r\n    end\r\n    nil\r\n  end\r\n\r\n  def self.check_match(w, h, target_w, target_h, rect)\r\n    tol = 30\r\n    [1.0, 1.25, 1.5, 2.0].each do |scale|\r\n      if (w - target_w * scale).abs <= tol && (h - target_h * scale).abs <= tol\r\n        return { :x => rect.left, :y => rect.top, :w => w, :h => h, :scale => scale }\r\n      end\r\n    end\r\n    nil\r\n  end\r\nend\r\n\r\n# --- Módulo ScreenCapture (GDI32) ---\r\n# Captures the SketchUp viewport via Win32 GDI and produces a BMP thumbnail\r\n# encoded as Base64, suitable for embedding in an HTML <img> tag.\r\n#\r\n# Uses Fiddle::Importer (Ruby stdlib) to call gdi32.dll and user32.dll functions.\r\n# Also declares PrintWindow from user32.dll as a fallback for occluded windows.\r\n#\r\n# Fiddle type mapping reference (from fiddle/types.rb Win32Types):\r\n#   HANDLE / HDC / HWND / HBITMAP  ->  void*   (pointer-sized, correct for 32/64-bit)\r\n#   DWORD                          ->  unsigned long\r\n#   BOOL                           ->  int\r\n#   UINT                           ->  unsigned int\r\n#\r\n# The extern signatures below use 'void*' directly for all handle types\r\n# (HDC, HBITMAP, HGDIOBJ) so we do not need to include Fiddle::Win32Types\r\n# or add custom typealiases beyond what WindowUtils already defines.\r\nmodule ScreenCapture\r\n  extend Fiddle::Importer\r\n\r\n  if Sketchup.platform == :platform_win\r\n    dlload 'gdi32.dll', 'user32.dll'\r\n\r\n    # --- user32.dll functions ---\r\n    # HDC GetDC(HWND hWnd)\r\n    #   hWnd=NULL(0) returns DC for entire screen\r\n    extern 'void* GetDC(void*)'\r\n\r\n    # int ReleaseDC(HWND hWnd, HDC hDC)\r\n    extern 'int ReleaseDC(void*, void*)'\r\n\r\n    # BOOL PrintWindow(HWND hwnd, HDC hdcBlt, UINT nFlags)\r\n    #   Asks the window to paint itself into the given DC.\r\n    #   Works even when the window is partially occluded (unlike BitBlt from screen DC).\r\n    extern 'int PrintWindow(void*, void*, unsigned int)'\r\n\r\n    # --- gdi32.dll functions ---\r\n    # HDC CreateCompatibleDC(HDC hdc)\r\n    extern 'void* CreateCompatibleDC(void*)'\r\n\r\n    # HBITMAP CreateCompatibleBitmap(HDC hdc, int cx, int cy)\r\n    extern 'void* CreateCompatibleBitmap(void*, int, int)'\r\n\r\n    # HGDIOBJ SelectObject(HDC hdc, HGDIOBJ h)\r\n    extern 'void* SelectObject(void*, void*)'\r\n\r\n    # BOOL BitBlt(HDC hdc, int x, int y, int cx, int cy,\r\n    #             HDC hdcSrc, int x1, int y1, DWORD rop)\r\n    extern 'int BitBlt(void*, int, int, int, int, void*, int, int, unsigned long)'\r\n\r\n    # BOOL StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest,\r\n    #                 HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop)\r\n    extern 'int StretchBlt(void*, int, int, int, int, void*, int, int, int, int, unsigned long)'\r\n\r\n    # int SetStretchBltMode(HDC hdc, int mode)\r\n    extern 'int SetStretchBltMode(void*, int)'\r\n\r\n    # int GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines,\r\n    #               LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage)\r\n    #   lpvBits and lpbmi are both void* (raw pointers to caller-allocated buffers)\r\n    extern 'int GetDIBits(void*, void*, unsigned int, unsigned int, void*, void*, unsigned int)'\r\n\r\n    # BOOL DeleteDC(HDC hdc)\r\n    extern 'int DeleteDC(void*)'\r\n\r\n    # BOOL DeleteObject(HGDIOBJ ho)\r\n    extern 'int DeleteObject(void*)'\r\n\r\n    # --- Raster-operation and mode constants ---\r\n    SRCCOPY        = 0x00CC0020\r\n    HALFTONE       = 4          # SetStretchBltMode mode for high-quality shrinking\r\n    DIB_RGB_COLORS = 0          # GetDIBits color table usage\r\n\r\n    # --- PrintWindow flags ---\r\n    PW_CLIENTONLY          = 0x00000001  # capture client area only (no title bar)\r\n    PW_RENDERFULLCONTENT   = 0x00000002  # Win 8.1+: captures DirectX/DWM content\r\n  end\r\n\r\n  # Build a 40-byte BITMAPINFOHEADER as a packed binary string.\r\n  #\r\n  # The BITMAPINFOHEADER struct layout (40 bytes total):\r\n  #   DWORD  biSize          (4 bytes, unsigned 32-bit LE)   = 40\r\n  #   LONG   biWidth         (4 bytes, signed   32-bit LE)\r\n  #   LONG   biHeight        (4 bytes, signed   32-bit LE)   negative = top-down DIB\r\n  #   WORD   biPlanes        (2 bytes, unsigned 16-bit LE)   = 1\r\n  #   WORD   biBitCount      (2 bytes, unsigned 16-bit LE)   = 24 for RGB\r\n  #   DWORD  biCompression   (4 bytes, unsigned 32-bit LE)   = 0 (BI_RGB)\r\n  #   DWORD  biSizeImage     (4 bytes, unsigned 32-bit LE)\r\n  #   LONG   biXPelsPerMeter (4 bytes, signed   32-bit LE)   = 0\r\n  #   LONG   biYPelsPerMeter (4 bytes, signed   32-bit LE)   = 0\r\n  #   DWORD  biClrUsed       (4 bytes, unsigned 32-bit LE)   = 0\r\n  #   DWORD  biClrImportant  (4 bytes, unsigned 32-bit LE)   = 0\r\n  #\r\n  # Pack template: 'L<' = uint32 LE, 'l<' = int32 LE, 'S<' = uint16 LE\r\n  # Combined: 'L< l< l< S< S< L< L< l< l< L< L<'  (spaces for clarity)\r\n  #\r\n  # Using negative biHeight produces a top-down DIB, which means:\r\n  #  - Row 0 in memory is the top row of the image\r\n  #  - No vertical flip is needed when writing the BMP file\r\n  #  - The BMP file header must also use the negative height to match\r\n  def self.pack_bitmapinfoheader(width, height, image_size)\r\n    [\r\n      40,           # biSize\r\n      width,        # biWidth\r\n      -height,      # biHeight (negative = top-down)\r\n      1,            # biPlanes\r\n      24,           # biBitCount (24-bit RGB)\r\n      0,            # biCompression (BI_RGB = uncompressed)\r\n      image_size,   # biSizeImage\r\n      0,            # biXPelsPerMeter\r\n      0,            # biYPelsPerMeter\r\n      0,            # biClrUsed\r\n      0             # biClrImportant\r\n    ].pack('L<l<l<S<S<L<L<l<l<L<L<')\r\n  end\r\n\r\n  # Build the 14-byte BMP file header (BITMAPFILEHEADER).\r\n  #\r\n  # Layout:\r\n  #   WORD   bfType      = 0x4D42 (\"BM\")\r\n  #   DWORD  bfSize      = total file size in bytes\r\n  #   WORD   bfReserved1 = 0\r\n  #   WORD   bfReserved2 = 0\r\n  #   DWORD  bfOffBits   = offset to pixel data = 14 + 40 = 54\r\n  #\r\n  # Pack template: 'S< L< S< S< L<'\r\n  def self.pack_bmp_file_header(pixel_data_size)\r\n    file_size = 14 + 40 + pixel_data_size\r\n    [\r\n      0x4D42,       # bfType (\"BM\")\r\n      file_size,    # bfSize\r\n      0,            # bfReserved1\r\n      0,            # bfReserved2\r\n      54            # bfOffBits (14-byte file header + 40-byte info header)\r\n    ].pack('S<L<S<S<L<')\r\n  end\r\n\r\n  # Capture the SketchUp viewport as a scaled-down BMP thumbnail and return\r\n  # a Base64-encoded string. Returns nil on failure (non-Windows, HWND not found, etc.).\r\n  #\r\n  # Strategy:\r\n  #   1. StretchBlt from screen DC (fast, works when viewport is visible)\r\n  #   2. If vp[:hwnd] is available, PrintWindow can be used as alternative\r\n  #\r\n  # Parameters:\r\n  #   view     - Sketchup::View instance\r\n  #   thumb_w  - desired thumbnail width  in pixels (default 96)\r\n  #   thumb_h  - desired thumbnail height in pixels (default 60)\r\n  #\r\n  # Returns: Base64-encoded BMP string, or nil on failure.\r\n  def self.capture_viewport(view, thumb_w = 96, thumb_h = 60)\r\n    return nil unless Sketchup.platform == :platform_win\r\n\r\n    vp = WindowUtils.get_viewport_rect_deep(view)\r\n    return nil unless vp\r\n\r\n    src_w = vp[:w]\r\n    src_h = vp[:h]\r\n\r\n    # Get screen DC -- needed for CreateCompatibleBitmap color depth\r\n    screen_dc = GetDC(0)\r\n    return nil if screen_dc.nil? || screen_dc.to_i == 0\r\n\r\n    begin\r\n      # Create a memory DC compatible with the screen\r\n      mem_dc = CreateCompatibleDC(screen_dc)\r\n      return nil if mem_dc.nil? || mem_dc.to_i == 0\r\n\r\n      begin\r\n        # Create a bitmap at the desired thumbnail size\r\n        bmp = CreateCompatibleBitmap(screen_dc, thumb_w, thumb_h)\r\n        return nil if bmp.nil? || bmp.to_i == 0\r\n\r\n        begin\r\n          old = SelectObject(mem_dc, bmp)\r\n          SetStretchBltMode(mem_dc, HALFTONE)\r\n\r\n          # StretchBlt from the screen DC directly into the thumbnail-sized bitmap.\r\n          # This both captures AND scales in a single operation.\r\n          ok = StretchBlt(\r\n            mem_dc, 0, 0, thumb_w, thumb_h,\r\n            screen_dc, vp[:x], vp[:y], src_w, src_h,\r\n            SRCCOPY\r\n          )\r\n          return nil if ok == 0\r\n\r\n          # IMPORTANT: Deselect the bitmap from the DC before calling GetDIBits.\r\n          # Per MSDN: \"The bitmap identified by hbmp must not be selected into\r\n          # a device context when the application calls this function.\"\r\n          SelectObject(mem_dc, old)\r\n          old = nil\r\n\r\n          # Calculate row stride (BMP rows must be padded to 4-byte boundaries)\r\n          stride     = ((thumb_w * 3 + 3) & ~3)\r\n          pixel_size = stride * thumb_h\r\n\r\n          # Pack the BITMAPINFOHEADER into a Fiddle::Pointer buffer.\r\n          # GetDIBits may modify the header (e.g., filling in biSizeImage),\r\n          # so we use a mutable native buffer rather than a Ruby String.\r\n          bmi_bytes = pack_bitmapinfoheader(thumb_w, thumb_h, pixel_size)\r\n          bmi_ptr   = Fiddle::Pointer.malloc(bmi_bytes.bytesize)\r\n          bmi_ptr[0, bmi_bytes.bytesize] = bmi_bytes\r\n\r\n          # Allocate the pixel data buffer\r\n          buf = Fiddle::Pointer.malloc(pixel_size)\r\n\r\n          begin\r\n            # GetDIBits(hdc, hbm, start, cLines, lpvBits, lpbmi, usage)\r\n            # hdc: a DC compatible with the bitmap (mem_dc works)\r\n            # hbm: the bitmap handle (NOT selected into any DC)\r\n            rows = GetDIBits(mem_dc, bmp, 0, thumb_h, buf, bmi_ptr, DIB_RGB_COLORS)\r\n            return nil if rows == 0\r\n\r\n            # Read the raw pixel bytes from the Fiddle::Pointer buffer.\r\n            # ptr[offset, length] returns a Ruby String (binary safe, works since Ruby 2.0).\r\n            pixel_data = buf[0, pixel_size]\r\n\r\n            # Assemble the complete BMP file: file header + info header + pixel data\r\n            file_hdr = pack_bmp_file_header(pixel_size)\r\n            info_hdr = pack_bitmapinfoheader(thumb_w, thumb_h, pixel_size)\r\n\r\n            Base64.strict_encode64(file_hdr + info_hdr + pixel_data)\r\n          ensure\r\n            Fiddle.free(bmi_ptr) if bmi_ptr\r\n            Fiddle.free(buf)     if buf\r\n          end\r\n        ensure\r\n          SelectObject(mem_dc, old) if old\r\n          DeleteObject(bmp)\r\n        end\r\n      ensure\r\n        DeleteDC(mem_dc)\r\n      end\r\n    ensure\r\n      ReleaseDC(0, screen_dc)\r\n    end\r\n  rescue => e\r\n    puts \"ScreenCapture error: #{e.message}\"\r\n    puts e.backtrace.first(5).join(\"\\n\")\r\n    nil\r\n  end\r\nend\r\n\r\nmodule TourPlugin\r\n  class AreaSelectorTool\r\n    def initialize(callback)\r\n      @callback = callback\r\n      @start_x = nil; @start_y = nil; @current_x = nil; @current_y = nil\r\n      @drawing = false\r\n    end\r\n\r\n    def activate\r\n      Sketchup.active_model.active_view.invalidate\r\n      Sketchup.status_text = \"CLIQUE E ARRASTE para definir a área de gravação do vídeo.\"\r\n    end\r\n\r\n    def onLButtonDown(flags, x, y, view)\r\n      @start_x = x; @start_y = y; @current_x = x; @current_y = y\r\n      @drawing = true\r\n    end\r\n\r\n    def onMouseMove(flags, x, y, view)\r\n      if @drawing\r\n        @current_x = x; @current_y = y\r\n        view.invalidate\r\n      end\r\n    end\r\n\r\n    def onLButtonUp(flags, x, y, view)\r\n      return unless @drawing\r\n      @drawing = false\r\n      x1 = [@start_x, @current_x].min\r\n      y1 = [@start_y, @current_y].min\r\n      x2 = [@start_x, @current_x].max\r\n      y2 = [@start_y, @current_y].max\r\n      width = x2 - x1\r\n      height = y2 - y1\r\n\r\n      if width < 50 || height < 50\r\n        UI.messagebox(\"Área muito pequena. Tente novamente.\")\r\n        Sketchup.active_model.select_tool(nil)\r\n        return\r\n      end\r\n\r\n      @callback.call({ :x => x1, :y => y1, :w => width, :h => height })\r\n      Sketchup.active_model.select_tool(nil) \r\n    end\r\n\r\n    def draw(view)\r\n      return unless @drawing && @start_x && @current_x\r\n      points = [\r\n        Geom::Point3d.new(@start_x, @start_y, 0),\r\n        Geom::Point3d.new(@current_x, @start_y, 0),\r\n        Geom::Point3d.new(@current_x, @current_y, 0),\r\n        Geom::Point3d.new(@start_x, @current_y, 0)\r\n      ]\r\n      view.line_width = 3\r\n      view.drawing_color = 'red'\r\n      view.draw2d(GL_LINE_LOOP, points)\r\n    end\r\n  end\r\n\r\n  class ExportPreviewTool\r\n    def initialize(target_w, target_h)\r\n      @target_w = target_w\r\n      @target_h = target_h\r\n    end\r\n\r\n    def activate\r\n      Sketchup.active_model.active_view.invalidate\r\n    end\r\n\r\n    def deactivate(view)\r\n      view.invalidate\r\n    end\r\n\r\n    def draw(view)\r\n      vw = view.vpwidth\r\n      vh = view.vpheight\r\n      ew = [@target_w, vw].min\r\n      eh = [@target_h, vh].min\r\n      ox = (vw - ew) / 2\r\n      oy = (vh - eh) / 2\r\n\r\n      # Escurecer áreas fora da gravação (letterbox/pillarbox)\r\n      view.drawing_color = Sketchup::Color.new(0, 0, 0, 120)\r\n      if oy > 0\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(0, 0, 0), Geom::Point3d.new(vw, 0, 0),\r\n          Geom::Point3d.new(vw, oy, 0), Geom::Point3d.new(0, oy, 0)\r\n        ])\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(0, oy + eh, 0), Geom::Point3d.new(vw, oy + eh, 0),\r\n          Geom::Point3d.new(vw, vh, 0), Geom::Point3d.new(0, vh, 0)\r\n        ])\r\n      end\r\n      if ox > 0\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(0, oy, 0), Geom::Point3d.new(ox, oy, 0),\r\n          Geom::Point3d.new(ox, oy + eh, 0), Geom::Point3d.new(0, oy + eh, 0)\r\n        ])\r\n        view.draw2d(GL_QUADS, [\r\n          Geom::Point3d.new(ox + ew, oy, 0), Geom::Point3d.new(vw, oy, 0),\r\n          Geom::Point3d.new(vw, oy + eh, 0), Geom::Point3d.new(ox + ew, oy + eh, 0)\r\n        ])\r\n      end\r\n\r\n      # Borda branca ao redor da área de gravação\r\n      view.line_width = 2\r\n      view.drawing_color = Sketchup::Color.new(255, 255, 255, 200)\r\n      view.draw2d(GL_LINE_LOOP, [\r\n        Geom::Point3d.new(ox, oy, 0), Geom::Point3d.new(ox + ew, oy, 0),\r\n        Geom::Point3d.new(ox + ew, oy + eh, 0), Geom::Point3d.new(ox, oy + eh, 0)\r\n      ])\r\n    end\r\n  end\r\n\r\n  module CameraTimeline\r\n    module GlobalKey\r\n      extend Fiddle::Importer\r\n      if Sketchup.platform == :platform_win\r\n        dlload 'user32.dll'\r\n        extern 'short GetAsyncKeyState(int)'\r\n      else\r\n        dlload '/System/Library/Frameworks/ApplicationServices.framework/ApplicationServices'\r\n        extern 'bool CGEventSourceKeyState(int, int)'\r\n      end\r\n\r\n      DEFAULT_HOTKEY = Sketchup.platform == :platform_win ? 0x6B : 69\r\n      @key_code = Sketchup.read_default(\"TourVirtual\", \"Hotkey\", DEFAULT_HOTKEY).to_i\r\n      @ctrl = Sketchup.read_default(\"TourVirtual\", \"HotkeyCtrl\", false)\r\n      @alt = Sketchup.read_default(\"TourVirtual\", \"HotkeyAlt\", false)\r\n      @shift = Sketchup.read_default(\"TourVirtual\", \"HotkeyShift\", false)\r\n\r\n      # Windows virtual key codes for modifiers\r\n      VK_CONTROL = 0x11\r\n      VK_MENU    = 0x12\r\n      VK_SHIFT   = 0x10\r\n      # macOS key codes for modifiers\r\n      MAC_CTRL  = 59\r\n      MAC_SHIFT = 56\r\n      MAC_ALT   = 58\r\n\r\n      def self.set_hotkey(code, ctrl, alt, shift)\r\n        @key_code = code.to_i\r\n        @ctrl = ctrl\r\n        @alt = alt\r\n        @shift = shift\r\n      end\r\n\r\n      def self.key_code; @key_code; end\r\n      def self.ctrl; @ctrl; end\r\n      def self.alt; @alt; end\r\n      def self.shift; @shift; end\r\n\r\n      def self.key_pressed?(code)\r\n        if Sketchup.platform == :platform_win\r\n          GetAsyncKeyState(code) & 0x8000 != 0\r\n        else\r\n          CGEventSourceKeyState(0, code)\r\n        end\r\n      end\r\n\r\n      def self.space_pressed?\r\n        return false unless key_pressed?(@key_code)\r\n        if Sketchup.platform == :platform_win\r\n          return false if @ctrl && !key_pressed?(VK_CONTROL)\r\n          return false if @alt && !key_pressed?(VK_MENU)\r\n          return false if @shift && !key_pressed?(VK_SHIFT)\r\n        else\r\n          return false if @ctrl && !key_pressed?(MAC_CTRL)\r\n          return false if @alt && !key_pressed?(MAC_ALT)\r\n          return false if @shift && !key_pressed?(MAC_SHIFT)\r\n        end\r\n        true\r\n      end\r\n    end\r\n\r\n    def self.start_space_timer\r\n      return if defined?(@space_timer) && @space_timer\r\n      @space_down = false\r\n      @space_timer = UI.start_timer(0.1, true) do\r\n        if GlobalKey.space_pressed?\r\n          unless @space_down\r\n            @space_down = true\r\n            @dialog.execute_script('triggerSpaceFromRuby()')\r\n          end\r\n        else\r\n          @space_down = false\r\n        end\r\n      end\r\n    end\r\n\r\n    def self.stop_space_timer\r\n      if defined?(@space_timer) && @space_timer\r\n        UI.stop_timer(@space_timer)\r\n        @space_timer = nil\r\n      end\r\n    end\r\n\r\n    def self.capture_thumbnail\r\n      view = Sketchup.active_model.active_view\r\n      # Tentar screen capture instantâneo via GDI32 (Windows)\r\n      result = ScreenCapture.capture_viewport(view, 96, 60) rescue nil\r\n      return result if result && result.length > 0\r\n      # Fallback: write_image (lento, mas funciona em qualquer plataforma)\r\n      path = File.join(Dir.tmpdir, \"thumb_#{Time.now.to_i}.jpg\")\r\n      view.write_image(path, 96, 60, false, 0.5)\r\n      encoded = Base64.strict_encode64(File.binread(path))\r\n      File.delete(path) if File.exist?(path)\r\n      encoded\r\n    end\r\n\r\n    # --- Lógica de Exportação ---\r\n    def self.calcular_rect_gravacao(export_width, export_height)\r\n      view = Sketchup.active_model.active_view\r\n      viewport_global = WindowUtils.get_viewport_rect_deep(view)\r\n\r\n      unless viewport_global\r\n        viewport_global = { :x => 0, :y => 0, :w => view.vpwidth, :h => view.vpheight, :scale => 1.0 }\r\n      end\r\n\r\n      vp_w = viewport_global[:w]\r\n      vp_h = viewport_global[:h]\r\n\r\n      final_w = [export_width.to_i, vp_w].min\r\n      final_h = [export_height.to_i, vp_h].min\r\n\r\n      offset_x = viewport_global[:x] + ((vp_w - final_w) / 2).to_i\r\n      offset_y = viewport_global[:y] + ((vp_h - final_h) / 2).to_i\r\n\r\n      final_w -= 1 if final_w.odd?\r\n      final_h -= 1 if final_h.odd?\r\n\r\n      { :x => offset_x, :y => offset_y, :w => final_w, :h => final_h }\r\n    end\r\n\r\n    def self.iniciar_processo_exportacao(json_data, use_easing, start_index_from_js, export_width, export_height, filename)\r\n      effective_index = start_index_from_js.to_i\r\n\r\n      if effective_index == 0\r\n        @dialog.execute_script(\"currentIndex = 0; updateTime(0); sketchup.goto_camera(JSON.stringify(visoes[0]));\")\r\n        sleep(0.5)\r\n      end\r\n\r\n      rect = calcular_rect_gravacao(export_width, export_height)\r\n      executar_gravacao_ffmpeg(json_data, use_easing, rect, effective_index, filename)\r\n    end\r\n\r\n    def self.iniciar_processo_exportacao_projeto(all_timelines_json, use_easing, active_tl_index, start_vision_index, export_width, export_height, filename)\r\n      timelines = JSON.parse(all_timelines_json, symbolize_names: true)\r\n      rect = calcular_rect_gravacao(export_width, export_height)\r\n\r\n      start_tl = active_tl_index.to_i\r\n      start_vision = start_vision_index.to_i\r\n\r\n      # Calcular duração total a partir do ponto de início\r\n      total_time = 0.0\r\n      timelines.each_with_index do |tl, i|\r\n        next if i < start_tl\r\n        next unless tl[:visoes] && tl[:visoes].length >= 2\r\n        sorted = tl[:visoes].sort_by { |v| v[:time] }\r\n        first_v = (i == start_tl && start_vision > 0 && start_vision < sorted.length) ? start_vision : 0\r\n        if first_v < sorted.length - 1\r\n          total_time += sorted.last[:time] - sorted[first_v][:time]\r\n          total_time += 0.5\r\n        end\r\n      end\r\n\r\n      play_cmd = \"startRecordingPlayAll(#{start_tl}, #{start_vision})\"\r\n      executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, play_cmd)\r\n    end\r\n\r\n    def self.executar_gravacao_ffmpeg(json_data, use_easing, rect, start_index, filename)\r\n      camera_keys = JSON.parse(json_data, symbolize_names: true)\r\n      camera_keys.sort_by! { |v| v[:time] }\r\n\r\n      total_time = 0\r\n      if start_index < camera_keys.length - 1\r\n        relevant_keys = camera_keys[start_index..-1]\r\n        relevant_keys.each_cons(2) { |c, n| total_time += (n[:time] - c[:time]).abs }\r\n      end\r\n\r\n      executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, \"triggerSpaceFromRuby()\")\r\n    end\r\n\r\n    def self.executar_gravacao_ffmpeg_with_duration(total_time, use_easing, rect, filename, play_command)\r\n      folder = UI.select_directory(title: \"Selecione a pasta para salvar\")\r\n      return unless folder\r\n\r\n      output_path = File.join(folder, \"#{filename}.mp4\")\r\n\r\n      is_win = Sketchup.platform == :platform_win\r\n      ffmpeg_path = File.join(PLUGIN_DIR, 'ffmpeg', is_win ? 'ffmpeg.exe' : 'ffmpeg')\r\n\r\n      unless File.exist?(ffmpeg_path)\r\n        UI.messagebox(\"FFmpeg não encontrado.\")\r\n        return\r\n      end\r\n\r\n      duration_padding = 4.0\r\n      recording_duration = total_time + duration_padding\r\n\r\n      input_format = is_win ? 'gdigrab' : 'avfoundation'\r\n      input_source = is_win ? 'desktop' : '1:none'\r\n\r\n      cmd_array = [\r\n        \"\\\"#{ffmpeg_path}\\\"\",\r\n        '-y',\r\n        '-f', input_format,\r\n        '-framerate', '30',\r\n        '-t', recording_duration.to_s\r\n      ]\r\n\r\n      if is_win\r\n        cmd_array.concat([\r\n          '-draw_mouse', '0',\r\n          '-offset_x', rect[:x].to_s,\r\n          '-offset_y', rect[:y].to_s,\r\n          '-video_size', \"#{rect[:w]}x#{rect[:h]}\",\r\n          '-i', input_source\r\n        ])\r\n      else\r\n        cmd_array.concat([\r\n          '-i', input_source,\r\n          '-vf', \"crop=#{rect[:w]}:#{rect[:h]}:#{rect[:x]}:#{rect[:y]}\"\r\n        ])\r\n      end\r\n\r\n      cmd_array.concat([\r\n        '-c:v', 'libx264',\r\n        '-preset', 'ultrafast',\r\n        '-pix_fmt', 'yuv420p',\r\n        \"\\\"#{output_path}\\\"\"\r\n      ])\r\n\r\n      cmd = cmd_array.join(' ')\r\n\r\n      begin\r\n        if is_win\r\n           WIN32OLE.new('WScript.Shell').Run(cmd, 0, false)\r\n        else\r\n           pid = spawn(cmd)\r\n           Process.detach(pid)\r\n        end\r\n      rescue => e\r\n        UI.messagebox(\"Erro ao iniciar gravador: #{e.message}\")\r\n        return\r\n      end\r\n\r\n      sleep(1.5)\r\n\r\n      @dialog.execute_script(\"showRecordingIndicator()\")\r\n      @dialog.execute_script(play_command)\r\n\r\n      UI.start_timer(recording_duration + 1.0, false) do\r\n        @dialog.execute_script(\"hideRecordingIndicator()\")\r\n        UI.messagebox(\"Gravação finalizada!\\nSalvo em: #{output_path}\")\r\n        @dialog.execute_script(\"resetPlayButton(); resetPlayAll();\")\r\n      end\r\n    end\r\n\r\n    def self.start_ui\r\n      current_hotkey = GlobalKey.key_code\r\n      hotkey_ctrl = GlobalKey.ctrl ? 'true' : 'false'\r\n      hotkey_alt = GlobalKey.alt ? 'true' : 'false'\r\n      hotkey_shift = GlobalKey.shift ? 'true' : 'false'\r\n      ffmpeg_path = File.join(PLUGIN_DIR, 'ffmpeg', Sketchup.platform == :platform_win ? 'ffmpeg.exe' : 'ffmpeg')\r\n      \r\n      has_ffmpeg = File.exist?(ffmpeg_path)\r\n\r\n      view = Sketchup.active_model.active_view\r\n      vp_width = view.vpwidth\r\n      vp_height = view.vpheight\r\n\r\n      html = <<-HTML\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n  <meta charset=\"utf-8\">\r\n  <title>Tour Virtual</title>\r\n  <style>\r\n    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }\r\n    body {\r\n      font-family: system-ui, -apple-system, 'Segoe UI', sans-serif;\r\n      background: #f5f5f5; color: #333; font-size: 13px;\r\n      padding: 16px; line-height: 1.4;\r\n    }\r\n\r\n    /* Header */\r\n    .header {\r\n      display: flex; align-items: center; gap: 10px;\r\n      padding-bottom: 14px; border-bottom: 2px solid #0066cc;\r\n      margin-bottom: 16px;\r\n    }\r\n    .header svg { flex-shrink: 0; }\r\n    .header h1 { font-size: 17px; font-weight: 700; color: #1a1a1a; }\r\n    .header .subtitle { font-size: 11px; color: #888; font-weight: 400; }\r\n\r\n    /* Cards */\r\n    .card {\r\n      background: #fff; border: 1px solid #e0e0e0; border-radius: 8px;\r\n      box-shadow: 0 1px 3px rgba(0,0,0,0.06); margin-bottom: 12px;\r\n      overflow: hidden;\r\n    }\r\n    .card-header {\r\n      display: flex; align-items: center; justify-content: space-between;\r\n      padding: 10px 14px; background: #fafafa; border-bottom: 1px solid #eee;\r\n      cursor: pointer; user-select: none;\r\n    }\r\n    .card-header h2 { font-size: 13px; font-weight: 600; color: #444; }\r\n    .card-header .toggle-icon { font-size: 11px; color: #999; transition: transform 0.2s; }\r\n    .card-header.collapsed .toggle-icon { transform: rotate(-90deg); }\r\n    .card-body { padding: 14px; }\r\n    .card-body.collapsed { display: none; }\r\n\r\n    /* Timeline */\r\n    .timeline-wrapper { position: relative; padding: 8px 0 20px; }\r\n    .timeline-track {\r\n      position: absolute; top: 20px; left: 6px; right: 6px; height: 4px;\r\n      background: #ddd; border-radius: 2px; z-index: 0;\r\n    }\r\n    #timeline_range {\r\n      -webkit-appearance: none; appearance: none; width: 100%;\r\n      height: 6px; background: transparent; outline: none;\r\n      position: relative; z-index: 2; cursor: pointer;\r\n    }\r\n    #timeline_range::-webkit-slider-runnable-track {\r\n      height: 6px; background: linear-gradient(90deg, #0066cc 0%, #4da6ff 100%);\r\n      border-radius: 3px;\r\n    }\r\n    #timeline_range::-webkit-slider-thumb {\r\n      -webkit-appearance: none; width: 16px; height: 16px;\r\n      background: #0066cc; border: 2px solid #fff; border-radius: 50%;\r\n      margin-top: -5px; cursor: grab; box-shadow: 0 1px 4px rgba(0,0,0,0.2);\r\n    }\r\n    #timeline_range::-webkit-slider-thumb:active { cursor: grabbing; transform: scale(1.15); }\r\n    #markers_layer {\r\n      position: absolute; top: 0; left: 0; width: 100%; height: 40px;\r\n      pointer-events: none; z-index: 3;\r\n    }\r\n    .marker {\r\n      position: absolute; top: 26px; width: 14px; height: 14px;\r\n      background: #0066cc; border-radius: 50%; border: 2px solid #fff;\r\n      transform: translateX(-50%); pointer-events: auto; cursor: pointer;\r\n      box-shadow: 0 1px 3px rgba(0,0,0,0.15); transition: transform 0.15s, background 0.15s;\r\n    }\r\n    .marker:hover { transform: translateX(-50%) scale(1.25); }\r\n    .marker.anchor { background: #dc3545; }\r\n    .marker .marker-tooltip {\r\n      position: absolute; bottom: 18px; left: 50%; transform: translateX(-50%);\r\n      background: #333; color: #fff; font-size: 10px; padding: 2px 6px;\r\n      border-radius: 3px; white-space: nowrap; opacity: 0;\r\n      pointer-events: none; transition: opacity 0.15s;\r\n    }\r\n    .marker:hover .marker-tooltip { opacity: 1; }\r\n    .time-row {\r\n      display: flex; align-items: center; justify-content: space-between;\r\n      margin-top: 8px; gap: 12px;\r\n    }\r\n    .time-display { font-size: 20px; font-weight: 700; color: #0066cc; font-variant-numeric: tabular-nums; }\r\n    .time-display small { font-size: 12px; color: #888; font-weight: 400; }\r\n    .time-input-group { display: flex; align-items: center; gap: 6px; }\r\n    .time-input-group label { font-size: 11px; color: #666; }\r\n\r\n    /* Buttons */\r\n    .btn {\r\n      display: inline-flex; align-items: center; justify-content: center; gap: 6px;\r\n      padding: 7px 14px; border: 1px solid transparent; border-radius: 6px;\r\n      font-size: 12px; font-weight: 500; cursor: pointer;\r\n      transition: all 0.15s; outline: none; font-family: inherit;\r\n    }\r\n    .btn:active { transform: scale(0.97); }\r\n    .btn-primary { background: #0066cc; color: #fff; }\r\n    .btn-primary:hover { background: #0052a3; }\r\n    .btn-success { background: #28a745; color: #fff; }\r\n    .btn-success:hover { background: #218838; }\r\n    .btn-danger { background: #dc3545; color: #fff; }\r\n    .btn-danger:hover { background: #c82333; }\r\n    .btn-outline { background: transparent; border: 1px solid #ccc; color: #555; }\r\n    .btn-outline:hover { background: #f0f0f0; border-color: #aaa; }\r\n    .btn-sm { padding: 4px 10px; font-size: 11px; }\r\n    .btn-record { background: #dc3545; color: #fff; padding: 10px 20px; font-size: 13px; font-weight: 600; }\r\n    .btn-record:hover { background: #c82333; }\r\n    .btn-record:disabled { background: #ccc; color: #888; cursor: not-allowed; }\r\n\r\n    .btn-group { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }\r\n\r\n    /* Checkboxes */\r\n    .check-group { display: flex; align-items: center; gap: 16px; margin-top: 10px; }\r\n    .check-item { display: flex; align-items: center; gap: 5px; }\r\n    .check-item input[type=\"checkbox\"] {\r\n      width: 15px; height: 15px; accent-color: #0066cc; cursor: pointer;\r\n    }\r\n    .check-item label { font-size: 12px; color: #555; cursor: pointer; }\r\n\r\n    /* Hotkey */\r\n    .hotkey-editor {\r\n      display: none; align-items: center; gap: 6px;\r\n      background: #f9f9f9; padding: 6px 10px; border-radius: 6px; border: 1px solid #ddd;\r\n    }\r\n    .hotkey-editor.visible { display: inline-flex; }\r\n    .hotkey-editor input {\r\n      width: 100px; padding: 4px 8px; border: 1px solid #ccc;\r\n      border-radius: 4px; font-size: 12px; font-family: monospace;\r\n      outline: none;\r\n    }\r\n    .hotkey-editor input:focus { border-color: #0066cc; }\r\n\r\n    /* Vision List */\r\n    .vision-list { max-height: 350px; overflow-y: auto; }\r\n    .vision-list::-webkit-scrollbar { width: 6px; }\r\n    .vision-list::-webkit-scrollbar-track { background: #f0f0f0; border-radius: 3px; }\r\n    .vision-list::-webkit-scrollbar-thumb { background: #ccc; border-radius: 3px; }\r\n    .vision-list::-webkit-scrollbar-thumb:hover { background: #aaa; }\r\n    .vision-item {\r\n      display: flex; align-items: center; gap: 10px; padding: 8px 10px;\r\n      border-bottom: 1px solid #f0f0f0; cursor: pointer;\r\n      transition: background 0.12s;\r\n    }\r\n    .vision-item:hover { background: #f7faff; }\r\n    .vision-item:last-child { border-bottom: none; }\r\n    .vision-item .vision-num {\r\n      font-size: 11px; font-weight: 700; color: #999; width: 20px;\r\n      text-align: center; flex-shrink: 0;\r\n    }\r\n    .vision-item img {\r\n      width: 72px; height: 45px; object-fit: cover; border-radius: 4px;\r\n      border: 1px solid #ddd; flex-shrink: 0;\r\n    }\r\n    .vision-item img.thumb-placeholder {\r\n      background: linear-gradient(135deg, #e0e0e0 0%, #c0c0c0 100%);\r\n      animation: pulse-placeholder 1s ease-in-out infinite alternate;\r\n    }\r\n    @keyframes pulse-placeholder {\r\n      from { opacity: 0.6; }\r\n      to { opacity: 1.0; }\r\n    }\r\n    .vision-item .vision-info { flex: 1; min-width: 0; }\r\n    .vision-item .vision-time-input {\r\n      width: 58px; padding: 3px 6px; border: 1px solid #ddd; border-radius: 4px;\r\n      font-size: 12px; text-align: center; outline: none; font-family: inherit;\r\n    }\r\n    .vision-item .vision-time-input:focus { border-color: #0066cc; }\r\n    .vision-item .vision-time-input:disabled { background: #f5f5f5; color: #999; }\r\n    .vision-actions { display: flex; align-items: center; gap: 6px; flex-shrink: 0; }\r\n    .anchor-toggle {\r\n      width: 26px; height: 26px; border-radius: 50%; border: 2px solid #ddd;\r\n      background: transparent; cursor: pointer; display: flex;\r\n      align-items: center; justify-content: center; transition: all 0.15s;\r\n      font-size: 12px; color: #ccc;\r\n    }\r\n    .anchor-toggle:hover { border-color: #dc3545; color: #dc3545; }\r\n    .anchor-toggle.active { background: #dc3545; border-color: #dc3545; color: #fff; }\r\n    .delete-btn {\r\n      width: 26px; height: 26px; border-radius: 50%; border: 1px solid #eee;\r\n      background: transparent; cursor: pointer; display: flex;\r\n      align-items: center; justify-content: center; transition: all 0.15s;\r\n      font-size: 14px; color: #ccc;\r\n    }\r\n    .delete-btn:hover { background: #fee; border-color: #dc3545; color: #dc3545; }\r\n    .empty-state {\r\n      text-align: center; padding: 30px 16px; color: #aaa;\r\n    }\r\n    .empty-state svg { margin-bottom: 8px; opacity: 0.4; }\r\n    .empty-state p { font-size: 12px; }\r\n\r\n    /* Export Section */\r\n    .preset-select {\r\n      width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px;\r\n      font-size: 12px; font-family: inherit; outline: none; background: #fff;\r\n      cursor: pointer; color: #333;\r\n    }\r\n    .preset-select:focus { border-color: #0066cc; }\r\n    .preset-preview {\r\n      display: flex; align-items: center; justify-content: center;\r\n      padding: 8px; margin-top: 8px; background: #f7faff;\r\n      border: 1px dashed #b3d4fc; border-radius: 6px;\r\n      font-size: 12px; color: #0066cc; font-weight: 600;\r\n    }\r\n    .custom-dims {\r\n      display: none; gap: 8px; align-items: center; margin-top: 8px;\r\n    }\r\n    .custom-dims.visible { display: flex; }\r\n    .custom-dims input {\r\n      width: 80px; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px;\r\n      font-size: 12px; text-align: center; outline: none; font-family: inherit;\r\n    }\r\n    .custom-dims input:focus { border-color: #0066cc; }\r\n    .custom-dims span { color: #999; font-weight: 600; }\r\n\r\n    /* Recording indicator */\r\n    .recording-bar {\r\n      display: none; align-items: center; gap: 8px; padding: 10px 14px;\r\n      background: #fff5f5; border: 1px solid #f5c6cb; border-radius: 6px;\r\n      margin-top: 10px;\r\n    }\r\n    .recording-bar.active { display: flex; }\r\n    .recording-dot {\r\n      width: 10px; height: 10px; background: #dc3545; border-radius: 50%;\r\n      animation: pulse 1s infinite;\r\n    }\r\n    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }\r\n    .recording-bar span { font-size: 12px; color: #dc3545; font-weight: 600; }\r\n\r\n    /* Playing overlay */\r\n    body.playing .card { opacity: 0.6; pointer-events: none; }\r\n    body.playing .card.playback-card { opacity: 1; pointer-events: auto; }\r\n    body.playing .card.playback-card .btn:not(#play_button):not(#play_all_button) { pointer-events: none; opacity: 0.4; }\r\n    body.playing #play_button, body.playing #play_all_button { pointer-events: auto !important; opacity: 1 !important; }\r\n\r\n    /* Input base */\r\n    input[type=\"number\"] {\r\n      -moz-appearance: textfield;\r\n    }\r\n    input[type=\"number\"]::-webkit-inner-spin-button {\r\n      -webkit-appearance: none;\r\n    }\r\n\r\n    /* Draggable markers */\r\n    .marker { cursor: grab; }\r\n    .marker.dragging {\r\n      transform: translateX(-50%) scale(1.3);\r\n      z-index: 20;\r\n      cursor: grabbing;\r\n    }\r\n    .marker.no-drag { cursor: default; }\r\n\r\n    /* Saved timelines list */\r\n    .saved-timelines-list { margin-top: 10px; }\r\n    .saved-timelines-list:empty { display: none; }\r\n    .tl-item {\r\n      display: flex; align-items: center; gap: 8px;\r\n      padding: 6px 10px; border-bottom: 1px solid #f0f0f0;\r\n      cursor: pointer; transition: background 0.12s; font-size: 12px;\r\n    }\r\n    .tl-item:hover { background: #f7faff; }\r\n    .tl-item:last-child { border-bottom: none; }\r\n    .tl-item .tl-indicator {\r\n      width: 8px; height: 8px; border-radius: 50%;\r\n      background: #ccc; flex-shrink: 0;\r\n    }\r\n    .tl-item.active .tl-indicator { background: #0066cc; }\r\n    .tl-item .tl-name { flex: 1; font-weight: 500; color: #333; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }\r\n    .tl-item .tl-count { color: #999; font-size: 11px; flex-shrink: 0; }\r\n    .tl-item .tl-delete {\r\n      width: 20px; height: 20px; border-radius: 50%; border: 1px solid #eee;\r\n      background: transparent; cursor: pointer; display: flex;\r\n      align-items: center; justify-content: center; font-size: 12px; color: #ccc;\r\n      flex-shrink: 0; transition: all 0.15s;\r\n    }\r\n    .tl-item .tl-delete:hover { background: #fee; border-color: #dc3545; color: #dc3545; }\r\n\r\n    /* Drag-and-drop for timeline reordering */\r\n    .tl-drag-handle {\r\n      cursor: grab; flex-shrink: 0; color: #ccc; font-size: 14px;\r\n      padding: 0 4px; user-select: none;\r\n    }\r\n    .tl-drag-handle:active { cursor: grabbing; }\r\n    .tl-item.dragging { opacity: 0.4; }\r\n    .tl-item.drag-over-top { border-top: 2px solid #0066cc; }\r\n    .tl-item.drag-over-bottom { border-bottom: 2px solid #0066cc; }\r\n\r\n    /* Viewport info */\r\n    .viewport-info {\r\n      font-size: 11px; color: #666; margin-bottom: 10px;\r\n      padding: 6px 10px; background: #f9f9f9; border-radius: 4px; border: 1px solid #eee;\r\n    }\r\n\r\n    /* Misc */\r\n    .hidden { display: none !important; }\r\n    .mt-8 { margin-top: 8px; }\r\n  </style>\r\n</head>\r\n<body>\r\n\r\n<!-- Header -->\r\n<div class=\"header\">\r\n  <svg width=\"28\" height=\"28\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"#0066cc\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\r\n    <path d=\"M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z\"/>\r\n    <circle cx=\"12\" cy=\"13\" r=\"4\"/>\r\n  </svg>\r\n  <div>\r\n    <h1>Tour Virtual</h1>\r\n    <span class=\"subtitle\">Linha do Tempo</span>\r\n  </div>\r\n</div>\r\n\r\n<!-- Timeline Card -->\r\n<div class=\"card\">\r\n  <div class=\"card-body\">\r\n    <div class=\"timeline-wrapper\">\r\n      <div class=\"timeline-track\"></div>\r\n      <input type=\"range\" min=\"0\" max=\"60\" step=\"0.1\" value=\"0\" id=\"timeline_range\" oninput=\"updateTime(this.value)\">\r\n      <div id=\"markers_layer\"></div>\r\n    </div>\r\n    <div class=\"time-row\">\r\n      <div class=\"time-display\"><span id=\"current_time\">0.0</span><small>s</small></div>\r\n      <div class=\"time-input-group\">\r\n        <label>Total:</label>\r\n        <input id=\"max_time\" type=\"number\" step=\"1\" value=\"60\" min=\"1\" onchange=\"atualizarTempoTotal()\"\r\n          style=\"width:65px; padding:4px 8px; border:1px solid #ddd; border-radius:4px; font-size:12px; text-align:center; outline:none; font-family:inherit;\">\r\n        <small style=\"color:#888;\">s</small>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Playback Controls Card -->\r\n<div class=\"card playback-card\">\r\n  <div class=\"card-body\">\r\n    <div class=\"btn-group\">\r\n      <button class=\"btn btn-primary\" onclick=\"addVision()\">\r\n        <svg width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2.5\"><line x1=\"12\" y1=\"5\" x2=\"12\" y2=\"19\"/><line x1=\"5\" y1=\"12\" x2=\"19\" y2=\"12\"/></svg>\r\n        Visão\r\n      </button>\r\n      <button id=\"play_button\" class=\"btn btn-success\" onclick=\"togglePlay()\">&#9654; Play</button>\r\n      <button id=\"play_all_button\" class=\"btn btn-outline btn-sm hidden\" onclick=\"togglePlayAll()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><polygon points=\"5 3 19 12 5 21 5 3\"/><line x1=\"19\" y1=\"3\" x2=\"19\" y2=\"21\"/></svg>\r\n        Play All\r\n      </button>\r\n      <button class=\"btn btn-outline btn-sm\" onclick=\"mostrarCampoAtalho()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><rect x=\"2\" y=\"4\" width=\"20\" height=\"16\" rx=\"2\"/><line x1=\"6\" y1=\"8\" x2=\"6\" y2=\"8\"/><line x1=\"10\" y1=\"8\" x2=\"10\" y2=\"8\"/><line x1=\"14\" y1=\"8\" x2=\"14\" y2=\"8\"/><line x1=\"18\" y1=\"8\" x2=\"18\" y2=\"8\"/><line x1=\"8\" y1=\"16\" x2=\"16\" y2=\"16\"/></svg>\r\n        Atalho\r\n      </button>\r\n      <span id=\"hotkey_edit\" class=\"hotkey-editor\">\r\n        <input id=\"hotkey_input\" type=\"text\" placeholder=\"Pressione...\" onkeydown=\"capturarAtalhoInput(event)\">\r\n        <button class=\"btn btn-primary btn-sm\" onclick=\"confirmarAtalho()\">Ok</button>\r\n      </span>\r\n    </div>\r\n    <div class=\"check-group\">\r\n      <div class=\"check-item\">\r\n        <input type=\"checkbox\" id=\"loop_checkbox\">\r\n        <label for=\"loop_checkbox\">Loop</label>\r\n      </div>\r\n      <div class=\"check-item\">\r\n        <input type=\"checkbox\" id=\"easing_checkbox\">\r\n        <label for=\"easing_checkbox\">Easing</label>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Visions Card -->\r\n<div class=\"card\">\r\n  <div class=\"card-header\" onclick=\"toggleSection('visions')\">\r\n    <h2>Visões salvas <span id=\"vision_count\" style=\"color:#999; font-weight:400;\"></span></h2>\r\n    <span class=\"toggle-icon\" id=\"visions_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body\" id=\"visions_body\">\r\n    <div class=\"vision-list\" id=\"lista_visoes\"></div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Gerenciar Time Line Card -->\r\n<div class=\"card\">\r\n  <div class=\"card-header\" onclick=\"toggleSection('timeline_mgr')\">\r\n    <h2>Gerenciar Time Line</h2>\r\n    <span class=\"toggle-icon\" id=\"timeline_mgr_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body\" id=\"timeline_mgr_body\">\r\n    <div class=\"btn-group\">\r\n      <button class=\"btn btn-outline\" onclick=\"novaTimeline()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z\"/><polyline points=\"14 2 14 8 20 8\"/><line x1=\"12\" y1=\"18\" x2=\"12\" y2=\"12\"/><line x1=\"9\" y1=\"15\" x2=\"15\" y2=\"15\"/></svg>\r\n        Nova\r\n      </button>\r\n      <button class=\"btn btn-outline\" onclick=\"exportarTimeline()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\"/><polyline points=\"7 10 12 15 17 10\"/><line x1=\"12\" y1=\"15\" x2=\"12\" y2=\"3\"/></svg>\r\n        Exportar Atual\r\n      </button>\r\n      <button class=\"btn btn-outline\" onclick=\"exportarProjeto()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z\"/><polyline points=\"9 14 12 17 15 14\"/><line x1=\"12\" y1=\"17\" x2=\"12\" y2=\"10\"/></svg>\r\n        Exportar Projeto\r\n      </button>\r\n      <input type=\"file\" id=\"import_file\" class=\"hidden\" accept=\".json\" onchange=\"importarTimeline(this)\">\r\n      <button class=\"btn btn-outline\" onclick=\"document.getElementById('import_file').click()\">\r\n        <svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><path d=\"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\"/><polyline points=\"17 8 12 3 7 8\"/><line x1=\"12\" y1=\"3\" x2=\"12\" y2=\"15\"/></svg>\r\n        Importar\r\n      </button>\r\n    </div>\r\n    <div id=\"saved_timelines_list\" class=\"saved-timelines-list\"></div>\r\n  </div>\r\n</div>\r\n\r\n<!-- Exportar Vídeo Card (colapsado por padrão) -->\r\n<div class=\"card\">\r\n  <div class=\"card-header collapsed\" onclick=\"toggleSection('export')\">\r\n    <h2>Exportar Vídeo</h2>\r\n    <span class=\"toggle-icon\" id=\"export_toggle\">&#9660;</span>\r\n  </div>\r\n  <div class=\"card-body collapsed\" id=\"export_body\">\r\n    <div id=\"ffmpeg_section\" class=\"#{has_ffmpeg ? '' : 'hidden'}\">\r\n      <div class=\"viewport-info\">\r\n        Viewport atual: <strong>#{vp_width} x #{vp_height} px</strong>\r\n      </div>\r\n\r\n      <select id=\"preset_select\" class=\"preset-select\" onchange=\"onPresetChange()\">\r\n        <option value=\"\" disabled selected>Selecione o formato…</option>\r\n      </select>\r\n\r\n      <div class=\"custom-dims\" id=\"custom_dims\">\r\n        <input type=\"number\" id=\"custom_w\" min=\"50\" placeholder=\"Largura\" value=\"1280\">\r\n        <span>x</span>\r\n        <input type=\"number\" id=\"custom_h\" min=\"50\" placeholder=\"Altura\" value=\"720\">\r\n        <small style=\"color:#888;\">px</small>\r\n      </div>\r\n\r\n      <div class=\"preset-preview\" id=\"preset_preview\" style=\"display:none;\"></div>\r\n\r\n      <div class=\"check-group\" style=\"margin-top:12px; flex-direction:column; align-items:flex-start; gap:8px;\">\r\n        <div class=\"check-item\">\r\n          <input type=\"checkbox\" id=\"rec_projeto\">\r\n          <label for=\"rec_projeto\">Gravar todo o projeto (todas as Time Lines)</label>\r\n        </div>\r\n        <div class=\"check-item\">\r\n          <input type=\"checkbox\" id=\"rec_inicio\" checked>\r\n          <label for=\"rec_inicio\">Iniciar do quadro 1</label>\r\n        </div>\r\n      </div>\r\n\r\n      <button class=\"btn btn-record mt-8\" id=\"btn_record\" onclick=\"iniciarGravacao()\" disabled style=\"width:100%; margin-top:12px;\">\r\n        <svg width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><circle cx=\"12\" cy=\"12\" r=\"10\"/><circle cx=\"12\" cy=\"12\" r=\"4\" fill=\"currentColor\"/></svg>\r\n        Iniciar Gravação\r\n      </button>\r\n\r\n      <div class=\"recording-bar\" id=\"recording_bar\">\r\n        <div class=\"recording-dot\"></div>\r\n        <span>Gravando...</span>\r\n      </div>\r\n    </div>\r\n\r\n    <div id=\"ffmpeg_install\" class=\"#{has_ffmpeg ? 'hidden' : ''}\" style=\"text-align:center; padding:12px 0;\">\r\n      <p style=\"color:#888; font-size:12px; margin-bottom:10px;\">FFmpeg necessário para gravar vídeo.</p>\r\n      <button class=\"btn btn-primary\" onclick=\"instalarExportacao()\">Instalar FFmpeg</button>\r\n    </div>\r\n\r\n    <!-- Modal de nome do arquivo -->\r\n    <div id=\"filename_modal\" style=\"display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.4);z-index:100;align-items:center;justify-content:center;\">\r\n      <div style=\"background:#fff;border-radius:10px;padding:24px;width:320px;box-shadow:0 8px 30px rgba(0,0,0,0.2);\">\r\n        <h3 style=\"font-size:14px;font-weight:600;color:#333;margin-bottom:12px;\">Nome do arquivo</h3>\r\n        <input id=\"filename_input\" type=\"text\" value=\"tour_final\" style=\"width:100%;padding:8px 12px;border:1px solid #ddd;border-radius:6px;font-size:13px;font-family:inherit;outline:none;margin-bottom:6px;\">\r\n        <small style=\"color:#888;\">A extensão .mp4 será adicionada automaticamente.</small>\r\n        <div style=\"display:flex;gap:8px;margin-top:16px;justify-content:flex-end;\">\r\n          <button class=\"btn btn-outline btn-sm\" onclick=\"fecharModalFilename()\">Cancelar</button>\r\n          <button class=\"btn btn-primary btn-sm\" onclick=\"confirmarFilename()\">Salvar</button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n<script>\r\n    let visoes = [], playing = false, currentIndex = 0;\r\n    let hotkey = { keyCode: #{current_hotkey}, ctrl: #{hotkey_ctrl}, alt: #{hotkey_alt}, shift: #{hotkey_shift} };\r\n    let capturingHotkey = false, pendingHotkey = null;\r\n    let savedTimelines = [];\r\n    let activeTimelineIndex = -1;\r\n    let playingAll = false, playAllQueue = [], playAllCurrentIdx = 0;\r\n    var viewportW = #{vp_width}, viewportH = #{vp_height};\r\n\r\n    if (window.sketchup) { window.sketchup.set_hotkey(hotkey.keyCode, hotkey.ctrl, hotkey.alt, hotkey.shift); }\r\n\r\n    /* --- Export Formats (aspect ratios) --- */\r\n    const EXPORT_FORMATS = [\r\n      { label: '16:9 Paisagem', ratio: [16, 9] },\r\n      { label: '9:16 Retrato', ratio: [9, 16] },\r\n      { label: '1:1 Quadrado', ratio: [1, 1] },\r\n      { label: '4:3 Clássico', ratio: [4, 3] },\r\n      { label: '21:9 Ultra-wide', ratio: [21, 9] },\r\n      { label: 'Viewport Inteira', ratio: null },\r\n      { label: 'Personalizado', ratio: null, custom: true }\r\n    ];\r\n\r\n    function calcEffectiveDims(ratioW, ratioH, vpW, vpH) {\r\n      const scaleW = vpW / ratioW;\r\n      const scaleH = vpH / ratioH;\r\n      const scale = Math.min(scaleW, scaleH);\r\n      let w = Math.floor(ratioW * scale);\r\n      let h = Math.floor(ratioH * scale);\r\n      w = w % 2 === 0 ? w : w - 1;\r\n      h = h % 2 === 0 ? h : h - 1;\r\n      return { w: w, h: h };\r\n    }\r\n\r\n    function populatePresets() {\r\n      const sel = document.getElementById(\"preset_select\");\r\n      sel.innerHTML = '<option value=\"\" disabled selected>Selecione o formato…</option>';\r\n      EXPORT_FORMATS.forEach((fmt, i) => {\r\n        const opt = document.createElement(\"option\");\r\n        opt.value = i.toString();\r\n        if (fmt.custom) {\r\n          opt.textContent = fmt.label;\r\n        } else if (fmt.ratio) {\r\n          const dims = calcEffectiveDims(fmt.ratio[0], fmt.ratio[1], viewportW, viewportH);\r\n          opt.textContent = fmt.label + \" (\" + dims.w + \" x \" + dims.h + \" px)\";\r\n        } else {\r\n          let w = viewportW % 2 === 0 ? viewportW : viewportW - 1;\r\n          let h = viewportH % 2 === 0 ? viewportH : viewportH - 1;\r\n          opt.textContent = fmt.label + \" (\" + w + \" x \" + h + \" px)\";\r\n        }\r\n        sel.appendChild(opt);\r\n      });\r\n    }\r\n\r\n    /* --- Section Toggle --- */\r\n    function toggleSection(name) {\r\n      const body = document.getElementById(name + '_body');\r\n      const icon = document.getElementById(name + '_toggle');\r\n      const header = icon.parentElement;\r\n      const wasCollapsed = body.classList.contains('collapsed');\r\n      if (wasCollapsed) {\r\n        body.classList.remove('collapsed');\r\n        header.classList.remove('collapsed');\r\n      } else {\r\n        body.classList.add('collapsed');\r\n        header.classList.add('collapsed');\r\n      }\r\n      /* Hide viewport preview when closing export card */\r\n      if (name === 'export' && !wasCollapsed) {\r\n        if (window.sketchup) window.sketchup.hide_export_preview();\r\n      }\r\n    }\r\n\r\n    /* --- Timeline --- */\r\n    function updateTime(val) {\r\n      document.getElementById(\"current_time\").innerText = parseFloat(val).toFixed(1);\r\n    }\r\n\r\n    function atualizarTempoTotal() {\r\n      const novoMax = parseFloat(document.getElementById(\"max_time\").value);\r\n      if (isNaN(novoMax) || novoMax <= 0) return;\r\n      document.getElementById(\"timeline_range\").max = novoMax;\r\n      visoes.forEach(v => { if (v.time > novoMax) v.time = novoMax - 0.1; });\r\n      renderMarkers();\r\n    }\r\n\r\n    /* --- Visions --- */\r\n    function addVision() {\r\n      if (savedTimelines.length === 0 && visoes.length === 0) {\r\n        var name = prompt(\"Nome da Time Line:\", \"Time Line 1\");\r\n        if (!name) return;\r\n        savedTimelines.push({ name: name, visoes: [], maxTime: 60 });\r\n        activeTimelineIndex = 0;\r\n        renderSavedTimelines();\r\n      }\r\n      const time = parseFloat(document.getElementById(\"timeline_range\").value);\r\n      sketchup.capture_camera(time);\r\n    }\r\n\r\n    function captureVisionFromRuby(camJson) {\r\n      const obj = JSON.parse(camJson);\r\n      obj.walk = false; obj.anchor = false;\r\n      visoes = visoes.filter(v => v.time !== obj.time);\r\n      visoes.push(obj);\r\n      visoes.sort((a, b) => a.time - b.time);\r\n      visoes[0].time = 0.0;\r\n      syncActiveTimeline();\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    /* --- Draggable markers --- */\r\n    function setupMarkerDrag(marker, visionIndex, slider, maxTime) {\r\n      if (visionIndex === 0) {\r\n        marker.classList.add(\"no-drag\");\r\n        return;\r\n      }\r\n      marker.addEventListener(\"mousedown\", function(e) {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        marker.classList.add(\"dragging\");\r\n        const sliderPadding = 8;\r\n\r\n        function onMove(ev) {\r\n          const sliderRect = slider.getBoundingClientRect();\r\n          const usableWidth = sliderRect.width - sliderPadding * 2;\r\n          const relativeX = Math.max(0, Math.min(ev.clientX - sliderRect.left - sliderPadding, usableWidth));\r\n          const newTime = parseFloat(((relativeX / usableWidth) * maxTime).toFixed(1));\r\n          marker.style.left = (relativeX + sliderPadding) + \"px\";\r\n          const tooltip = marker.querySelector(\".marker-tooltip\");\r\n          if (tooltip) tooltip.textContent = newTime.toFixed(1) + \"s\";\r\n        }\r\n\r\n        function onUp(ev) {\r\n          marker.classList.remove(\"dragging\");\r\n          document.removeEventListener(\"mousemove\", onMove);\r\n          document.removeEventListener(\"mouseup\", onUp);\r\n          const sliderRect = slider.getBoundingClientRect();\r\n          const usableWidth = sliderRect.width - sliderPadding * 2;\r\n          const relativeX = Math.max(0, Math.min(ev.clientX - sliderRect.left - sliderPadding, usableWidth));\r\n          const newTime = parseFloat(((relativeX / usableWidth) * maxTime).toFixed(1));\r\n          visoes[visionIndex].time = Math.max(0.1, newTime);\r\n          visoes.sort((a, b) => a.time - b.time);\r\n          if (visoes.length > 0) visoes[0].time = 0.0;\r\n          renderMarkers();\r\n        }\r\n\r\n        document.addEventListener(\"mousemove\", onMove);\r\n        document.addEventListener(\"mouseup\", onUp);\r\n      });\r\n    }\r\n\r\n    function syncActiveTimeline() {\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n    }\r\n\r\n    function renderMarkers() {\r\n      const layer = document.getElementById(\"markers_layer\");\r\n      const lista = document.getElementById(\"lista_visoes\");\r\n      const slider = document.getElementById(\"timeline_range\");\r\n      const max = parseFloat(slider.max);\r\n      const width = slider.offsetWidth;\r\n      const countEl = document.getElementById(\"vision_count\");\r\n\r\n      layer.innerHTML = \"\"; lista.innerHTML = \"\";\r\n      countEl.textContent = visoes.length > 0 ? \"(\" + visoes.length + \")\" : \"\";\r\n\r\n      if (visoes.length === 0) {\r\n        lista.innerHTML = '<div class=\"empty-state\">' +\r\n          '<svg width=\"36\" height=\"36\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"#ccc\" stroke-width=\"1.5\"><path d=\"M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z\"/><circle cx=\"12\" cy=\"13\" r=\"4\"/></svg>' +\r\n          '<p>Nenhuma visão adicionada.<br>Posicione a câmera e clique em <b>+ Visão</b>.</p></div>';\r\n        return;\r\n      }\r\n\r\n      visoes.forEach((v, i) => {\r\n        /* Marker on timeline */\r\n        const percent = max > 0 ? v.time / max : 0;\r\n        const marker = document.createElement(\"div\");\r\n        marker.className = \"marker\" + (v.anchor ? \" anchor\" : \"\");\r\n        const sliderPadding = 8;\r\n        const usableWidth = width - sliderPadding * 2;\r\n        marker.style.left = (percent * usableWidth + sliderPadding) + \"px\";\r\n        const tooltip = document.createElement(\"span\");\r\n        tooltip.className = \"marker-tooltip\";\r\n        tooltip.textContent = v.time.toFixed(1) + \"s\";\r\n        marker.appendChild(tooltip);\r\n        marker.onclick = () => {\r\n          slider.value = v.time; updateTime(v.time); currentIndex = i;\r\n          resetPlayButton(); sketchup.goto_camera(JSON.stringify(v));\r\n        };\r\n        /* Draggable */\r\n        setupMarkerDrag(marker, i, slider, max);\r\n        layer.appendChild(marker);\r\n\r\n        /* Vision list item */\r\n        const item = document.createElement(\"div\");\r\n        item.className = \"vision-item\";\r\n        item.onclick = () => {\r\n          slider.value = v.time; updateTime(v.time); currentIndex = i;\r\n          resetPlayButton(); sketchup.goto_camera(JSON.stringify(v));\r\n        };\r\n\r\n        const num = document.createElement(\"span\");\r\n        num.className = \"vision-num\";\r\n        num.textContent = (i + 1);\r\n\r\n        const img = document.createElement(\"img\");\r\n        if (v.thumb && v.thumb.length > 0) {\r\n          const mime = v.thumb.startsWith(\"/9j/\") ? \"image/jpeg\" : \"image/bmp\";\r\n          img.src = \"data:\" + mime + \";base64,\" + v.thumb;\r\n        } else {\r\n          img.src = \"\";\r\n          img.className = \"thumb-placeholder\";\r\n        }\r\n\r\n        const info = document.createElement(\"div\");\r\n        info.className = \"vision-info\";\r\n        const timeInput = document.createElement(\"input\");\r\n        timeInput.type = \"number\"; timeInput.step = \"0.1\";\r\n        timeInput.value = v.time.toFixed(1);\r\n        timeInput.className = \"vision-time-input\";\r\n        timeInput.disabled = (i === 0);\r\n        timeInput.onclick = (e) => e.stopPropagation();\r\n        timeInput.onchange = () => {\r\n          v.time = parseFloat(timeInput.value);\r\n          visoes.sort((a, b) => a.time - b.time);\r\n          renderMarkers();\r\n        };\r\n        info.appendChild(timeInput);\r\n\r\n        const actions = document.createElement(\"div\");\r\n        actions.className = \"vision-actions\";\r\n\r\n        const anchorBtn = document.createElement(\"button\");\r\n        anchorBtn.className = \"anchor-toggle\" + (v.anchor ? \" active\" : \"\");\r\n        anchorBtn.innerHTML = \"&#9875;\";\r\n        anchorBtn.title = \"Âncora\";\r\n        anchorBtn.onclick = (e) => {\r\n          e.stopPropagation();\r\n          v.anchor = !v.anchor;\r\n          renderMarkers();\r\n        };\r\n        actions.appendChild(anchorBtn);\r\n\r\n        const delBtn = document.createElement(\"button\");\r\n        delBtn.className = \"delete-btn\";\r\n        delBtn.innerHTML = \"&times;\";\r\n        delBtn.title = \"Excluir\";\r\n        delBtn.onclick = (e) => {\r\n          e.stopPropagation();\r\n          visoes.splice(i, 1);\r\n          if (visoes.length > 0) visoes[0].time = 0.0;\r\n          syncActiveTimeline();\r\n          renderMarkers();\r\n          renderSavedTimelines();\r\n        };\r\n        actions.appendChild(delBtn);\r\n\r\n        item.appendChild(num);\r\n        item.appendChild(img);\r\n        item.appendChild(info);\r\n        item.appendChild(actions);\r\n        lista.appendChild(item);\r\n      });\r\n    }\r\n\r\n    /* --- Playback --- */\r\n    function togglePlay() {\r\n      if (!playing) {\r\n        if (visoes.length < 2) return alert(\"Adicione pelo menos duas visões.\");\r\n        if (currentIndex >= visoes.length - 1) currentIndex = 0;\r\n        playing = true;\r\n        document.body.classList.add(\"playing\");\r\n        document.getElementById(\"play_button\").innerHTML = \"&#9724; Stop\";\r\n        document.getElementById(\"play_button\").className = \"btn btn-danger\";\r\n        sketchup.play_tour(JSON.stringify(visoes), document.getElementById(\"loop_checkbox\").checked, false, document.getElementById(\"easing_checkbox\").checked, currentIndex);\r\n      } else {\r\n        resetPlayButton();\r\n        sketchup.stop_tour();\r\n      }\r\n    }\r\n\r\n    function resetPlayButton() {\r\n      playing = false;\r\n      document.body.classList.remove(\"playing\");\r\n      document.getElementById(\"play_button\").innerHTML = \"&#9654; Play\";\r\n      document.getElementById(\"play_button\").className = \"btn btn-success\";\r\n    }\r\n\r\n    function togglePlayAll() {\r\n      if (playingAll) {\r\n        resetPlayAll();\r\n        sketchup.stop_tour();\r\n        return;\r\n      }\r\n      if (savedTimelines.length < 2) return;\r\n      /* Save current timeline state */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n      /* Build queue of timelines with 2+ visions */\r\n      playAllQueue = savedTimelines.map(function(tl, i) { return i; }).filter(function(i) { return savedTimelines[i].visoes.length >= 2; });\r\n      if (playAllQueue.length < 1) { alert(\"Nenhuma Time Line com 2+ visões.\"); return; }\r\n      playingAll = true;\r\n      playAllCurrentIdx = 0;\r\n      document.body.classList.add(\"playing\");\r\n      document.getElementById(\"play_all_button\").innerHTML = \"&#9724; Stop All\";\r\n      document.getElementById(\"play_all_button\").className = \"btn btn-danger btn-sm\";\r\n      playTimelineAtQueueIndex(0);\r\n    }\r\n\r\n    function playTimelineAtQueueIndex(qIdx) {\r\n      var tlIdx = playAllQueue[qIdx];\r\n      var tl = savedTimelines[tlIdx];\r\n      visoes = JSON.parse(JSON.stringify(tl.visoes));\r\n      document.getElementById(\"max_time\").value = tl.maxTime;\r\n      document.getElementById(\"timeline_range\").max = tl.maxTime;\r\n      activeTimelineIndex = tlIdx;\r\n      currentIndex = 0;\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n      sketchup.play_tour(\r\n        JSON.stringify(visoes),\r\n        false,\r\n        false,\r\n        document.getElementById(\"easing_checkbox\").checked,\r\n        0\r\n      );\r\n    }\r\n\r\n    function resetPlayAll() {\r\n      playingAll = false;\r\n      playAllQueue = [];\r\n      playAllCurrentIdx = 0;\r\n      document.body.classList.remove(\"playing\");\r\n      var btn = document.getElementById(\"play_all_button\");\r\n      btn.innerHTML = '<svg width=\"12\" height=\"12\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" stroke-width=\"2\"><polygon points=\"5 3 19 12 5 21 5 3\"/><line x1=\"19\" y1=\"3\" x2=\"19\" y2=\"21\"/></svg> Play All';\r\n      btn.className = \"btn btn-outline btn-sm\";\r\n      playing = false;\r\n      document.getElementById(\"play_button\").innerHTML = \"&#9654; Play\";\r\n      document.getElementById(\"play_button\").className = \"btn btn-success\";\r\n    }\r\n\r\n    function startRecordingPlayAll(startTlIdx, startVisionIdx) {\r\n      syncActiveTimeline();\r\n      /* Montar fila de timelines com 2+ visões, a partir de startTlIdx */\r\n      playAllQueue = [];\r\n      for (var i = startTlIdx; i < savedTimelines.length; i++) {\r\n        if (savedTimelines[i].visoes.length >= 2) playAllQueue.push(i);\r\n      }\r\n      if (playAllQueue.length === 0) return;\r\n\r\n      playingAll = true;\r\n      playAllCurrentIdx = 0;\r\n      playing = true;\r\n      document.body.classList.add(\"playing\");\r\n      document.getElementById(\"play_button\").innerHTML = \"&#9724; Stop\";\r\n      document.getElementById(\"play_button\").className = \"btn btn-danger\";\r\n\r\n      /* Carregar a primeira timeline da fila */\r\n      var firstTlIdx = playAllQueue[0];\r\n      var tl = savedTimelines[firstTlIdx];\r\n      visoes = JSON.parse(JSON.stringify(tl.visoes));\r\n      document.getElementById(\"max_time\").value = tl.maxTime;\r\n      document.getElementById(\"timeline_range\").max = tl.maxTime;\r\n      activeTimelineIndex = firstTlIdx;\r\n      currentIndex = startVisionIdx;\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n\r\n      sketchup.play_tour(\r\n        JSON.stringify(visoes),\r\n        false,\r\n        false,\r\n        document.getElementById(\"easing_checkbox\").checked,\r\n        startVisionIdx\r\n      );\r\n    }\r\n\r\n    function updatePlayAllButton() {\r\n      var btn = document.getElementById(\"play_all_button\");\r\n      if (savedTimelines.length > 1) {\r\n        btn.classList.remove(\"hidden\");\r\n      } else {\r\n        btn.classList.add(\"hidden\");\r\n      }\r\n    }\r\n\r\n    function pauseAtIndex(idx) {\r\n      currentIndex = idx;\r\n      if (playingAll) {\r\n        playAllCurrentIdx++;\r\n        if (playAllCurrentIdx < playAllQueue.length) {\r\n          playTimelineAtQueueIndex(playAllCurrentIdx);\r\n          return;\r\n        } else {\r\n          resetPlayAll();\r\n          return;\r\n        }\r\n      }\r\n      resetPlayButton();\r\n    }\r\n    function triggerSpaceFromRuby() { togglePlay(); }\r\n    function updatePlayhead(time) {\r\n      var slider = document.getElementById(\"timeline_range\");\r\n      slider.value = time;\r\n      document.getElementById(\"current_time\").innerText = parseFloat(time).toFixed(1);\r\n    }\r\n\r\n    /* --- Timeline Management --- */\r\n    function exportarTimeline() {\r\n      if (visoes.length === 0) { alert(\"Nenhuma visão para exportar.\"); return; }\r\n      var tlName = (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length)\r\n        ? savedTimelines[activeTimelineIndex].name : \"Time Line\";\r\n      /* Download JSON */\r\n      var dataStr = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(visoes, null, 2));\r\n      var a = document.createElement(\"a\");\r\n      a.setAttribute(\"href\", dataStr);\r\n      a.setAttribute(\"download\", tlName.replace(/[^a-zA-Z0-9_-]/g, \"_\") + \".json\");\r\n      document.body.appendChild(a); a.click(); a.remove();\r\n      /* Salvar na lista */\r\n      saveCurrentToTimelines(tlName);\r\n    }\r\n\r\n    function exportarProjeto() {\r\n      syncActiveTimeline();\r\n      if (savedTimelines.length === 0) { alert(\"Nenhuma Time Line para exportar.\"); return; }\r\n      var projeto = { type: \"tour_virtual_project\", timelines: savedTimelines };\r\n      var dataStr = \"data:text/json;charset=utf-8,\" + encodeURIComponent(JSON.stringify(projeto, null, 2));\r\n      var a = document.createElement(\"a\");\r\n      a.setAttribute(\"href\", dataStr);\r\n      a.setAttribute(\"download\", \"projeto_tour_virtual.json\");\r\n      document.body.appendChild(a); a.click(); a.remove();\r\n    }\r\n\r\n    function saveCurrentToTimelines(name) {\r\n      var maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      var entry = { name: name, visoes: JSON.parse(JSON.stringify(visoes)), maxTime: maxTime };\r\n      /* Atualizar existente se ativo, senão adicionar novo */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex] = entry;\r\n      } else {\r\n        savedTimelines.push(entry);\r\n        activeTimelineIndex = savedTimelines.length - 1;\r\n      }\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    function importarTimeline(input) {\r\n      var file = input.files[0];\r\n      if (!file) return;\r\n      var reader = new FileReader();\r\n      reader.onload = function(e) {\r\n        try {\r\n          var imported = JSON.parse(e.target.result);\r\n          /* Detectar se é um projeto completo */\r\n          if (imported && imported.type === \"tour_virtual_project\" && Array.isArray(imported.timelines)) {\r\n            syncActiveTimeline();\r\n            imported.timelines.forEach(function(tl) {\r\n              if (tl.visoes) {\r\n                tl.visoes.sort(function(a, b) { return a.time - b.time; });\r\n                if (tl.visoes.length > 0) tl.visoes[0].time = 0.0;\r\n              }\r\n              savedTimelines.push({ name: tl.name || \"Importada\", visoes: tl.visoes || [], maxTime: tl.maxTime || 60 });\r\n            });\r\n            if (savedTimelines.length > 0 && activeTimelineIndex < 0) {\r\n              activeTimelineIndex = 0;\r\n              var first = savedTimelines[0];\r\n              visoes = JSON.parse(JSON.stringify(first.visoes));\r\n              document.getElementById(\"max_time\").value = first.maxTime;\r\n              document.getElementById(\"timeline_range\").max = first.maxTime;\r\n              renderMarkers();\r\n            }\r\n            renderSavedTimelines();\r\n            return;\r\n          }\r\n          /* Time Line única */\r\n          if (!Array.isArray(imported)) throw \"Formato inválido.\";\r\n          imported.sort(function(a, b) { return a.time - b.time; });\r\n          if (imported.length > 0) imported[0].time = 0.0;\r\n          var maxTime = imported.length > 0 ? Math.ceil(imported[imported.length - 1].time + 1) : 60;\r\n          var name = file.name.replace(/\\\\.json$/i, \"\");\r\n          savedTimelines.push({ name: name, visoes: imported, maxTime: maxTime });\r\n          renderSavedTimelines();\r\n        } catch (err) { alert(\"Erro ao importar: \" + err); }\r\n      };\r\n      reader.readAsText(file);\r\n      input.value = \"\";\r\n    }\r\n\r\n    function switchTimeline(index) {\r\n      if (index === activeTimelineIndex) return;\r\n      /* Save current state if there's an active timeline */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n      /* Load selected timeline */\r\n      const tl = savedTimelines[index];\r\n      visoes = JSON.parse(JSON.stringify(tl.visoes));\r\n      document.getElementById(\"max_time\").value = tl.maxTime;\r\n      document.getElementById(\"timeline_range\").max = tl.maxTime;\r\n      activeTimelineIndex = index;\r\n      currentIndex = 0;\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    function deleteTimeline(index) {\r\n      if (index === activeTimelineIndex) return;\r\n      savedTimelines.splice(index, 1);\r\n      if (activeTimelineIndex > index) activeTimelineIndex--;\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    function renderSavedTimelines() {\r\n      var container = document.getElementById(\"saved_timelines_list\");\r\n      container.innerHTML = \"\";\r\n      if (savedTimelines.length === 0) { updatePlayAllButton(); return; }\r\n      var dragSrcIndex = null;\r\n\r\n      savedTimelines.forEach(function(tl, i) {\r\n        var item = document.createElement(\"div\");\r\n        item.className = \"tl-item\" + (i === activeTimelineIndex ? \" active\" : \"\");\r\n        item.draggable = true;\r\n        item.dataset.index = i;\r\n\r\n        /* Drag handle */\r\n        var handle = document.createElement(\"span\");\r\n        handle.className = \"tl-drag-handle\";\r\n        handle.innerHTML = \"&#9776;\";\r\n        item.appendChild(handle);\r\n\r\n        /* Drag events */\r\n        item.addEventListener(\"dragstart\", function(e) {\r\n          dragSrcIndex = i;\r\n          item.classList.add(\"dragging\");\r\n          e.dataTransfer.effectAllowed = \"move\";\r\n        });\r\n        item.addEventListener(\"dragover\", function(e) {\r\n          e.preventDefault();\r\n          e.dataTransfer.dropEffect = \"move\";\r\n          var rect = item.getBoundingClientRect();\r\n          var midY = rect.top + rect.height / 2;\r\n          item.classList.remove(\"drag-over-top\", \"drag-over-bottom\");\r\n          item.classList.add(e.clientY < midY ? \"drag-over-top\" : \"drag-over-bottom\");\r\n        });\r\n        item.addEventListener(\"dragleave\", function() {\r\n          item.classList.remove(\"drag-over-top\", \"drag-over-bottom\");\r\n        });\r\n        item.addEventListener(\"drop\", function(e) {\r\n          e.preventDefault();\r\n          item.classList.remove(\"drag-over-top\", \"drag-over-bottom\");\r\n          if (dragSrcIndex === null || dragSrcIndex === i) return;\r\n          var rect = item.getBoundingClientRect();\r\n          var midY = rect.top + rect.height / 2;\r\n          var targetIndex = e.clientY < midY ? i : i + 1;\r\n          if (dragSrcIndex < targetIndex) targetIndex--;\r\n          var moved = savedTimelines.splice(dragSrcIndex, 1)[0];\r\n          savedTimelines.splice(targetIndex, 0, moved);\r\n          if (activeTimelineIndex === dragSrcIndex) {\r\n            activeTimelineIndex = targetIndex;\r\n          } else if (dragSrcIndex < activeTimelineIndex && targetIndex >= activeTimelineIndex) {\r\n            activeTimelineIndex--;\r\n          } else if (dragSrcIndex > activeTimelineIndex && targetIndex <= activeTimelineIndex) {\r\n            activeTimelineIndex++;\r\n          }\r\n          renderSavedTimelines();\r\n        });\r\n        item.addEventListener(\"dragend\", function() {\r\n          item.classList.remove(\"dragging\");\r\n          dragSrcIndex = null;\r\n        });\r\n\r\n        item.onclick = function() { switchTimeline(i); };\r\n\r\n        var indicator = document.createElement(\"span\");\r\n        indicator.className = \"tl-indicator\";\r\n        item.appendChild(indicator);\r\n\r\n        var nameEl = document.createElement(\"span\");\r\n        nameEl.className = \"tl-name\";\r\n        nameEl.textContent = tl.name;\r\n        item.appendChild(nameEl);\r\n\r\n        var count = document.createElement(\"span\");\r\n        count.className = \"tl-count\";\r\n        count.textContent = tl.visoes.length + \" visões\";\r\n        item.appendChild(count);\r\n\r\n        if (i !== activeTimelineIndex) {\r\n          var del = document.createElement(\"button\");\r\n          del.className = \"tl-delete\";\r\n          del.innerHTML = \"&times;\";\r\n          del.title = \"Excluir\";\r\n          del.onclick = function(e) { e.stopPropagation(); deleteTimeline(i); };\r\n          item.appendChild(del);\r\n        }\r\n\r\n        container.appendChild(item);\r\n      });\r\n\r\n      updatePlayAllButton();\r\n    }\r\n\r\n    function novaTimeline() {\r\n      var name = prompt(\"Nome da nova Time Line:\", \"Time Line \" + (savedTimelines.length + 1));\r\n      if (!name) return;\r\n      /* Salvar timeline atual na lista se pertencer a uma timeline salva */\r\n      if (activeTimelineIndex >= 0 && activeTimelineIndex < savedTimelines.length) {\r\n        savedTimelines[activeTimelineIndex].visoes = JSON.parse(JSON.stringify(visoes));\r\n        savedTimelines[activeTimelineIndex].maxTime = parseFloat(document.getElementById(\"max_time\").value) || 60;\r\n      }\r\n      /* Criar nova timeline vazia e adicioná-la à lista */\r\n      savedTimelines.push({ name: name, visoes: [], maxTime: 60 });\r\n      activeTimelineIndex = savedTimelines.length - 1;\r\n      /* Limpar estado */\r\n      visoes = [];\r\n      currentIndex = 0;\r\n      document.getElementById(\"max_time\").value = 60;\r\n      document.getElementById(\"timeline_range\").max = 60;\r\n      document.getElementById(\"timeline_range\").value = 0;\r\n      updateTime(0);\r\n      renderMarkers();\r\n      renderSavedTimelines();\r\n    }\r\n\r\n    /* --- Video Export with Proportional Presets --- */\r\n    function onPresetChange() {\r\n      const sel = document.getElementById(\"preset_select\");\r\n      const preview = document.getElementById(\"preset_preview\");\r\n      const customDims = document.getElementById(\"custom_dims\");\r\n      const btnRecord = document.getElementById(\"btn_record\");\r\n      const idx = parseInt(sel.value);\r\n\r\n      if (isNaN(idx)) {\r\n        customDims.classList.remove(\"visible\");\r\n        preview.style.display = \"none\";\r\n        btnRecord.disabled = true;\r\n        if (window.sketchup) window.sketchup.hide_export_preview();\r\n        return;\r\n      }\r\n\r\n      const fmt = EXPORT_FORMATS[idx];\r\n      btnRecord.disabled = false;\r\n\r\n      if (fmt.custom) {\r\n        customDims.classList.add(\"visible\");\r\n        preview.style.display = \"none\";\r\n        if (window.sketchup) window.sketchup.hide_export_preview();\r\n      } else {\r\n        customDims.classList.remove(\"visible\");\r\n        let dims;\r\n        if (fmt.ratio) {\r\n          dims = calcEffectiveDims(fmt.ratio[0], fmt.ratio[1], viewportW, viewportH);\r\n        } else {\r\n          dims = { w: viewportW % 2 === 0 ? viewportW : viewportW - 1, h: viewportH % 2 === 0 ? viewportH : viewportH - 1 };\r\n        }\r\n        preview.textContent = \"Área de gravação: \" + dims.w + \" x \" + dims.h + \" px\";\r\n        preview.style.display = \"flex\";\r\n        /* Show preview overlay in viewport */\r\n        if (window.sketchup) window.sketchup.show_export_preview(dims.w, dims.h);\r\n      }\r\n    }\r\n\r\n    function getExportDimensions() {\r\n      const sel = document.getElementById(\"preset_select\");\r\n      const idx = parseInt(sel.value);\r\n      if (isNaN(idx)) return null;\r\n      const fmt = EXPORT_FORMATS[idx];\r\n      if (fmt.custom) {\r\n        return {\r\n          w: parseInt(document.getElementById(\"custom_w\").value) || 1280,\r\n          h: parseInt(document.getElementById(\"custom_h\").value) || 720\r\n        };\r\n      }\r\n      if (fmt.ratio) {\r\n        return calcEffectiveDims(fmt.ratio[0], fmt.ratio[1], viewportW, viewportH);\r\n      }\r\n      return { w: viewportW % 2 === 0 ? viewportW : viewportW - 1, h: viewportH % 2 === 0 ? viewportH : viewportH - 1 };\r\n    }\r\n\r\n    function iniciarGravacao() {\r\n      var gravarProjeto = document.getElementById(\"rec_projeto\").checked;\r\n      var desdeInicio = document.getElementById(\"rec_inicio\").checked;\r\n\r\n      if (gravarProjeto) {\r\n        syncActiveTimeline();\r\n        var temVisoes = savedTimelines.some(function(tl) { return tl.visoes.length >= 2; });\r\n        if (!temVisoes) { alert(\"Nenhuma Time Line com pelo menos duas visões.\"); return; }\r\n      } else {\r\n        if (visoes.length < 2) { alert(\"Adicione pelo menos duas visões.\"); return; }\r\n      }\r\n      var dims = getExportDimensions();\r\n      if (!dims || dims.w < 50 || dims.h < 50) { alert(\"Dimensões inválidas (mínimo 50 x 50 px).\"); return; }\r\n\r\n      /* Mostrar modal de nome */\r\n      document.getElementById(\"filename_input\").value = gravarProjeto ? \"projeto_tour\" : \"tour_final\";\r\n      document.getElementById(\"filename_modal\").style.display = \"flex\";\r\n      document.getElementById(\"filename_input\").focus();\r\n      document.getElementById(\"filename_input\").select();\r\n    }\r\n\r\n    function fecharModalFilename() {\r\n      document.getElementById(\"filename_modal\").style.display = \"none\";\r\n    }\r\n\r\n    function confirmarFilename() {\r\n      var nome = document.getElementById(\"filename_input\").value.trim();\r\n      if (!nome) { alert(\"Digite um nome para o arquivo.\"); return; }\r\n      document.getElementById(\"filename_modal\").style.display = \"none\";\r\n\r\n      var gravarProjeto = document.getElementById(\"rec_projeto\").checked;\r\n      var desdeInicio = document.getElementById(\"rec_inicio\").checked;\r\n      var dims = getExportDimensions();\r\n      var startIdx = desdeInicio ? 0 : currentIndex;\r\n\r\n      if (window.sketchup) window.sketchup.hide_export_preview();\r\n\r\n      if (gravarProjeto) {\r\n        syncActiveTimeline();\r\n        var allTimelines = JSON.stringify(savedTimelines);\r\n        var startTl = desdeInicio ? 0 : activeTimelineIndex;\r\n        var startVision = desdeInicio ? 0 : currentIndex;\r\n        if (window.sketchup) {\r\n          window.sketchup.start_export_project(\r\n            allTimelines,\r\n            document.getElementById(\"easing_checkbox\").checked,\r\n            startTl,\r\n            startVision,\r\n            dims.w,\r\n            dims.h,\r\n            nome\r\n          );\r\n        }\r\n      } else {\r\n        if (window.sketchup) {\r\n          window.sketchup.start_export_process(\r\n            JSON.stringify(visoes),\r\n            document.getElementById(\"easing_checkbox\").checked,\r\n            startIdx,\r\n            dims.w,\r\n            dims.h,\r\n            nome\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    function showRecordingIndicator() {\r\n      document.getElementById(\"recording_bar\").classList.add(\"active\");\r\n    }\r\n    function hideRecordingIndicator() {\r\n      document.getElementById(\"recording_bar\").classList.remove(\"active\");\r\n    }\r\n\r\n    function instalarExportacao() {\r\n      if (window.sketchup) { window.sketchup.install_ffmpeg(); }\r\n    }\r\n\r\n    /* --- Hotkey --- */\r\n    function mostrarCampoAtalho() {\r\n      capturingHotkey = true; pendingHotkey = null;\r\n      document.getElementById(\"hotkey_input\").value = \"\";\r\n      document.getElementById(\"hotkey_edit\").classList.add(\"visible\");\r\n      document.getElementById(\"hotkey_input\").focus();\r\n    }\r\n    function capturarAtalhoInput(e) {\r\n      e.preventDefault();\r\n      /* Ignorar teclas modificadoras sozinhas */\r\n      if ([16, 17, 18, 91, 93].includes(e.keyCode)) return;\r\n      pendingHotkey = {\r\n        keyCode: e.keyCode,\r\n        ctrl: e.ctrlKey,\r\n        alt: e.altKey,\r\n        shift: e.shiftKey\r\n      };\r\n      /* Montar label legivel */\r\n      var parts = [];\r\n      if (e.ctrlKey) parts.push(\"Ctrl\");\r\n      if (e.altKey) parts.push(\"Alt\");\r\n      if (e.shiftKey) parts.push(\"Shift\");\r\n      parts.push(e.code.replace(\"Key\", \"\").replace(\"Digit\", \"\"));\r\n      document.getElementById(\"hotkey_input\").value = parts.join(\" + \");\r\n    }\r\n    function confirmarAtalho() {\r\n      if (pendingHotkey !== null) {\r\n        hotkey = pendingHotkey;\r\n        if (window.sketchup) {\r\n          window.sketchup.set_hotkey(hotkey.keyCode, hotkey.ctrl, hotkey.alt, hotkey.shift);\r\n        }\r\n      }\r\n      capturingHotkey = false;\r\n      document.getElementById(\"hotkey_edit\").classList.remove(\"visible\");\r\n    }\r\n\r\n    /* --- Global bindings --- */\r\n    window.captureVisionFromRuby = captureVisionFromRuby;\r\n    window.resetPlayButton = resetPlayButton;\r\n    window.pauseAtIndex = pauseAtIndex;\r\n    window.triggerSpaceFromRuby = triggerSpaceFromRuby;\r\n    window.showRecordingIndicator = showRecordingIndicator;\r\n    window.hideRecordingIndicator = hideRecordingIndicator;\r\n    window.updatePlayhead = updatePlayhead;\r\n    window.resetPlayAll = resetPlayAll;\r\n    window.startRecordingPlayAll = startRecordingPlayAll;\r\n    window.addEventListener(\"resize\", () => { renderMarkers(); });\r\n\r\n    document.addEventListener(\"keydown\", (e) => {\r\n      if (!capturingHotkey &&\r\n          e.keyCode === hotkey.keyCode &&\r\n          e.ctrlKey === hotkey.ctrl &&\r\n          e.altKey === hotkey.alt &&\r\n          e.shiftKey === hotkey.shift &&\r\n          ![\"INPUT\", \"TEXTAREA\"].includes(e.target.tagName)) {\r\n        e.preventDefault(); togglePlay();\r\n      }\r\n    });\r\n\r\n    /* Init */\r\n    populatePresets();\r\n    renderMarkers();\r\n</script>\r\n</body>\r\n</html>\r\nHTML\r\n\r\n      @dialog ||= UI::HtmlDialog.new({\r\n        :dialog_title => \"Tour Virtual\",\r\n        :preferences_key => \"com.example.tour\",\r\n        :scrollable => true,\r\n        :resizable => true,\r\n        :width => 430,\r\n        :height => 790,\r\n        :style => UI::HtmlDialog::STYLE_DIALOG\r\n      })\r\n\r\n      @dialog.set_html(html)\r\n      start_space_timer\r\n\r\n      @dialog.add_action_callback(\"set_hotkey\") do |_, key_code, ctrl, alt, shift|\r\n        GlobalKey.set_hotkey(key_code.to_i, ctrl, alt, shift)\r\n        Sketchup.write_default(\"TourVirtual\", \"Hotkey\", key_code.to_i)\r\n        Sketchup.write_default(\"TourVirtual\", \"HotkeyCtrl\", ctrl ? true : false)\r\n        Sketchup.write_default(\"TourVirtual\", \"HotkeyAlt\", alt ? true : false)\r\n        Sketchup.write_default(\"TourVirtual\", \"HotkeyShift\", shift ? true : false)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"capture_camera\") do |_, time_code|\r\n        cam = Sketchup.active_model.active_view.camera\r\n        thumb = capture_thumbnail\r\n        camera_data = {\r\n          time: time_code.to_f,\r\n          eye: cam.eye.to_a,\r\n          target: cam.target.to_a,\r\n          up: cam.up.to_a,\r\n          fov: cam.fov,\r\n          perspective: cam.perspective?,\r\n          thumb: thumb,\r\n          anchor: false\r\n        }\r\n        json_str = camera_data.to_json.gsub('\"', '\\\"')\r\n        @dialog.execute_script(\"captureVisionFromRuby(\\\"#{json_str}\\\")\")\r\n      end\r\n\r\n      @dialog.add_action_callback(\"goto_camera\") do |_, cam_json|\r\n        cam_data = JSON.parse(cam_json, symbolize_names: true)\r\n        cam = Sketchup::Camera.new(cam_data[:eye], cam_data[:target], cam_data[:up], cam_data[:perspective])\r\n        cam.fov = cam_data[:fov]\r\n        Sketchup.active_model.active_view.camera = cam\r\n      end\r\n\r\n      @dialog.add_action_callback(\"play_tour\") do |_, json_data, loop_enabled, inverse_mode, use_easing, start_index|\r\n        @camera_keys = JSON.parse(json_data, symbolize_names: true)\r\n        view = Sketchup.active_model.active_view\r\n        return if @camera_keys.length < 2\r\n        @camera_keys.sort_by! { |v| v[:time] }\r\n        @index = start_index.to_i\r\n        @direction = 1\r\n        @ping_pong = loop_enabled && inverse_mode\r\n\r\n        define_singleton_method(:ease_in_out_quad) do |t|\r\n          t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t\r\n        end\r\n\r\n        define_singleton_method(:catmull_rom) do |p0, p1, p2, p3, t|\r\n          t2 = t * t\r\n          t3 = t2 * t\r\n          [\r\n            0.5 * ((2 * p1[0]) + (-p0[0] + p2[0]) * t + (2*p0[0] - 5*p1[0] + 4*p2[0] - p3[0]) * t2 + (-p0[0] + 3*p1[0] - 3*p2[0] + p3[0]) * t3),\r\n            0.5 * ((2 * p1[1]) + (-p0[1] + p2[1]) * t + (2*p0[1] - 5*p1[1] + 4*p2[1] - p3[1]) * t2 + (-p0[1] + 3*p1[1] - 3*p2[1] + p3[1]) * t3),\r\n            0.5 * ((2 * p1[2]) + (-p0[2] + p2[2]) * t + (2*p0[2] - 5*p1[2] + 4*p2[2] - p3[2]) * t2 + (-p0[2] + 3*p1[2] - 3*p2[2] + p3[2]) * t3)\r\n          ]\r\n        end\r\n\r\n        define_singleton_method(:catmull_rom_1d) do |p0, p1, p2, p3, t|\r\n          t2 = t * t\r\n          t3 = t2 * t\r\n          0.5 * ((2 * p1) + (-p0 + p2) * t + (2*p0 - 5*p1 + 4*p2 - p3) * t2 + (-p0 + 3*p1 - 3*p2 + p3) * t3)\r\n        end\r\n\r\n        define_singleton_method(:play_transition) do\r\n          current = @camera_keys[@index]\r\n          next_index = @index + @direction\r\n\r\n          if next_index >= @camera_keys.size || next_index < 0\r\n            if loop_enabled\r\n               @index = 0\r\n               UI.start_timer(0.01) { play_transition }\r\n               return\r\n            else\r\n              @dialog.execute_script(\"pauseAtIndex(0)\")\r\n              return\r\n            end\r\n          end\r\n\r\n          next_cam = @camera_keys[next_index]\r\n          duration = (next_cam[:time] - current[:time]).abs\r\n          t_start = Time.now\r\n\r\n          p0 = @camera_keys[[@index - 1, 0].max]\r\n          p1 = current\r\n          p2 = next_cam\r\n          p3 = @camera_keys[[@index + 2, @camera_keys.size - 1].min]\r\n\r\n          @walk_shake = {\r\n            z_phase: rand * Math::PI * 2, x_phase: rand * Math::PI * 2,\r\n            z_amp: 0.8 + rand * 0.4, x_amp: 0.3 + rand * 0.4\r\n          }\r\n          playhead_counter = 0\r\n\r\n          @timer_id = UI.start_timer(0.03, true) do\r\n            t_elapsed = Time.now - t_start\r\n            t = duration.zero? ? 1.0 : [t_elapsed / duration, 1.0].min\r\n            t = use_easing ? ease_in_out_quad(t) : t\r\n\r\n            # Atualizar playhead na timeline (~a cada 0.09s)\r\n            playhead_counter += 1\r\n            if playhead_counter % 3 == 0\r\n              interpolated_time = current[:time] + t * (next_cam[:time] - current[:time])\r\n              @dialog.execute_script(\"updatePlayhead(#{interpolated_time.round(1)})\")\r\n            end\r\n\r\n            eye    = catmull_rom(p0[:eye],    p1[:eye],    p2[:eye],    p3[:eye],    t)\r\n            target = catmull_rom(p0[:target], p1[:target], p2[:target], p3[:target], t)\r\n            up     = catmull_rom(p0[:up],     p1[:up],     p2[:up],     p3[:up],     t)\r\n\r\n            # Interpolação Catmull-Rom para o FOV: suavidade total acompanhando a curva da câmera\r\n            fov = catmull_rom_1d(p0[:fov], p1[:fov], p2[:fov], p3[:fov], t)\r\n\r\n            if current[:walk]\r\n              eye[2] += Math.sin(t * Math::PI * 6 + @walk_shake[:z_phase]) * @walk_shake[:z_amp]\r\n              eye[0] += Math.sin(t * Math::PI * 3 + @walk_shake[:x_phase]) * @walk_shake[:x_amp]\r\n            end\r\n\r\n            cam = Sketchup::Camera.new(eye, target, up, current[:perspective])\r\n            cam.fov = fov\r\n            view.camera = cam\r\n            view.refresh\r\n\r\n            if t >= 1.0\r\n              UI.stop_timer(@timer_id)\r\n              @index = next_index\r\n              if @camera_keys[@index][:anchor] && @index > 0\r\n                @dialog.execute_script(\"pauseAtIndex(#{@index})\")\r\n              else\r\n                play_transition\r\n              end\r\n            end\r\n          end\r\n        end\r\n\r\n        play_transition\r\n      end\r\n\r\n      # Callback de exportação com presets de resolução\r\n      @dialog.add_action_callback(\"start_export_process\") do |_, json_data, use_easing, start_index, width, height, filename|\r\n        iniciar_processo_exportacao(json_data, use_easing, start_index, width.to_i, height.to_i, filename.to_s)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"start_export_project\") do |_, all_timelines_json, use_easing, active_tl_index, start_vision_index, width, height, filename|\r\n        iniciar_processo_exportacao_projeto(all_timelines_json, use_easing, active_tl_index.to_i, start_vision_index.to_i, width.to_i, height.to_i, filename.to_s)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"install_ffmpeg\") do |_|\r\n        eval(FFMPEG_INSTALL_SCRIPT, TOPLEVEL_BINDING)\r\n        UI.messagebox(\"FFmpeg instalado. Execute o Tour Virtual novamente.\")\r\n      end\r\n\r\n      @dialog.add_action_callback(\"stop_tour\") do |_|\r\n        UI.stop_timer(@timer_id) if @timer_id\r\n        @dialog.execute_script(\"resetPlayButton()\")\r\n      end\r\n\r\n      @dialog.add_action_callback(\"show_export_preview\") do |_, width, height|\r\n        @preview_tool = ExportPreviewTool.new(width.to_i, height.to_i)\r\n        Sketchup.active_model.select_tool(@preview_tool)\r\n      end\r\n\r\n      @dialog.add_action_callback(\"hide_export_preview\") do |_|\r\n        Sketchup.active_model.select_tool(nil)\r\n        @preview_tool = nil\r\n      end\r\n\r\n      @dialog.set_on_closed {\r\n        UI.stop_timer(@timer_id) if defined?(@timer_id) && @timer_id\r\n        stop_space_timer\r\n        if @preview_tool\r\n          Sketchup.active_model.select_tool(nil)\r\n          @preview_tool = nil\r\n        end\r\n      }\r\n\r\n      @dialog.show\r\n    end\r\n  end\r\nend\r\n\r\nTourPlugin::CameraTimeline.start_ui"
    },
    "enabled": false,
    "execute": true
  }
]